( function _aFileProvider_test_s_()
{

'use strict';

let crypto;
if( typeof module !== 'undefined' )
{
  let _ = require( '../../../wtools/Tools.s' );
  require( '../l4_files/entry/Files.s' );
  _.include( 'wTesting' );
  crypto = require( 'crypto' );
}

let _ = _global_.wTools;

// --
// context
// --

function onSuiteBegin( test )
{
  let context = this;
}

//

function onSuiteEnd()
{
  let path = this.provider.path;
  _.assert( _.strHas( this.suiteTempPath, '.tmp' ) );
  debugger;
  path.tempClose( this.suiteTempPath );
  debugger;
  this.provider.finit();
  this.system.finit();
}

//

function onRoutineEnd( test )
{
  let context = this;
  let provider = context.provider;
  let system = context.system;
  let path = context.provider.path;
  _.sure( _.arraySetIdentical( _.mapKeys( system.providersWithProtocolMap ), [ 'second', 'current' ] ), test.name, 'has not restored system!' );
}

//

function assetFor( test, a )
{
  let context = this;

  if( !_.mapIs( a ) )
  {
    if( _.boolIs( arguments[ 1 ] ) )
    a = { originalAssetPath : arguments[ 1 ] }
    else
    a = { assetName : arguments[ 1 ] }
  }

  if( !a.fileProvider )
  {
    a.fileProvider = context.providerMake();
  }

  a.suiteTempPath = a.fileProvider.path.tempOpen( a.fileProvider.constructor.name );

  let system = a.system;
  let effectiveProvider = a.effectiveProvider;
  let global = a.global;

  a = test.assetFor( a );

  if( !system )
  {
    if( a.fileProvider.system )
    a.system = a.fileProvider.system;
    else if( a.fileProvider instanceof _.FileProvider.System )
    a.system = a.fileProvider;
  }

  if( !effectiveProvider )
  {
    if( !( a.fileProvider instanceof _.FileProvider.System ) )
    a.effectiveProvider = a.fileProvider;
    else if( a.fileProvider.defaultProvider )
    a.effectiveProvider = a.fileProvider.defaultProvider;
  }

  _.assert( a.effectiveProvider instanceof _.FileProvider.Abstract, 'effectiveProvider is not specificed' );

  if( !global )
  a.global = globalFor;

  return a;

  function globalFor()
  {
    let a = this;
    let abs = a.abs( ... arguments );
    let result = a.system.path.s.join( a.effectiveProvider.protocol + '://', abs );
    return result;
  }

}

// {
//   let context = this;
//
//   if( !_.mapIs( a ) )
//   {
//     if( _.boolIs( arguments[ 1 ] ) )
//     a = { originalAssetPath : arguments[ 1 ] }
//     else
//     a = { assetName : arguments[ 1 ] }
//   }
//
//   if( !a.fileProvider )
//   {
//     a.fileProvider = context.providerMake();
//   }
//
//   a.suiteTempPath = a.fileProvider.path.tempOpen( a.fileProvider.constructor.name );
//
//   a = test.assetFor( a );
//
//   if( !a.system )
//   {
//     if( a.fileProvider.system )
//     a.system = a.fileProvider.system;
//     else if( a.fileProvider instanceof _.FileProvider.System )
//     a.system = a.fileProvider;
//   }
//
//   if( !a.effectiveProvider )
//   {
//     if( !( a.fileProvider instanceof _.FileProvider.System ) )
//     a.effectiveProvider = a.fileProvider;
//     else if( a.fileProvider.defaultProvider )
//     a.effectiveProvider = a.fileProvider.defaultProvider;
//   }
//
//   _.assert( a.effectiveProvider instanceof _.FileProvider.Abstract, 'effectiveProvider is not specificed' );
//
//   return a;
// }

//

function pathFor( filePath )
{
  let path = this.provider.path;
  filePath =  path.join( this.suiteTempPath, filePath );
  return path.normalize( filePath );
}

//

function providerIsInstanceOf( src ) /* qqq : eliminate. move special code to special test suites */
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( provider instanceof src )
  return true;

  if( _.FileProvider.System && provider instanceof _.FileProvider.System )
  {
    var routinePath = context.pathFor( 'routinePath' );
    var provider2 = provider.providerForPath( routinePath );
    if( provider2 instanceof src )
    return true;
  }

  return false;
}

//

function softLinkIsSupported()
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( Config.interpreter === 'njs' && typeof process !== undefined )
  if( process.platform === 'win32' )
  {
    var allowed = false;
    var routinePath = context.pathFor( 'softLinkIsSupported' );
    var srcPath = context.pathFor( 'softLinkIsSupported/src' );
    var dstPath = context.pathFor( 'softLinkIsSupported/dst' );

    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );

    try
    {
      provider.softLink({ dstPath, srcPath, throwing : 1, sync : 1 });
      allowed = provider.isSoftLink( dstPath );
    }
    catch( err )
    {
      logger.error( err );
    }

    return allowed;
  }

  return true;
}

// --
// tests
// --

function testDelaySample( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  test.case = 'delay test';

  var con = _.time.out( 1000 );

  test.identical( 1, 1 );

  con.finally( function( ){ logger.log( '1000ms delay' ) } );

  con.finally( _.routineSeal( _, _.time.out, [ 1000 ] ) );

  con.finally( function( ){ logger.log( '2000ms delay' ) } );

  con.finally( function( ){ test.identical( 1, 1 ); } );

  return con;
}

//

function mustNotThrowError( test )
{

  /**/

  test.case = 'mustNotThrowError must return con with message';

  var con = new _.Consequence().take( '123' );
  test.mustNotThrowError( con )
  .ifNoErrorThen( function( got )
  {
    test.identical( got, '123' );
    return null;
  })

}

//

function readWriteSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWriteAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var routinePath = path.normalize( test.context.pathFor( 'written/readWriteSync' ) );
  var got, filePath, readOptions, writeOptions;
  var testData = 'Lorem ipsum dolor sit amet';

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  test.case = 'fileRead, invalid path';

  /**/

  // test.shouldThrowErrorSync( function()
  // {
  //   provider.fileRead
  //   ({
  //     filePath : 'invalid path',
  //     sync : 1,
  //     throwing : 1,
  //   })
  // });
  /* - */
  // /**/
  /* - */
  // test.mustNotThrowError( function()
  // {
  //   debugger
  //   var got = provider.fileRead
  //   ({
  //     filePath : test.context.pathFor( 'invalid path' ),
  //     sync : 1,
  //     throwing : 0,
  //   });
  //   test.identical( got, null );
  // })
  /* - */
  // /* - */
  /* - */
  // test.case = 'fileRead, path ways to not a terminal file';
  // filePath = test.context.pathFor( 'written/readWriteSync/dir' );
  // provider.dirMake( filePath );
  /* - */
  // /**/
  /* - */
  // test.shouldThrowErrorSync( function()
  // {
  //   provider.fileRead
  //   ({
  //     filePath,
  //     sync : 1,
  //     throwing : 1,
  //   })
  // });
  /* - */
  // /**/
  /* - */
  // test.mustNotThrowError( function()
  // {
  //   var got = provider.fileRead
  //   ({
  //     filePath,
  //     sync : 1,
  //     throwing : 0,
  //   });
  //   test.identical( got, null );
  // });
  /* - */
  // /* - */
  /* - */
  // test.case = 'fileRead, simple file read ';
  // provider.filesDelete( routinePath );
  // filePath = test.context.pathFor( 'written/readWriteSync/file' );
  // provider.fileWrite( filePath, testData );
  // var files = provider.dirRead( routinePath );
  // test.identical( files, [ 'file' ] );
  /* - */
  // /**/
  /* - */
  // test.mustNotThrowError( function()
  // {
  //   got = provider.fileRead
  //   ({
  //     filePath,
  //     sync : 1,
  //     encoding : 'utf8',
  //     throwing : 1,
  //   })
  // });
  // test.identical( got, testData );
  /* - */
  // /**/
  /* - */
  // test.shouldThrowErrorSync( function()
  // {
  //   provider.fileRead
  //   ({
  //     filePath,
  //     sync : 1,
  //     encoding : 'unknown',
  //     throwing : 1,
  //   })
  // });
  /* - */
  // /**/
  /* - */
  // test.mustNotThrowError( function()
  // {
  //   var got = provider.fileRead
  //   ({
  //     filePath,
  //     sync : 1,
  //     encoding : 'unknown',
  //     throwing : 0,
  //   });
  //   test.identical( got, null );
  // });
  /* - */
  // /* - */
  /* - */
  // test.case = 'fileRead, file read with common encodings';
  // provider.filesDelete( routinePath );
  // filePath = test.context.pathFor( 'written/readWriteSync/file' );
  /* - */
  // /**/
  /* - */
  // testData = { a : 'abc' };
  // provider.fileWrite( filePath, JSON.stringify( testData ) );
  // got = provider.fileRead
  // ({
  //   filePath,
  //   sync : 1,
  //   encoding : 'json',
  //   throwing : 1,
  // });
  // test.identical( got, testData );
  /* - */
  // /**/
  /* - */
  // var isHd = context.providerIsInstanceOf( _.FileProvider.HardDrive );
  /* - */
  // if( isHd )
  // testData = 'module.exports = { a : 1 }';
  // else
  // testData = '1 + 2';
  /* - */
  // provider.fileWrite( filePath, testData );
  // got = provider.fileRead
  // ({
  //   filePath,
  //   sync : 1,
  //   encoding : isHd ? 'js.node' : 'js.structure',
  //   throwing : 1,
  // });
  /* - */
  // if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
  //   test.identical( got, { a : 1 } );
  // }
  // else
  // {
  //   var expected = _.exec
  //   ({
  //     code : testData,
  //     filePath,
  //     prependingReturn : 1,
  //   });
  //   test.identical( got, expected );
  // }
  /* - */
  // /**/
  /* - */
  // testData = filePath;
  // provider.fileWrite( filePath, testData );
  // got = provider.fileRead
  // ({
  //   filePath,
  //   sync : 1,
  //   encoding : 'original.type',
  //   throwing : 1,
  // });
  /* - */
  // if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
  //   test.is( _.bufferBytesIs( got ) )
  //   test.identical( got, _.bufferBytesFrom( BufferNode.from( testData ) ) );
  // }
  // else
  // {
  //   test.identical( got, testData );
  // }
  /* - */
  // /**/
  /* - */
  // test.shouldThrowErrorOfAnyKind( () =>
  // {
  //   provider.fileRead
  //   ({
  //     filePath,
  //     sync : 1,
  //     encoding : 'abcde',
  //     throwing : 1,
  //   });
  // })
  /* - */
  // /**/
  /* - */
  // test.mustNotThrowError( () =>
  // {
  //   var got = provider.fileRead
  //   ({
  //     filePath,
  //     sync : 1,
  //     encoding : 'abcde',
  //     throwing : 0,
  //   });
  //   test.identical( got, null );
  // })
  /* - */
  // /**/
  /* - */
  // test.case = 'encoder not finded';
  // var encoding = 'unknown';
  // test.identical( _.files.ReadEncoders[ encoding ], undefined );
  // test.shouldThrowErrorOfAnyKind( () =>
  // {
  //   provider.fileRead
  //   ({
  //     filePath,
  //     sync : 1,
  //     throwing : 1,
  //     encoding
  //   });
  // });
  /* - */
  // /* - */
  /* - */
  // if( Config.interpreter === 'njs' )
  // {
  //   test.case = 'other encodings';
  //   provider.filesDelete( routinePath );
  //   filePath = test.context.pathFor( 'written/readWriteSync/file' );
  //   testData = 'abc';
  /* - */
  //   provider.fileWrite( filePath, testData );
  //   got = provider.fileRead
  //   ({
  //     filePath,
  //     sync : 1,
  //     encoding : 'buffer.node',
  //     throwing : 1,
  //   });
  //   test.is( _.bufferNodeIs( got ) );
  /* - */
  //   provider.fileWrite( filePath, testData );
  //   got = provider.fileRead
  //   ({
  //     filePath,
  //     sync : 1,
  //     encoding : 'buffer.raw',
  //     throwing : 1,
  //   });
  //   test.is( _.bufferRawIs( got ) );
  // }

  /* - */

  test.case = 'fileRead, onBegin, onEnd, onError';
  provider.filesDelete( routinePath );
  filePath = test.context.pathFor( 'written/readWriteSync/file' );
  testData = 'Lorem ipsum dolor sit amet';
  function onBegin( err, o )
  {
    if( err )
    return;

    provider.fileWrite( filePath, testData );
    if( o )
    got = o;
  }
  function onEnd( err, data )
  {
    if( !err )
    got = data;
  }
  function onError( err )
  {
    got = err;
  }

  /* onBegin outputFormat : 'o' */

  debugger;
  got = provider.fileRead
  ({
    sync : 1,
    outputFormat : 'o',
    throwing : 1,
    filePath,
    encoding : 'utf8',
    onBegin,
    onEnd : null,
    onError : null,
  });
  debugger;
  test.identical( got.result, testData );

  /*onBegin returningRead 1*/

  var got = provider.fileRead
  ({
    sync : 1, /* qqq : write separate test routine for each option */
    outputFormat : 'data',
    throwing : 1,
    filePath,
    encoding : 'utf8',
    onBegin,
    onEnd : null,
    onError : null,
  });
  debugger;
  test.identical( _.objectIs( got ), false );

  /*onEnd returningRead 0*/

  var got = provider.fileRead
  ({
    sync : 1,
    outputFormat : 'o',
    throwing : 1,
    filePath,
    encoding : 'utf8',
    onBegin : null,
    onEnd,
    onError : null,
  });
  test.identical( got.result, testData );

  /*onEnd returningRead 1*/

  debugger;
  var got = provider.fileRead
  ({
    sync : 1,
    outputFormat : 'data',
    throwing : 1,
    filePath,
    encoding : 'utf8',
    onBegin : null,
    onEnd,
    onError : null,
  });
  debugger;
  test.identical( got, testData );
  debugger;

  /*onError is no called*/

  debugger;
  test.shouldThrowErrorSync( function()
  {
    var got = provider.fileRead
    ({
      sync : 1,
      outputFormat : 'o',
      throwing : 1,
      filePath : test.context.pathFor( 'invalid path' ),
      encoding : 'utf8',
      onBegin : null,
      onEnd : null,
      onError,
    });
  });
  debugger;
  test.identical( _.errIs( got ), true )
  debugger;

  /*onError is no called*/

  test.shouldThrowErrorSync( function()
  {
    provider.fileRead
    ({
      sync : 1,
      outputFormat : 'data',
      throwing : 1,
      filePath : test.context.pathFor( 'invalid path' ),
      encoding : 'utf8',
      onBegin : null,
      onEnd : null,
      onError,
    });
  });
  test.identical( _.errIs( got ), true );

  /*onError is no called*/

  test.mustNotThrowError( function()
  {
    provider.fileRead
    ({
      sync : 1,
      outputFormat : 'o',
      throwing : 0,
      filePath : test.context.pathFor( 'invalid path' ),
      encoding : 'utf8',
      onBegin : null,
      onEnd : null,
      onError,
    });
  });
  test.identical( _.errIs( got ), true );

  /*onError is no called*/

  test.shouldThrowErrorSync( function()
  {
    provider.fileRead
    ({
      sync : 1,
      outputFormat : 'o',
      throwing : 1,
      filePath : test.context.pathFor( 'invalid path' ),
      encoding : 'utf8',
      onBegin : null,
      onEnd : null,
      onError,
    });
  });
  test.identical( _.errIs( got ), true );

  /* - */

  test.case = 'fileWrite, path not exist, default settings';
  filePath = test.context.pathFor( 'written/readWriteSync/file' );
  testData = 'Lorem ipsum dolor sit amet';

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  test.identical( got, testData );

  /* path includes not existing directory */

  provider.filesDelete( routinePath );
  filePath = test.context.pathFor( 'written/readWriteSync/files/file' );
  provider.fileWrite( filePath, testData );
  var files = provider.dirRead( context.provider.path.dir( filePath ) );
  test.identical( files, [ 'file' ] );
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  test.identical( got, testData );

  /* - */

  test.case = 'fileWrite, path already exist, default settings';
  filePath = test.context.pathFor( 'written/readWriteSync/file' );
  testData = 'Lorem ipsum dolor sit amet';
  provider.fileWrite( filePath, testData );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  test.identical( got, testData );

  /*try rewrite folder*/
  test.shouldThrowErrorSync( function()
  {
    provider.fileWrite( routinePath, testData );
  });

  /* - */

  test.case = 'fileWrite, path already exist';
  provider.filesDelete( routinePath );
  filePath = test.context.pathFor( 'written/readWriteSync/file' );
  testData = 'Lorem ipsum dolor sit amet';
  provider.fileWrite( filePath, testData );

  /**/

  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    makingDirectory : 1,
    purging : 1,
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  test.identical( got, testData );

  /**/

  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    makingDirectory : 0,
    purging : 1,
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  test.identical( got, testData );

  /**/

  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    makingDirectory : 0,
    purging : 0,
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  test.identical( got, testData );

  /* - */

  test.case = 'fileWrite, path not exist';
  provider.filesDelete( routinePath );
  testData = 'Lorem ipsum dolor sit amet';
  filePath = test.context.pathFor( 'written/readWriteSync/file' );


  /*path includes not existing directory*/

  test.shouldThrowErrorSync( function()
  {
    provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 1,
      makingDirectory : 0,
      purging : 0,
    });
  });

  var files = provider.dirRead( routinePath );
  test.identical( files, null );

  /*file not exist*/

  provider.dirMake( routinePath );
  test.mustNotThrowError( function()
  {
    provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 1,
      makingDirectory : 0,
      purging : 0,
    });
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  test.identical( got, testData );

  /*purging non existing filePath*/

  provider.filesDelete( filePath );
  test.mustNotThrowError( function()
  {
    provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 1,
      makingDirectory : 0,
      purging : 1,
    });
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  test.identical( got, testData );

  /* - */

  test.case = 'fileWrite, different write modes';
  provider.filesDelete( routinePath );
  testData = 'Lorem ipsum dolor sit amet';
  filePath = test.context.pathFor( 'written/readWriteSync/file' );

  /*rewrite*/

  provider.fileWrite( filePath, ' ' );
  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    writeMode : 'rewrite'
  });
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  test.identical( got, testData );

  /*prepend*/

  provider.fileWrite( filePath, testData );
  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    writeMode : 'prepend'
  });
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  test.identical( got, testData+testData );

  /*append*/

  provider.fileWrite( filePath, testData );
  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    writeMode : 'append'
  });
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  test.identical( got, testData+testData );

  /* - */

  test.case = 'fileWrite, any writeMode should create file it not exist';
  provider.filesDelete( routinePath );
  testData = 'Lorem ipsum dolor sit amet';
  filePath = test.context.pathFor( 'written/readWriteSync/file' );

  /*rewrite*/

  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    writeMode : 'rewrite'
  });
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  test.identical( got, testData );

  /*prepend*/

  provider.filesDelete( filePath );
  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    writeMode : 'prepend'
  });
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  test.identical( got, testData );

  /*append*/

  provider.filesDelete( filePath );
  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    writeMode : 'append'
  });
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  test.identical( got, testData );

  /* - */

  var softLinkIsSupported = test.context.softLinkIsSupported();

  /* - */

  if( softLinkIsSupported )
  {
    /* resolvingSoftLink */

    test.case = 'read from soft link, resolvingSoftLink on';
    var data1 = 'data';
    provider.fieldPush( 'resolvingSoftLink', 1 );
    provider.fileWrite( filePath, data1 );
    var linkPath1 = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath1, filePath );
    var got1 = provider.fileRead( linkPath1 );
    test.identical( got1, data1);
    provider.fieldPop( 'resolvingSoftLink', 1 );

    test.case = 'read from soft link, resolvingSoftLink off';
    var data1 = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    provider.fileWrite( filePath, data1 );
    var linkPath1 = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath1, filePath );
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.fileRead({ linkPath1, resolvingSoftLink : 0 });
    });
    provider.fieldPop( 'resolvingSoftLink', 0 );

    test.case = 'write using link, resolvingSoftLink on';
    var data1 = 'data';
    provider.fieldPush( 'resolvingSoftLink', 1 );
    provider.fileWrite( filePath, data1 );
    var linkPath1 = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath1, filePath );
    provider.fileWrite( linkPath1, data1 + data1 );
    var got1 = provider.fileRead( filePath );
    test.identical( got1, data1 + data1 );
    provider.fieldPop( 'resolvingSoftLink', 1 );

    /* - */

    test.case = 'write using link, resolvingSoftLink off';
    var data1 = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    provider.fileWrite( filePath, data1 );
    var linkPath1 = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath1, filePath );
    provider.fileWrite( linkPath1, data1 + data1 );
    var got1 = provider.fileRead( filePath );
    test.identical( got1, data1 );
    var got1 = provider.fileRead( linkPath1 );
    test.identical( got1, data1 + data1 );
    provider.fieldPop( 'resolvingSoftLink', 0 );

    test.case = 'write using link, resolvingSoftLink off';
    var data1 = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    provider.fileWrite( filePath, data1 );
    var linkPath1 = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath1, filePath );
    provider.fileWrite
    ({
      filePath : linkPath1,
      writeMode : 'append',
      data : data1,
    });
    var got1 = provider.fileRead( filePath );
    test.identical( got1, data1 );
    var got1 = provider.fileRead( linkPath1 );
    test.identical( got1, data1 + data1 );
    provider.fieldPop( 'resolvingSoftLink', 0 );

    test.case = 'write using link, resolvingSoftLink off';
    var data1 = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    provider.fileWrite( filePath, data1 );
    var linkPath1 = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath1, filePath );
    provider.fileWrite
    ({
      filePath : linkPath1,
      writeMode : 'append',
      encoding : 'original.type',
      data : data1
    });
    var got1 = provider.fileRead( filePath );
    test.identical( got1, data1 );
    var got1 = provider.fileRead( linkPath1 );
    test.identical( got1, data1 + data1 );
    provider.fieldPop( 'resolvingSoftLink', 0 );

    test.case = 'write using link, resolvingSoftLink off';
    var data1 = _.bufferBytesFrom( 'abc' );
    provider.fieldPush( 'resolvingSoftLink', 0 );
    provider.fileWrite
    ({
      filePath,
      encoding : 'original.type',
      data : data1,
    });
    var linkPath1 = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath1, filePath );
    var appendData = 'abc';
    provider.fileWrite
    ({
      filePath : linkPath1,
      writeMode : 'append',
      encoding : 'original.type',
      data : appendData
    });
    var got1 = provider.fileRead({ filePath, encoding : 'original.type' });
    test.identical( got1, data1 );
    var got1 = provider.fileRead({ filePath : linkPath1, encoding : 'original.type' });
    test.is( _.bufferBytesIs( got1 ) );
    test.identical( got1, _.bufferBytesFrom( appendData + appendData ) );
    provider.fieldPop( 'resolvingSoftLink', 0 );

    test.case = 'write using link, resolvingSoftLink off';
    var data1 = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    provider.fileWrite( filePath, data1 );
    var linkPath1 = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath1, filePath );
    provider.fileWrite
    ({
      filePath : linkPath1,
      writeMode : 'prepend',
      data : '1'
    });
    var got1 = provider.fileRead( filePath );
    test.identical( got1, data1 );
    var got1 = provider.fileRead( linkPath1 );
    test.identical( got1, '1' + data1 );
    provider.fieldPop( 'resolvingSoftLink', 0 );

    test.case = 'write using link, resolvingSoftLink off';
    var data1 = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    provider.fileWrite( filePath, data1 );
    var linkPath1 = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath1, filePath );
    provider.fileWrite
    ({
      filePath : linkPath1,
      writeMode : 'prepend',
      encoding : 'original.type',
      data : '1'
    });
    var got1 = provider.fileRead( filePath );
    test.identical( got1, data1 );
    var got1 = provider.fileRead( linkPath1 );
    test.identical( got1, '1' + data1 );
    provider.fieldPop( 'resolvingSoftLink', 0 );

    test.case = 'write using link, resolvingSoftLink off';
    var data1 = _.bufferBytesFrom( 'abc' );
    provider.fieldPush( 'resolvingSoftLink', 0 );
    provider.fileWrite
    ({
      filePath,
      encoding : 'original.type',
      data : data1,
    });
    var linkPath1 = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath1, filePath );
    var appendData = 'abc';
    provider.fileWrite
    ({
      filePath : linkPath1,
      writeMode : 'prepend',
      encoding : 'original.type',
      data : appendData
    });
    var got1 = provider.fileRead({ filePath, encoding : 'original.type' });
    test.identical( got1, data1 );
    var got1 = provider.fileRead({ filePath : linkPath1, encoding : 'original.type' });
    test.is( _.bufferBytesIs( got1 ) );
    test.identical( got1, _.bufferBytesFrom( appendData + appendData ) );
    provider.fieldPop( 'resolvingSoftLink', 0 );

  }

  /* - */

  if( Config.interpreter === 'njs' )
  {
    test.case = 'fileWrite, data is raw buffer';
    provider.filesDelete( routinePath );
    testData = 'Lorem ipsum dolor sit amet';
    var buffer = _.bufferRawFrom( BufferNode.from( testData ) );
    filePath = test.context.pathFor( 'written/readWriteSync/file' );

    /**/

    provider.fileWrite( filePath, buffer );
    got = provider.fileRead
    ({
      filePath,
      sync : 1,
    });
    var files1 = provider.dirRead( routinePath );
    test.identical( files1, [ 'file' ] );
    test.identical( got, testData );

    if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    {
      test.case = 'typed buffer'
      buffer = new U16x( buffer );
      provider.fileWrite( filePath, buffer );
      got = provider.fileRead
      ({
        filePath,
        sync : 1,
      });
      test.identical( got, testData );

      test.case = 'node buffer'
      buffer = BufferNode.from( testData );
      provider.fileWrite( filePath, buffer );
      got = provider.fileRead
      ({
        filePath,
        sync : 1,
      });
      test.identical( got, testData );

      if( softLinkIsSupported )
      {
        test.case = 'write using link, resolvingSoftLink off';
        var data2 = 'data';
        provider.fieldPush( 'resolvingSoftLink', 0 );
        provider.fileWrite( filePath, data2 );
        var linkPath2 = test.context.pathFor( 'written/readWriteSync/link' );
        provider.softLink( linkPath2, filePath );
        provider.fileWrite
        ({
          filePath : linkPath2,
          writeMode : 'prepend',
          data : BufferNode.from( data2 )
        });
        var got2 = provider.fileRead( filePath );
        test.identical( got2, data2 );
        var got2 = provider.fileRead( linkPath2 );
        test.identical( got2, data2 + data2 );
        provider.fieldPop( 'resolvingSoftLink', 0 );

        test.case = 'write using link, resolvingSoftLink off';
        var data2 = 'data';
        provider.fieldPush( 'resolvingSoftLink', 0 );
        provider.fileWrite( filePath, data2 );
        var linkPath2 = test.context.pathFor( 'written/readWriteSync/link' );
        provider.softLink( linkPath2, filePath );
        provider.fileWrite
        ({
          filePath : linkPath2,
          writeMode : 'prepend',
          data : BufferNode.from( data2 ),
          encoding : 'original.type'
        });
        var got2 = provider.fileRead( filePath );
        test.identical( got2, data2 );
        var got2 = provider.fileRead( linkPath2 );
        test.identical( got2, data2 + data2 );
        provider.fieldPop( 'resolvingSoftLink', 0 );
      }
    }
  }

  if( context.providerIsInstanceOf( _.FileProvider.Extract ) )
  {
    var data3 = 'data';

    provider.fieldPush( 'safe', 0 );


    /* hardLink */

    // var resolvingHardLink = provider.resolvingHardLink;

    /* resolving on */

    // provider.fieldPush( 'resolvingHardLink', 1 );

    // test.case = 'read, hardLink to file that not exist';
    // var linkPath3 = '/linkToUnknown';
    // test.shouldThrowErrorOfAnyKind( () => provider.fileRead( linkPath3 ) );

    // test.case = 'write+read, hardLink to file that not exist';
    // var linkPath3 = '/linkToUnknown';
    // test.shouldThrowErrorOfAnyKind( () => provider.fileWrite( linkPath3, data3 ) );
    // test.shouldThrowErrorOfAnyKind( () => provider.fileRead( linkPath3 ) );

    // test.case = 'update file using hardLink, then read';
    // var linkPath3 = '/linkToTerminal';
    // var filePath3 = '/file';
    // provider.fileWrite( linkPath3, data3 );
    // var got3 = provider.fileRead( filePath3 );
    // test.identical( got3, data3 );

    // test.case = 'update file, then read it using hardLink';
    // var linkPath3 = '/linkToTerminal';
    // var filePath3 = '/file';
    // provider.fileWrite( filePath3, data3 + data3 );
    // var got3 = provider.fileRead( linkPath3 );
    // test.identical( got3, data3 + data3 );

    // test.case = 'hardLink to directory, read+write';
    // var linkPath3 = '/linkToDir';
    // test.shouldThrowErrorOfAnyKind( () => provider.fileRead( linkPath3 ) );
    // test.shouldThrowErrorOfAnyKind( () => provider.fileWrite( linkPath3, data3 ) );

    /* resolving off */

    // provider.fieldPush( 'resolvingHardLink', 0 );

    // test.case = 'resolving disabled, read using hardLink';
    // var linkPath3 = '/linkToTerminal';
    // test.shouldThrowErrorOfAnyKind( () => provider.fileRead( linkPath3 ) );

    // test.case = 'resolving disabled, write using hardLink, link becomes usual file';
    // var linkPath3 = '/linkToTerminal';
    // provider.fileWrite( linkPath3, data3 );
    // var got3 = provider.fileRead( linkPath3 );
    // test.identical( got3, data3 );
    // test.is( !provider.isHardLink( linkPath3 ) );

    /* - */

    // provider.fieldPop( 'resolvingHardLink', 0 );

    /* softLink */

    var resolvingSoftLink = provider.resolvingSoftLink;

    /* resolving on */

    provider.fieldPush( 'resolvingSoftLink', 1 );

    test.case = 'read, softLink to file that not exist';
    var linkPath3 = '/softLinkToUnknown';
    var filePath3 = '/unknown';
    // provider.filesDelete( filePath3 );
    test.shouldThrowErrorOfAnyKind( () => provider.fileRead( linkPath3 ) );

    test.case = 'write+read, softLink to file that not exist';
    var linkPath3 = '/softLinkToUnknown';
    // test.shouldThrowErrorOfAnyKind( () => provider.fileWrite( linkPath3, data3 ) );
    test.shouldThrowErrorOfAnyKind( () => provider.fileRead( linkPath3 ) );

    test.case = 'update file using softLink, then read';
    var linkPath3 = '/softLinkToFile';
    var filePath3 = '/file';
    provider.fileWrite( filePath3, '' );
    provider.softLink( linkPath3, filePath3 )
    provider.fileWrite( linkPath3, data3 );
    var got3 = provider.fileRead( filePath3 );
    test.identical( got3, data3 );

    test.case = 'update file, then read it using softLink';
    var linkPath3 = '/softLinkToFile';
    var filePath3 = '/file';
    provider.fileWrite( filePath3, data3 + data3 );
    var got3 = provider.fileRead( linkPath3 );
    test.identical( got3, data3 + data3 );

    test.case = 'softLink to directory, read+write';
    var filePath3 = '/dir';
    var linkPath3 = '/softLinkToDir';
    provider.dirMake( filePath3 );
    provider.softLink( linkPath3, filePath3 );
    test.shouldThrowErrorOfAnyKind( () => provider.fileRead( linkPath3 ) );
    test.shouldThrowErrorOfAnyKind( () => provider.fileWrite( linkPath3, data3 ) );

    test.case = 'softLink to file, file renamed';
    var linkPath3 = '/softLinkToFile';
    var filePath3 = '/file';
    var filePath3New = '/file_new';
    provider.fileWrite( filePath3, filePath3 );
    provider.softLink( linkPath3, filePath3 );
    provider.fileRename( filePath3New, filePath3 );
    test.shouldThrowErrorOfAnyKind( () => provider.fileRead( linkPath3 ) );
    // test.shouldThrowErrorOfAnyKind( () => provider.fileWrite( linkPath3, data3 ) );
    provider.fileRename( filePath3, filePath3New );


    /* resolving off */

    provider.fieldPush( 'resolvingSoftLink', 0 );

    test.case = 'resolving disabled, read using softLink';
    var linkPath3 = '/softLinkToFile';
    test.shouldThrowErrorOfAnyKind( () => provider.fileRead({ linkPath3, resolvingSoftLink : 0 }) );

    test.case = 'resolving disabled, write using softLink, link becomes usual file';
    var linkPath3 = '/softLinkToFile';
    provider.fileWrite( linkPath3, data3 );
    var got3 = provider.fileRead( linkPath3 );
    test.identical( got3, data3 );
    test.is( !provider.isSoftLink( linkPath3 ) );

    /* - */

    provider.fieldPop( 'resolvingSoftLink', 0 );
    provider.fieldPop( 'safe', 0 );
  }

  /* - */

  // var data1 = 'Lorem ipsum dolor sit amet, consectetur adipisicing elit';
  // provider.fileWrite
  // ({
  //   filePath : test.context.pathFor( 'written/readWriteSync/test.txt' ),
  //   data : data1,
  //   sync : 1,
  // });
  /* - */
  // test.case = 'single file is written';
  // var files = provider.dirRead( test.context.pathFor( 'written/readWriteSync/' ) );
  // test.identical( files, [ 'test.txt' ] );
  /* - */
  // test.case = 'synchronous, writeMode : rewrite';
  // var got = provider.fileRead
  // ({
  //   filePath : test.context.pathFor( 'written/readWriteSync/test.txt' ),
  //   sync : 1
  // });
  // var expected = data1;
  // test.identical( got, expected );
  /* - */
  // var data2 = 'LOREM';
  // provider.fileWrite
  // ({
  //   filePath : test.context.pathFor( 'written/readWriteSync/test.txt' ),
  //   data : data2,
  //   sync : 1,
  //   writeMode : 'append'
  // });
  /* - */
  // test.case = 'single file is written';
  // var files = provider.dirRead( test.context.pathFor( 'written/readWriteSync/' ) );
  // test.identical( files, [ 'test.txt' ] );
  /* - */
  // test.case = 'synchronous, writeMode : append';
  // var got = provider.fileRead
  // ({
  //   filePath : test.context.pathFor( 'written/readWriteSync/test.txt' ),
  //   sync : 1
  // });
  // var expected = data1 + data2;
  // test.identical( got, expected );
  /* - */
  // var data2 = 'LOREM';
  // provider.fileWrite
  // ({
  //   filePath : test.context.pathFor( 'written/readWriteSync/test.txt' ),
  //   data : data2,
  //   sync : 1,
  //   writeMode : 'prepend'
  // });
  /* - */
  // test.case = 'single file is written';
  // var files = provider.dirRead( test.context.pathFor( 'written/readWriteSync/' ) );
  // test.identical( files, [ 'test.txt' ] );
  /* - */
  // test.case = 'synchronous, writeMode : prepend';
  // var got = provider.fileRead
  // ({
  //   filePath : test.context.pathFor( 'written/readWriteSync/test.txt' ),
  //   sync : 1
  // });
  // var expected = data2 + data1 + data2;
  // test.identical( got, expected );
  /* - */
  // if( Config.debug )
  // {
  //   test.case = 'file doesn`t exist';
  //   test.shouldThrowErrorSync( function( )
  //   {
  //     provider.fileRead
  //     ({
  //       filePath : test.context.pathFor( 'unknown' ),
  //       sync : 1
  //     });
  //   });
  /* - */
  //   test.case = 'try to read dir';
  //   test.shouldThrowErrorSync( function( )
  //   {
  //     provider.fileRead
  //     ({
  //       filePath : test.context.pathFor( '/' ),
  //       sync : 1
  //     });
  //   });
  // }

}

//

function fileWriteActSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWriteAct ) )
  return;

  var isHd = test.context.providerIsInstanceOf( _.FileProvider.HardDrive );
  var isSystem = provider instanceof _.FileProvider.System;

  let data = 'Test data'

  /* - */

  test.case = 'normalized path, call fileWrite'
  var filePath = test.context.pathFor( 'write_test/file' );
  var o = _.mapExtend( null, provider.fileWriteAct.defaults );
  o.filePath = filePath;
  o.sync = 1;
  o.data = data;
  provider.dirMakeForFile( filePath )
  provider.fileWriteAct( o );
  test.identical( o.filePath, filePath );
  test.identical( provider.fileRead( filePath ), data );

  /* - */

  if( Config.debug )
  if( process.platform === 'win32' )
  if( !isSystem && isHd )
  {
    test.case = 'native path, call fileWrite_body'
    var filePath2 = test.context.pathFor( 'write_test/file' );
    provider.filesDelete( filePath2 )
    var o2 = _.mapExtend( null, provider.fileWriteAct.defaults );
    o2.filePath = _.path.nativize( filePath2 );
    o2.sync = 1;
    o2.data = data;
    test.shouldThrowErrorSync( () =>
    {
      provider.fileWriteAct( o2 );
    })
    test.is( !provider.path.isNormalized( o2.filePath ) );
    test.is( !provider.fileExists( filePath2 ) );
  }
}

//

function fileWriteActAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWriteAct ) )
  return;

  var isHd = test.context.providerIsInstanceOf( _.FileProvider.HardDrive );
  var isSystem = provider instanceof _.FileProvider.System;

  let data = 'Test data'

  let ready = new _.Consequence().take( null )

  /* - */

  .finally( () =>
  {
    test.case = 'normalized path, call fileWrite'
    var filePath = test.context.pathFor( 'write_test/file' );
    var o = _.mapExtend( null, provider.fileWriteAct.defaults );
    o.filePath = filePath;
    o.sync = 0;
    o.data = data;
    provider.dirMakeForFile( filePath )
    return provider.fileWriteAct( o )
    .then( () =>
    {
      test.identical( o.filePath, filePath );
      test.identical( provider.fileRead( filePath ), data );
      return null;
    })
  })

  /* - */

  if( Config.debug )
  if( process.platform === 'win32' )
  if( !isSystem && isHd )
  ready.finally( () =>
  {
    test.case = 'native path, call fileWrite_body'
    var filePath = test.context.pathFor( 'write_test/file' );
    provider.filesDelete( filePath )
    var o = _.mapExtend( null, provider.fileWriteAct.defaults );
    o.filePath = _.path.nativize( filePath );
    o.sync = 0;
    o.data = data;
    return test.shouldThrowErrorOfAnyKind( () =>
    {
      return provider.fileWriteAct( o );
    })
    .then( () =>
    {
      test.is( !provider.path.isNormalized( o.filePath ) );
      test.is( !provider.fileExists( filePath ) );
      return null;
    })

  })

  /* - */

  return ready;
}

//

function readWriteAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWriteAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var softLinkIsSupported = test.context.softLinkIsSupported();
  var routinePath = test.context.pathFor( 'written/readWriteAsync' );
  var got, filePath, readOptions, writeOptions, onBegin, onEnd, onError, buffer;
  var testData = 'Lorem ipsum dolor sit amet';

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var consequence = new _.Consequence().take( null );
  consequence

  /**/

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileRead, invalid path';
    var con = provider.fileRead
    ({
      filePath : '/invalid path',
      sync : 0,
      throwing : 1,
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .ifNoErrorThen( function()
  {
    var con = provider.fileRead
    ({
      filePath : '/invalid path',
      sync : 0,
      throwing : 0,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( ( got ) =>
    {
      test.identical( got, null );
      return got;
    })
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileRead, path ways to not a terminal file';
    filePath = test.context.pathFor( 'written/readWriteAsync/dir' );
    provider.dirMake( filePath );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      filePath,
      sync : 0,
      throwing : 1,
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .ifNoErrorThen( function()
  {
    var con = provider.fileRead
    ({
      filePath,
      sync : 0,
      throwing : 0,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( ( got ) =>
    {
      test.identical( got, null );
      return got;
    })
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileRead, simple file read ';
    provider.filesDelete( routinePath );
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    provider.fileWrite( filePath, testData );
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      filePath,
      sync : 0,
      encoding : 'utf8',
      throwing : 1,
    });
    return test.mustNotThrowError( con )
    .then( function( got )
    {
      test.identical( got, testData );
      return got;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      filePath,
      sync : 0,
      encoding : 'unknown',
      throwing : 1,
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .ifNoErrorThen( function()
  {
    var con = provider.fileRead
    ({
      filePath,
      sync : 0,
      encoding : 'unknown',
      throwing : 0,
    });
    return test.mustNotThrowError( con );
  })

  /* - */

  .then( function( arg )
  {
    test.case = 'fileRead, file read with common encodings';
    provider.filesDelete( routinePath );
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    testData = { a : 'abc' };
    provider.fileWrite( filePath, JSON.stringify( testData ) );
    var con = provider.fileRead
    ({
      filePath,
      sync : 0,
      encoding : 'json',
      throwing : 1,
    });
    return test.mustNotThrowError( con )
    .finally( function( err, got )
    {
      if( err )
      throw err;
      test.identical( got, testData );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    testData = 'module.exports = { a : 1 }';
    else
    testData = '1 + 2';

    provider.fileWrite( filePath, testData );
    var con  = provider.fileRead
    ({
      filePath,
      sync : 0,
      encoding : 'js.smart',
      throwing : 1,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
      {
        test.identical( got, { a : 1 } );
      }
      else
      {
        var expected = _.exec
        ({
          code : testData,
          filePath,
          prependingReturn : 1,
        });
        test.identical( got, expected );
      }

      return got;
    });
  })

  /* - */

  .ifNoErrorThen( ( arg ) =>
  {
    testData = filePath;
    provider.fileWrite( filePath, testData );
    var con = provider.fileRead
    ({
      filePath,
      sync : 0,
      encoding : 'original.type',
      throwing : 1,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( ( got ) =>
    {
      if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
      {
        test.is( _.bufferBytesIs( got ) )
        test.identical( got, _.bufferBytesFrom( BufferNode.from( testData ) ) );
      }
      else
      {
        test.identical( got, testData );
      }

      return null;
    })
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileRead, onBegin, onEnd, onError';
    provider.filesDelete( routinePath );
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    testData = 'Lorem ipsum dolor sit amet';
    onBegin = function onBegin( err, o )
    {
      if( err )
      return;

      provider.fileWrite( filePath, testData );
      if( o )
      got = o;
    }
    onEnd = function onEnd( err, data )
    {
      if( !err )
      got = data;
    }
    onError = function onError( err )
    {
      got = err;
    }
    return null;
  })

  /*onBegin returningRead 0*/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      sync : 0,
      outputFormat : 'o',
      throwing : 1,
      filePath,
      encoding : 'utf8',
      onBegin,
      onEnd : null,
      onError : null,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      test.identical( _.objectIs( got ), true );
      return null;
    });
  })

  /*onBegin returningRead 1*/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      sync : 0,
      outputFormat : 'data',
      throwing : 1,
      filePath,
      encoding : 'utf8',
      onBegin,
      onEnd : null,
      onError : null,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      test.identical( _.objectIs( got ), true );
      return null;
    });
  })

  /*onEnd returningRead 0*/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      sync : 0,
      outputFormat : 'o',
      throwing : 1,
      filePath,
      encoding : 'utf8',
      onBegin : null,
      onEnd,
      onError : null,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      test.identical( got.result, testData );
      return null;
    });
  })

  /*onEnd returningRead 1*/
  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      sync : 0,
      outputFormat : 'data',
      throwing : 1,
      filePath,
      encoding : 'utf8',
      onBegin : null,
      onEnd,
      onError : null,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      test.identical( got.result, testData );
      return null;
    });
  })

  /*onError is no called*/
  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      sync : 0,
      outputFormat : 'o',
      throwing : 1,
      filePath : '/invalid path',
      encoding : 'utf8',
      onBegin : null,
      onEnd : null,
      onError,
    });
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( function()
    {
      test.identical( _.errIs( got ), true )
      return null;
    });
  })

  /*onError is no called*/
  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      sync : 0,
      outputFormat : 'data',
      throwing : 1,
      filePath : '/invalid path',
      encoding : 'utf8',
      onBegin : null,
      onEnd : null,
      onError,
    });
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( function()
    {
      test.identical( _.errIs( got ), true );
      return null;
    });
  })

  /*onError is no called*/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      sync : 0,
      outputFormat : 'o',
      throwing : 0,
      filePath : '/invalid path',
      encoding : 'utf8',
      onBegin : null,
      onEnd : null,
      onError,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      test.identical( _.errIs( got ), true );
      return null;
    });
  })

  /*onError is no called*/
  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      sync : 0,
      outputFormat : 'o',
      throwing : 1,
      filePath : '/invalid path',
      encoding : 'utf8',
      onBegin : null,
      onEnd : null,
      onError,
    });
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( function()
    {
      test.identical( _.errIs( got ), true );
      return null;
    });
  })

  // fileWrite

  .then( function( arg )
  {
    test.case = 'fileWrite, path not exist, default settings';
    provider.filesDelete( routinePath );
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    testData = 'Lorem ipsum dolor sit amet';
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.fileWrite
    ({
      sync : 0,
      filePath,
      data : testData,
    })
  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );

    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    test.identical( got, testData );
    return null;
  })

  /*path includes not existing directory*/

  .ifNoErrorThen( function( arg )
  {
    filePath = test.context.pathFor( 'written/readWriteAsync/files/file.txt' );
    return provider.fileWrite
    ({
      sync : 0,
      filePath,
      data : testData
    })
  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( test.context.pathFor( 'written/readWriteAsync/files' ) );
    test.identical( files, [ 'file.txt' ] );
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    test.identical( got, testData );
    return null;
  })

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileWrite, path already exist, default settings';
    provider.filesDelete( routinePath );
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    testData = 'Lorem ipsum dolor sit amet';
    provider.fileWrite( filePath, testData );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.fileWrite
    ({
      sync : 0,
      filePath,
      data : testData
    })
  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    test.identical( got, testData );
    return null;
  })

  /*try rewrite folder*/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileWrite
    ({
      sync : 0,
      filePath : routinePath,
      data : testData
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileWrite, path already exist';
    provider.filesDelete( routinePath );
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    testData = 'Lorem ipsum dolor sit amet';
    provider.fileWrite( filePath, testData );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      makingDirectory : 1,
      purging : 1,
    });
  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    test.identical( got, testData );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      makingDirectory : 0,
      purging : 1,
    });

  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    test.identical( got, testData );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      makingDirectory : 0,
      purging : 0,
    });
  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    test.identical( got, testData );
    return null;
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileWrite, path not exist';
    provider.filesDelete( routinePath );
    testData = 'Lorem ipsum dolor sit amet';
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    return null;
  })

  /*path includes not existing directory*/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      makingDirectory : 0,
      purging : 0,
    });
    return test.shouldThrowErrorOfAnyKind( con )
  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( routinePath );
    test.identical( files, null );
    return null;
  })

  /*file not exist*/

  .ifNoErrorThen( function( arg )
  {
    provider.dirMake( routinePath );
    var con = provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      makingDirectory : 0,
      purging : 0,
    });
    return test.mustNotThrowError( con );
  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    test.identical( got, testData );
    return null;
  })

  /*purging non existing filePath*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( filePath );
    var con = provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      makingDirectory : 0,
      purging : 1,
    });
    return test.mustNotThrowError( con );
  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    test.identical( got, testData );
    return null;
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileWrite, different write modes';
    provider.filesDelete( routinePath );
    testData = 'Lorem ipsum dolor sit amet';
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    return null;
  })

  /*rewrite*/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath, ' ' );
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      writeMode : 'rewrite'
    });

  })
  .ifNoErrorThen( function( arg )
  {
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    test.identical( got, testData );
    return null;
  })

  /*prepend*/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath, testData );
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      writeMode : 'prepend'
    });
  })
  .ifNoErrorThen( function( arg )
  {
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    test.identical( got, testData+testData );
    return null;
  })

  /*append*/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath, testData );
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      writeMode : 'append'
    });
  })
  .ifNoErrorThen( function( arg )
  {
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    test.identical( got, testData+testData );
    return null;
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileWrite, any writeMode should create file it not exist';
    provider.filesDelete( routinePath );
    testData = 'Lorem ipsum dolor sit amet';
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    return null;
  })

  /*rewrite*/

  .ifNoErrorThen( function( arg )
  {
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      writeMode : 'rewrite'
    });
  })
  .ifNoErrorThen( function( arg )
  {
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    test.identical( got, testData );
    return null;
  })

  /*prepend*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( filePath );
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      writeMode : 'prepend'
    });
  })
  .ifNoErrorThen( function( arg )
  {
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    test.identical( got, testData );
    return null;
  })

  /*append*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( filePath );
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      writeMode : 'append'
    });
  })
  .ifNoErrorThen( function( arg )
  {
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    test.identical( got, testData );
    return null;
  })

  /* resolvingSoftLink */

  .ifNoErrorThen( ( arg ) =>
  {

    if( !softLinkIsSupported )
    return null;

    test.case = 'read from soft link, resolvingSoftLink on';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 1 );
    return provider.fileWrite({ filePath, data, sync : 0 })
    .finally( () =>
    {
      var linkPath = test.context.pathFor( 'written/readWriteAsync/link' );
      provider.softLink( linkPath, filePath );
      return provider.fileRead({ filePath : linkPath, sync : 0 })
      .then( ( got ) =>
      {
        test.identical( got, data );
        provider.fieldPop( 'resolvingSoftLink', 1 );
        return null;

      })
    })
  })

  .ifNoErrorThen( ( arg ) =>
  {
    if( !softLinkIsSupported )
    return null;

    test.case = 'read from soft link, resolvingSoftLink on';
    var data = 'data';
    //qqq2 Vova: duplicate cases that are using fieldPush to own routine, use option resolvingSoftLink explicitly here
    //qqq2 Vova: use field usingSoftLink instead of resolvingSoftLink in combination with fileRead to simulate old behaviour
    provider.fieldPush( 'resolvingSoftLink', 0 );
    return provider.fileWrite({ filePath, data, sync : 0 })
    .finally( () =>
    {
      var linkPath = test.context.pathFor( 'written/readWriteAsync/link' );
      provider.softLink( linkPath, filePath );
      var con = provider.fileRead({ filePath : linkPath, sync : 0, resolvingSoftLink : 0 });
      return test.shouldThrowErrorOfAnyKind( con )
      .finally( () =>
      {
        provider.fieldPop( 'resolvingSoftLink', 0 );
        return null;
      })
    })

  })

  .ifNoErrorThen( ( arg ) =>
  {
    if( !softLinkIsSupported )
    return null;

    test.case = 'write using link, resolvingSoftLink on';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 1 );
    return provider.fileWrite({ filePath, data, sync : 0 })
    .finally( () =>
    {
      var linkPath = test.context.pathFor( 'written/readWriteAsync/link' );
      provider.softLink( linkPath, filePath );
      return provider.fileWrite({ filePath, data : data + data, sync : 0 })
    })
    .finally( () => provider.fileRead({ filePath, sync : 0 }) )
    .then( ( got ) =>
    {
      test.identical( got, data + data );
      provider.fieldPop( 'resolvingSoftLink', 1 );
      return null;
    })
  })

  .ifNoErrorThen( ( arg ) =>
  {
    if( !softLinkIsSupported )
    return null;

    test.case = 'write using link, resolvingSoftLink off';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    var linkPath = test.context.pathFor( 'written/readWriteAsync/link' );
    return provider.fileWrite({ filePath, data, sync : 0 })
    .finally( () =>
    {
      provider.softLink( linkPath, filePath );
      return provider.fileWrite({ filePath : linkPath, data : data + data, sync : 0 })
    })
    .finally( () =>
    {
      return provider.fileRead({ filePath, sync : 0 })
      .then( ( got ) =>
      {
        test.identical( got, data );
        return null;
      })
    })
    .finally( () =>
    {
      return provider.fileRead({ filePath : linkPath, sync : 0 })
      .then( ( got ) =>
      {
        test.identical( got, data + data );
        return null;
      })
    })
    .finally( () =>
    {
      provider.fieldPop( 'resolvingSoftLink', 0 );
      return true;
    })
  })

  .ifNoErrorThen( ( arg ) =>
  {
    if( !softLinkIsSupported )
    return null;

    test.case = 'write using link, resolvingSoftLink off';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    var linkPath = test.context.pathFor( 'written/readWriteAsync/link' );
    return provider.fileWrite({ filePath, data, sync : 0 })
    .finally( () =>
    {
      provider.softLink( linkPath, filePath );
      return provider.fileWrite
      ({
        filePath : linkPath,
        writeMode : 'append',
        sync : 0,
        data
      });
    })
    .finally( () =>
    {
      return provider.fileRead({ filePath, sync : 0 })
      .then( ( got ) =>
      {
        test.identical( got, data );
        return null;
      })
    })
    .finally( () =>
    {
      return provider.fileRead({ filePath : linkPath, sync : 0 })
      .then( ( got ) =>
      {
        test.identical( got, data + data );
        return null;
      })
    })
    .finally( () =>
    {
      provider.fieldPop( 'resolvingSoftLink', 0 );
      return true;
    })
  })

  .ifNoErrorThen( ( arg ) =>
  {
    if( !softLinkIsSupported )
    return null;

    test.case = 'write using link, resolvingSoftLink off';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    var linkPath = test.context.pathFor( 'written/readWriteAsync/link' );
    return provider.fileWrite({ filePath, data, sync : 0 })
    .finally( () =>
    {
      provider.softLink( linkPath, filePath );
      return provider.fileWrite
      ({
        filePath : linkPath,
        writeMode : 'prepend',
        sync : 0,
        data : 'prepend'
      });
    })
    .finally( () =>
    {
      return provider.fileRead({ filePath, sync : 0 })
      .then( ( got ) =>
      {
        test.identical( got, data );
        return null;
      })
    })
    .finally( () =>
    {
      return provider.fileRead({ filePath : linkPath, sync : 0 })
      .then( ( got ) =>
      {
        test.identical( got, 'prepend' + data );
        return null;
      })
    })
    .finally( () =>
    {
      provider.fieldPop( 'resolvingSoftLink', 0 )
      return null;
    })

  })

  /* - */

  if( Config.interpreter === 'njs' )
  {
    consequence.ifNoErrorThen( function( arg )
    {
      test.case = 'fileWrite, data is raw buffer';
      provider.filesDelete( routinePath );
      testData = 'Lorem ipsum dolor sit amet';
      buffer = _.bufferRawFrom( BufferNode.from( testData ) );
      filePath = test.context.pathFor( 'written/readWriteAsync/file' );
      return null;
    })

    /**/

    consequence.ifNoErrorThen( function( arg )
    {
      return provider.fileWrite
      ({
        filePath,
        data : buffer,
        sync : 0,
      });
    })
    .ifNoErrorThen( function( arg )
    {
      got = provider.fileRead
      ({
        filePath,
        sync : 1,
      });
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'file' ] );
      test.identical( got, testData );
      return null;
    });

    /* - */

    consequence.ifNoErrorThen( function( arg )
    {
      test.case = 'encoder not finded';
      var encoding = 'unknown';
      test.identical( _.files.ReadEncoders[ encoding ], undefined );
      // test.identical( provider.fileReadAct.encoders[ encoding ], undefined );
      var con = provider.fileRead
      ({
        filePath,
        sync : 0,
        throwing : 1,
        encoding
      });
      return test.shouldThrowErrorOfAnyKind( con );
    })
    .ifNoErrorThen( function( arg )
    {
      test.case = 'other encodings';
      provider.filesDelete( routinePath );
      filePath = test.context.pathFor( 'written/readWriteSync/file' );
      testData = 'abc';
      return null;
    })
    .ifNoErrorThen( function( arg )
    {
      provider.fileWrite( filePath, testData );
      return provider.fileRead
      ({
        filePath,
        sync : 0,
        encoding : 'buffer.node',
        throwing : 1,
      })
      .then( ( got ) => test.is( _.bufferNodeIs( got ) ) )
    })
    .ifNoErrorThen( function( arg )
    {
      provider.fileWrite( filePath, testData );
      return provider.fileRead
      ({
        filePath,
        sync : 0,
        encoding : 'buffer.raw',
        throwing : 1,
      })
      .then( ( got ) => test.is( _.bufferRawIs( got ) ) )
    })
  }

  return consequence;
}

//

function fileReadJson( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  var textData1 = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.';
  var bufferData1;

  if( Config.interpreter === 'browser' || context.providerIsInstanceOf( _.FileProvider.Extract ))
  bufferData1 = new BufferRaw( 4 );
  else
  bufferData1 = BufferNode.from( [ 0x01, 0x02, 0x03, 0x04 ] );


  var dataToJSON1 = [ 1, 'a', { b : 34 } ];
  var dataToJSON2 = { a : 1, b : 's', c : [ 1, 3, 4 ] };

  var testChecks =
  [
    {
      name : 'try to load empty text file as json',
      data : '',
      path : 'fileReadJson/rtext1.txt',
      expected :
      {
        error : true,
        content : undefined,
        // content : void 0
      },
    },
    {
      name : 'try to read non json string as json',
      data : textData1,
      path : 'fileReadJson/text2.txt',
      expected :
      {
        error : true,
        content : undefined,
        // content : void 0
      }
    },
    {
      name : 'try to parse buffer as json',
      data : bufferData1,
      path : 'fileReadJson/data0',
      expected :
      {
        error : true,
        content : undefined,
        // content : void 0
      }
    },
    {
      name : 'read json from file',
      data : dataToJSON1,
      path : 'fileReadJson/jason1.json',
      encoding : 'json',
      expected :
      {
        error : null,
        content : dataToJSON1
      }
    },
    {
      name : 'read json from file 2',
      data : dataToJSON2,
      path : 'fileReadJson/json2.json',
      encoding : 'json',
      expected :
      {
        error : null,
        content : dataToJSON2
      }
    }
  ];

  for( var testCheck of testChecks )
  {
    // join several test aspects together
    var got =
    {
      error : null,
      content : undefined,
      // content : void 0
    };

    let path = test.context.pathFor( testCheck.path );

    if( provider.statResolvedRead( path ) )
    provider.fileDelete( path );

    if( testCheck.encoding === 'json' )
    {
      provider.fileWriteJson( path, testCheck.data );
    }
    else
    {
      provider.fileWrite({ filePath : path, data : testCheck.data })
    }

    try
    {
      got.content = provider.fileReadJson( path );
    }
    catch( err )
    {
      got.error = true;
    }

    test.identical( got, testCheck.expected );
  }

  /* - */

  if( Config.debug )
  {
    test.case = 'missed arguments';
    test.shouldThrowErrorSync( function( )
    {
      provider.fileReadJson( );
    });

    test.case = 'extra arguments';
    test.shouldThrowErrorSync( function( )
    {
      provider.fileReadJson( 'tmp.tmp/tmp.tmp.json', {} );
    });
  }

};

//

function fileReadWithEncoding( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let filePath = test.context.pathFor( 'written/fileReadWithEncoding/dstFile' );
  let isHd = context.providerIsInstanceOf( _.FileProvider.HardDrive );

  test.open( 'buffer.*' );

  var data = 'abc'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, data );

  /* */

  var got = provider.fileRead({ filePath, encoding : 'buffer.bytes' });
  test.identical( got, _.bufferBytesFrom( data ) );

  /* */

  if( isHd )
  {
    var got1 = provider.fileRead({ filePath, encoding : 'buffer.node' });
    test.identical( got1, _.bufferNodeFrom( data ) )
  }

  /* */

  var got = provider.fileRead({ filePath, encoding : 'buffer.raw' });
  test.identical( got, _.bufferRawFrom( data ) )

  test.close( 'buffer.*' );

  /* - */

  test.open( 'json' );

  var data = 'string'
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data, encoding : 'json' });
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, data );

  /* */

  var data = [ 1, 2, 3 ];
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data, encoding : 'json' });
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, data );

  /* */

  var data = '{a : b}';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data });
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRead({ filePath, encoding : 'json' });
  })

  /* */

  var data =
  {
    string : 'string',
    number : 1,
    array : [ 1, 'string' ],
    map : { string : 'string', number : 1, array : [ 'string', 1 ] }
  };
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data, encoding : 'json' });
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, data );

  test.close( 'json' );

  /* - */

  test.open( 'js' );

  var data  =
  `{
    string : 'string',
    number : 1,
    array : [ 1, 'string' ],
    date : new Date( Date.UTC( 2018, 1, 1 ) ),
    buffer : new U16x([ 1, 2, 3 ]),
    map : { string : 'string', number : 1, array : [ 'string', 1 ] }
  }`;
  var expected =
  {
    string : 'string',
    number : 1,
    array : [ 1, 'string' ],
    date : new Date( Date.UTC( 2018, 1, 1 ) ),
    buffer : new U16x([ 1, 2, 3 ]),
    map : { string : 'string', number : 1, array : [ 'string', 1 ] }
  }
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data });
  var got = provider.fileRead({ filePath, encoding : 'js.structure' });
  test.identical( got, expected )

  /* - */

  var data = '{a : b}';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data });
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRead({ filePath, encoding : 'js.structure' });
  })

  test.close( 'js' );

  /* */

  test.open( 'js.smart' );

  var data = 'return 1';
  if( isHd )
  data = 'module.exports = { data : 1 }'
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data });
  var got = provider.fileRead({ filePath, encoding : 'js.smart' });
  if( isHd )
  test.identical( got, { data : 1 } );
  else
  test.identical( got, 1 );

  /* - */

  var data = '{a : b}';
  var filePath2 = test.context.pathFor( 'written/fileReadWithEncoding/dstFile2' );
  provider.filesDelete( filePath2 );
  provider.fileWrite({ filePath : filePath2, data });
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRead({ filePath : filePath2, encoding : 'js.smart' });
  })

  test.close( 'js.smart' );

  /* */

  if( isHd )
  {
    test.case = 'js.node'
    var data2 = 'module.exports = { data : 1 }'
    provider.filesDelete( filePath );
    provider.fileWrite({ filePath, data : data2 });
    var got2 = provider.fileRead({ filePath, encoding : 'js.node' });
    test.identical( got2, { data : 1 });

    /* - */

    var data2 = 'module.exports = { data : 1'
    var filePath3 = test.context.pathFor( 'written/fileReadWithEncoding/dstFile3' );
    provider.filesDelete( filePath3 );
    provider.fileWrite({ filePath : filePath3, data : data2 });
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.fileRead({ filePath : filePath3, encoding : 'js.node' });
    })
  }
}

//

function fileWriteWithEncoding( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let filePath = test.context.pathFor( 'written/fileWriteWithEncoding/dstFile' );
  let isHd = context.providerIsInstanceOf( _.FileProvider.HardDrive );

  /* js */

  var src = '';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'js.structure' })
  var got = provider.fileRead({ filePath, encoding : 'js.structure' });
  test.identical( got, src );

  var src = 'return 1';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'js.structure' })
  var got = provider.fileRead({ filePath, encoding : 'js.structure' });
  test.identical( got, src );

  var src = [ 1, '2', { a : 3 } ];
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'js.structure' })
  var got = provider.fileRead({ filePath, encoding : 'js.structure' });
  test.identical( got, src );

  var src = new Date();
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'js.structure' })
  var got = provider.fileRead({ filePath, encoding : 'js.structure' });
  test.identical( got, src );

  var src =
  {
    string : 'string',
    number : 1,
    array : [ 1, 'string' ],
    date : new Date(),
    buffer : new U16x([ 1, 2, 3 ]),
    map : { string : 'string', number : 1, array : [ 'string', 1 ] }
  }
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'js.structure' })
  var got = provider.fileRead({ filePath, encoding : 'js.structure' });
  test.identical( got, src );

  /* json */

  var src = '';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'json' })
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, src );

  var src = [ 1, 'a', { b : 34 } ];
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'json' })
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, src );

  var src = { a : 1, b : 's', c : [ 1, 3, 4 ] };
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'json' })
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, src );

  var src = '{ "a" : "3" }';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'json' })
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, src );

  var src = new Date( Date.UTC( 2018, 1, 1 ) );
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'json' })
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, '2018-02-01T00:00:00.000Z' );

  var src =
  {
    string : 'string',
    number : 1,
    array : [ 1, 'string' ],
    date : new Date( Date.UTC( 2018, 1, 1 ) ),
    buffer : new U16x([ 1, 2, 3 ]),
    map : { string : 'string', number : 1, array : [ 'string', 1 ] }
  }
  var expected  =
  {
    string : 'string',
    number : 1,
    array : [ 1, 'string' ],
    date : '2018-02-01T00:00:00.000Z',
    buffer : { 0 : 1, 1 : 2, 2 : 3 },
    map : { string : 'string', number : 1, array : [ 'string', 1 ] }
  }
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'json.min' })
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, expected );

  /* origignal.type rewrite */

  var src = 'string';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'original.type' })
  var got = provider.fileRead( filePath );
  test.identical( got, src );

  var src = new U8x([ 99, 100, 101 ]);
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'original.type' })
  var got = provider.fileRead({ filePath, encoding : 'buffer.bytes' });
  test.identical( got, src );

  if( isHd )
  {
    var src1 = _.bufferNodeFrom( [ 99, 100, 101 ] )
    provider.filesDelete( filePath );
    provider.fileWrite({ filePath, data : src1, encoding : 'original.type' })
    var got1 = provider.fileRead({ filePath, encoding : 'buffer.node' });
    test.identical( got1, src1 );
  }

  var src = new BufferRaw( 3 );
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'original.type' })
  var got = provider.fileRead({ filePath, encoding : 'buffer.raw' });
  test.identical( got, src );

  /* original.type append to existing file */

  var src = 'string';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src });
  provider.fileWrite({ filePath, data : src, writeMode : 'append', encoding : 'original.type' })
  var got = provider.fileRead( filePath );
  test.identical( got, src + src );

  var src = new U8x([ 99, 100, 101 ]);
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src });
  provider.fileWrite({ filePath, data : src, writeMode : 'append', encoding : 'original.type' })
  var got = provider.fileRead({ filePath, encoding : 'original.type' });
  test.identical( got, _.bufferJoin( src, src ) );

  if( isHd )
  {
    var src2 = _.bufferNodeFrom( [ 99, 100, 101 ] )
    provider.filesDelete( filePath );
    provider.fileWrite({ filePath, data : src2 });
    provider.fileWrite({ filePath, data : src2, writeMode : 'append', encoding : 'original.type' })
    var got2 = provider.fileRead({ filePath, encoding : 'buffer.node' });
    test.identical( got2, _.bufferJoin( src2, src2 ) );
  }

  var src = new BufferRaw( 3 );
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src });
  provider.fileWrite({ filePath, data : src, writeMode : 'append', encoding : 'original.type' })
  var got = provider.fileRead({ filePath, encoding : 'buffer.raw' });
  test.identical( got, _.bufferJoin( src, src ) );

  /* original.type prepend to existing file */

  var src = 'string';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src });
  provider.fileWrite({ filePath, data : src, writeMode : 'prepend', encoding : 'original.type' })
  var got = provider.fileRead( filePath );
  test.identical( got, src + src );

  var src = new U8x([ 99, 100, 101 ]);
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src });
  provider.fileWrite({ filePath, data : src, writeMode : 'prepend', encoding : 'original.type' })
  var got = provider.fileRead({ filePath, encoding : 'original.type' });
  test.identical( got, _.bufferJoin( src, src ) );

  if( isHd )
  {
    var src3 = _.bufferNodeFrom( [ 99, 100, 101 ] )
    provider.filesDelete( filePath );
    provider.fileWrite({ filePath, data : src3 });
    provider.fileWrite({ filePath, data : src3, writeMode : 'prepend', encoding : 'original.type' })
    var got3 = provider.fileRead({ filePath, encoding : 'buffer.node' });
    test.identical( got3, _.bufferJoin( src3, src3 ) );
  }

  var src = new BufferRaw( 3 );
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src });
  provider.fileWrite({ filePath, data : src, writeMode : 'prepend', encoding : 'original.type' })
  var got = provider.fileRead({ filePath, encoding : 'buffer.raw' });
  test.identical( got, _.bufferJoin( src, src ) );

};

//

function fileWriteJson( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  var defReadOptions =
  {
    encoding : 'utf8'
  };
  var dataToJSON1 = [ 1, 'a', { b : 34 } ];
  var dataToJSON2 = { a : 1, b : 's', c : [ 1, 3, 4 ] };
  var dataToJSON3 = '{ "a" : "3" }';

  var testChecks =
  [
    {
      name : 'write empty JSON string file',
      data : '',
      path : 'fileWriteJson/data1.json',
      expected :
      {
        instance : false,
        content : '',
        exist : true
      },
      readOptions : defReadOptions
    },
    {
      name : 'write array to file',
      data : dataToJSON1,
      path : 'fileWriteJson/data1.json',
      expected :
      {
        instance : false,
        content : dataToJSON1,
        exist : true
      },
      readOptions : defReadOptions
    },
    {
      name : 'write object using options',
      data : dataToJSON2,
      path : 'fileWriteJson/data2.json',
      expected :
      {
        instance : false,
        content : dataToJSON2,
        exist : true
      },
      readOptions : defReadOptions
    },
    {
      name : 'write jason string',
      data : dataToJSON3,
      path : 'fileWriteJson/data3.json',
      expected :
      {
        instance : false,
        content : dataToJSON3,
        exist : true
      },
      readOptions : defReadOptions
    }
  ];


  // regular tests
  for( var testCheck of testChecks )
  {
    // join several test aspects together
    var got =
    {
      instance : null,
      content : null,
      exist : null
    }

    let path = test.context.pathFor( testCheck.path );

    // clear

    if( provider.statResolvedRead( path ) )
    provider.fileDelete( path );

    var con = provider.fileWriteJson( path, testCheck.data );

    // fileWtrite must returns wConsequence
    got.instance = _.consequenceIs( con );

    // recorded file should exists
    got.exist = !!provider.statResolvedRead( path );

    // check content of created file.
    var o = _.mapExtend( null, testCheck.readOptions, { filePath : path } );
    // got.content = JSON.parse( _.fileProvider.fileRead( path, testCheck.readOptions ) );
    got.content = JSON.parse( provider.fileRead( o ) );

    test.case = testCheck.name;
    test.identical( got, testCheck.expected );
  }

  if( Config.debug )
  {
    test.case = 'missed arguments';
    test.shouldThrowErrorSync( function( )
    {
      provider.fileWriteJson( );
    } );

    test.case = 'extra arguments';
    test.shouldThrowErrorSync( function( )
    {
      provider.fileWriteJson( 'temp/sample.txt', { a : 'hello' }, { b : 'world' } );
    } );

    test.case = 'path is not string';
    test.shouldThrowErrorSync( function( )
    {
      provider.fileWriteJson( 3, 'hello' );
    } );

    test.case = 'passed unexpected property in options';
    test.shouldThrowErrorSync( function( )
    {
      provider.fileWriteJson( { filePath : 'temp/some.txt', data : 'hello', parentDir : './work/project' } );
    } );
  }
}

//

function fileTouch( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWriteAct ) || context.providerIsInstanceOf( _.FileProvider.Extract )  )
  {
    test.identical( 1, 1 );
    return;
  }

  var got;

  var routinePath = test.context.pathFor( 'written/fileTouch' );

  provider.filesDelete( routinePath );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var srcPath = path.normalize( test.context.pathFor( 'written/fileTouch/src.txt' ) );
  var testData = 'test';

  /* - */

  test.case = 'filePath doesnt exist'
  // provider.filesDelete( srcPath );
  provider.fileTouch( srcPath );
  var stat = provider.statResolvedRead( srcPath );
  test.is( _.objectIs( stat ) );

  test.case = 'filePath doesnt exist, filePath as record';
  provider.filesDelete( srcPath );
  var record = provider.recordFactory({ allowingMissed : 1 }).record( srcPath );
  test.identical( record.stat, null );
  provider.fileTouch( record );
  var stat = provider.statResolvedRead( srcPath );
  test.is( _.objectIs( stat ) );

  test.case = 'filePath is a directory';
  provider.filesDelete( srcPath );
  provider.dirMake( srcPath );
  test.shouldThrowErrorOfAnyKind( () => provider.fileTouch( srcPath ) );

  test.case = 'directory, filePath as record';
  provider.filesDelete( srcPath );
  provider.dirMake( srcPath );
  var record = provider.recordFactory().record( srcPath );
  test.shouldThrowErrorOfAnyKind( () => provider.fileTouch( record ) );

  if( Config.debug )
  {
    test.case = 'invalid filePath type'
    test.shouldThrowErrorOfAnyKind( () => provider.fileTouch( 1 ) );

    test.case = 'data option must be undefined'
    test.shouldThrowErrorOfAnyKind( () => provider.fileTouch({ filePath : srcPath, data : testData }) );

    test.case = 'more then one arg'
    test.shouldThrowErrorOfAnyKind( () => provider.fileTouch( srcPath, testData ) );
  }

  var con = new _.Consequence().take( null )

  /**/

  .ifNoErrorThen( ( arg ) =>
  {
    test.case = 'filePath is a terminal';
    provider.filesDelete( srcPath );
    provider.fileWrite( srcPath, testData );
    var statsBefore = provider.statResolvedRead( srcPath );
    return _.time.out( 1000, () =>
    {
      provider.fileTouch( srcPath );
      var statsAfter = provider.statResolvedRead( srcPath );
      test.identical( statsAfter.size, statsBefore.size );
      test.identical( statsAfter.ino, statsBefore.ino );
      test.is( statsAfter.mtime > statsBefore.mtime );
      test.is( statsAfter.ctime > statsBefore.mtime );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( ( arg ) =>
  {
    test.case = 'terminal, filePath as record';
    provider.filesDelete( srcPath );
    provider.fileWrite( srcPath, testData );
    var record = provider.recordFactory().record( srcPath );
    var statsBefore = record.stat;
    return _.time.out( 1000, () =>
    {
      provider.fileTouch( record );
      var statsAfter = provider.statResolvedRead( srcPath );
      test.identical( statsAfter.size, statsBefore.size );
      test.identical( statsAfter.ino, statsBefore.ino );
      test.is( statsAfter.mtime > statsBefore.mtime );
      test.is( statsAfter.ctime > statsBefore.mtime );
      return null;
    })
  })

  return con;
}

//

function timeWrite( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/timeWrite' );
  let filePath = test.context.pathFor( 'written/timeWrite/file' );

  let maxDiff = provider.systemBitrateTimeGet();

  test.case = 'path does not exist';
  provider.filesDelete( filePath );
  var time = _.time.now();
  test.shouldThrowErrorOfAnyKind( () => provider.timeWrite( filePath, time, time ) );

  function testDiff( diff )
  {
    if( !diff )
    test.identical( diff, 0 );
    else
    test.le( diff, maxDiff );
  }

  test.case = 'terminal file';
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var time = new Date();
  provider.timeWrite( filePath, time, time );
  var stat  = provider.statResolvedRead( filePath );
  test.is( stat.isTerminal() );
  var adiff = time.getTime() - stat.atime.getTime();
  testDiff( adiff );
  var mdiff = time.getTime() - stat.mtime.getTime();
  testDiff( mdiff );

  test.case = 'dir';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  var time = new Date();
  provider.timeWrite( routinePath, time, time );
  var stat  = provider.statResolvedRead( routinePath );
  test.is( stat.isDir() );
  var adiff = time.getTime() - stat.atime.getTime();
  testDiff( adiff );
  var mdiff = time.getTime() - stat.mtime.getTime();
  testDiff( mdiff );

  test.case = 'object, file';
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var time = new Date();
  provider.timeWrite({ filePath, atime : time, mtime : time });
  var stat  = provider.statResolvedRead( filePath );
  test.is( stat.isTerminal() );
  var adiff = time.getTime() - stat.atime.getTime();
  testDiff( adiff );
  var mdiff = time.getTime() - stat.mtime.getTime();
  testDiff( mdiff );

  test.case = 'object, dir';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  var time = new Date();
  provider.timeWrite({ filePath : routinePath, atime : time, mtime : time });
  var stat  = provider.statResolvedRead( routinePath );
  test.is( stat.isDir() );
  var adiff = time.getTime() - stat.atime.getTime();
  testDiff( adiff );
  var mdiff = time.getTime() - stat.mtime.getTime();
  testDiff( mdiff );

  test.case = 'two args, file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  var filePath2 = test.context.pathFor( 'written/timeWrite/file2' );
  provider.fileWrite( filePath2, filePath2 );
  var time = new Date();
  provider.timeWrite( filePath2, time, time );
  provider.timeWrite( filePath, filePath2 );
  var stat  = provider.statResolvedRead( filePath );
  test.is( stat.isTerminal() );
  var adiff = time.getTime() - stat.atime.getTime();
  testDiff( adiff );
  var mdiff = time.getTime() - stat.mtime.getTime();
  testDiff( mdiff );

  test.case = 'two args, dir';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  var filePath2 = test.context.pathFor( 'written/timeWrite/dir' );
  provider.dirMake( filePath2 );
  var time = new Date();
  provider.timeWrite( filePath2, time, time );
  provider.timeWrite( routinePath, filePath2 );
  var stat  = provider.statResolvedRead( routinePath );
  test.is( stat.isDir() );
  var adiff = time.getTime() - stat.atime.getTime();
  testDiff( adiff );
  var mdiff = time.getTime() - stat.mtime.getTime();
  testDiff( mdiff );

  test.case = 'negative values';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  var statb  = provider.statResolvedRead( routinePath );
  provider.timeWrite( filePath, -1, -1 );
  var stata  = provider.statResolvedRead( routinePath );
  test.ge( statb.mtime, stata.mtime );
  test.ge( statb.atime, stata.atime );

  test.case = 'zero values';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  var statb  = provider.statResolvedRead( routinePath );
  provider.timeWrite( filePath, 0, 0 );
  var stata  = provider.statResolvedRead( routinePath );
  test.ge( statb.mtime, stata.mtime );
  test.ge( statb.atime, stata.atime );

  if( process )
  if( process.platform === 'win32' )
  {
    test.case = 'number, milliseconds';
    provider.filesDelete( filePath );
    provider.fileWrite( filePath, filePath );
    var time1 = new Date().getTime();
    var statb1  = provider.statResolvedRead( filePath );
    test.shouldThrowErrorOfAnyKind( () => provider.timeWrite( filePath, time1, time1 ) );
    var stata1  = provider.statResolvedRead( filePath );
    test.identical( statb1.atime, stata1.atime );
    test.identical( statb1.mtime, stata1.mtime );
  }
  else
  {
    test.case = 'number, sec';
    provider.filesDelete( filePath );
    provider.fileWrite( filePath, filePath );
    var time2 = new Date().getTime();
    provider.timeWrite( filePath, time2, time2 );
    var stat2  = provider.statResolvedRead( filePath );
    test.is( stat2.isTerminal() );
    var adiff2 = time2 - stat2.atime.getTime();
    testDiff( adiff2 );
    var mdiff2 = time2 - stat2.mtime.getTime();
    testDiff( mdiff2 );
  }

  test.case = 'number, sec';
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var time = new Date().getTime();
  provider.timeWrite( filePath, time / 1000, time / 1000 );
  var stat  = provider.statResolvedRead( filePath );
  test.is( stat.isTerminal() );
  var adiff = time - stat.atime.getTime();
  testDiff( adiff );
  var mdiff = time - stat.mtime.getTime();
  testDiff( mdiff );

  test.case = 'incorrect atime type';
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var time = new Date();
  var statb  = provider.statResolvedRead( filePath );
  test.shouldThrowErrorOfAnyKind( () => provider.timeWrite( filePath, {}, time ) );
  var stata  = provider.statResolvedRead( filePath );
  test.identical( statb.atime, stata.atime );
  test.identical( statb.mtime, stata.mtime );

  test.case = 'two args, second file does not exist';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  var filePath2 = test.context.pathFor( 'written/timeWrite/dir' );
  var time = new Date();
  var statb  = provider.statResolvedRead( filePath );
  test.shouldThrowErrorOfAnyKind( () => provider.timeWrite( filePath, filePath2 ) );
  var stata  = provider.statResolvedRead( filePath );
  test.identical( statb.atime, stata.atime );
  test.identical( statb.mtime, stata.mtime );

  test.case = 'only atime';
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var time = new Date();
  var statb  = provider.statResolvedRead( filePath );
  test.shouldThrowErrorOfAnyKind( () => provider.timeWrite({ filePath, atime : time }) );
  var stata  = provider.statResolvedRead( filePath );
  test.identical( statb.atime, stata.atime );
  test.identical( statb.mtime, stata.mtime );

  test.case = 'only mtime';
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var time = new Date();
  var statb  = provider.statResolvedRead( filePath );
  test.shouldThrowErrorOfAnyKind( () => provider.timeWrite({ filePath, mtime : time }) );
  var stata  = provider.statResolvedRead( filePath );
  test.identical( statb.atime, stata.atime );
  test.identical( statb.mtime, stata.mtime );

  if( !Config.debug )
  return;

  var time = new Date();
  test.case = 'invalid arguments'
  test.shouldThrowErrorOfAnyKind( () => provider.timeWrite( 1 ) );
  test.shouldThrowErrorOfAnyKind( () => provider.timeWrite({ filePath : 1, atime : time, mtime : time } ) );
}

//

function writeAsyncThrowingError( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWrite ) )
  return;

  var consequence = new _.Consequence().take( null );

  consequence
  .ifNoErrorThen( function( arg )
  {

    test.case = 'async, try to rewrite dir';

    var path = test.context.pathFor( 'dir' );
    provider.dirMake( path );
    test.identical( provider.isDir( path ), true )
    var data1 = 'data1';
    var con = provider.fileWrite
    ({
      filePath : path,
      data : data1,
      sync : 0,
    });

    return test.shouldThrowErrorAsync( con );
  })

  return consequence;
}

//

function fileCopyActSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopyAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var got;

  var routinePath = test.context.pathFor( 'written/fileCopy' );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );

  /* - */

  test.case = 'use terminal as parent directory';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var dstPath2 = path.join( srcPath, 'dst' );
  var o =
  {
    srcPath,
    dstPath : dstPath2,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath2,
    sync : 1,
    // breakingDstHardLink : 0,
  }
  test.shouldThrowErrorSync( () => provider.fileCopyAct( o ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath2 ) );

  /* - */

  test.case = 'no src';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      // breakingDstHardLink : 0,
      // breakingDstSoftLink : 0
    })
  })

  /* - */

  test.case = 'no src';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 0
    })
  })

  /* - */

  test.case = 'no src';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      // breakingDstHardLink : 0,
      // breakingDstSoftLink : 1
    })
  })

  /* - */

  test.case = 'no src';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 1
    })
  })

  /* - */

  test.case = 'no src, dst exists';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      // breakingDstHardLink : 0,
      // breakingDstSoftLink : 0
    })
  })
  var dstFile = provider.fileRead( dstPath );
  test.identical( dstFile, dstPath );

  /* - */

  test.case = 'no src, dst exists';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 0
    })
  })
  var dstFile = provider.fileRead( dstPath );
  test.identical( dstFile, dstPath );

  /* - */

  test.case = 'no src, dst exists';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      // breakingDstHardLink : 0,
      // breakingDstSoftLink : 1
    })
  })
  var dstFile = provider.fileRead( dstPath );
  test.identical( dstFile, dstPath );

  /* - */

  test.case = 'no src, dst exists';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 1
    })
  })
  var dstFile = provider.fileRead( dstPath );
  test.identical( dstFile, dstPath );

  /* - */

  test.case = 'src : directory, no dst';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      // breakingDstHardLink : 0,
      // breakingDstSoftLink : 0
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] )

  /* - */

  test.case = 'src : directory, no dst';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 0
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /* - */

  test.case = 'src : directory, no dst';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      // breakingDstHardLink : 0,
      // breakingDstSoftLink : 1
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /* - */

  test.case = 'src : directory, no dst';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 1
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] )

  /* - */

  test.case = 'no structure before dst';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      // breakingDstHardLink : 0,
      // breakingDstSoftLink : 0
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /* - */

  test.case = 'no structure before dst';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 0
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /* - */

  test.case = 'no structure before dst';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      // breakingDstHardLink : 0,
      // breakingDstSoftLink : 1
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /* - */

  test.case = 'no structure before dst';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 1
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /* - */

  test.case = 'src - terminal, dst - directory';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      // breakingDstHardLink : 0,
      // breakingDstSoftLink : 0
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dstPath', 'src' ] );
  var files = provider.dirRead( dstPath );
  test.identical( files, [] );

  /* - */

  test.case = 'src - terminal, dst - directory';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 0
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dstPath', 'src' ] );
  var files = provider.dirRead( dstPath );
  test.identical( files, [] );

  /* - */

  test.case = 'src - terminal, dst - directory';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      // breakingDstHardLink : 0,
      // breakingDstSoftLink : 1
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dstPath', 'src' ] );
  var files = provider.dirRead( dstPath );
  test.identical( files, [] );

  /* - */

  test.case = 'src - terminal, dst - directory';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 1
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dstPath', 'src' ] );
  var files = provider.dirRead( dstPath );
  test.identical( files, [] );

  /* - */

  test.case = 'simple copy';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopyAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
    // breakingDstHardLink : 0,
    // breakingDstSoftLink : 0
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst', 'src' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  /* - */

  test.case = 'simple copy';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopyAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
    // breakingDstHardLink : 1,
    // breakingDstSoftLink : 0
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst', 'src' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  /* - */

  test.case = 'simple copy';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopyAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
    // breakingDstHardLink : 0,
    // breakingDstSoftLink : 1
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst', 'src' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  /* - */

  test.case = 'simple copy';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopyAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
    // breakingDstHardLink : 1,
    // breakingDstSoftLink : 1
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst', 'src' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  /* - */

  test.case = 'simple, rewrite';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileCopyAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
    // breakingDstHardLink : 0,
    // breakingDstSoftLink : 0
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst', 'src' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  /* - */

  test.case = 'simple, rewrite';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileCopyAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
    // breakingDstHardLink : 1,
    // breakingDstSoftLink : 0
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst', 'src' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  /* - */

  test.case = 'simple, rewrite';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileCopyAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
    // breakingDstHardLink : 0,
    // breakingDstSoftLink : 1
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst', 'src' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  /* - */

  test.case = 'simple, rewrite';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileCopyAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
    // breakingDstHardLink : 1,
    // breakingDstSoftLink : 1
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst', 'src' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  /* - */

  var routinePath = test.context.pathFor( 'written/' + test.name );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  var otherPath = path.join( routinePath, 'other' );

  /* hardLink */

  test.case = 'dst is a hard link, breaking disabled';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, srcPath );
  provider.fileCopyAct
  ({
    dstPath,
    srcPath : otherPath,
    relativeSrcPath : otherPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
    // breakingDstSoftLink : 0,
    // breakingDstHardLink : 0
  });
  test.is( provider.isHardLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, srcFile );
  test.identical( otherFile, srcFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, srcFile );
  test.is( srcFile !== otherFile );

  /* - */

  test.case = 'dst is a hard link, breakingDstSoftLink : 1,breakingDstHardLink : 0';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, srcPath );
  provider.fileCopyAct
  ({
    dstPath,
    srcPath : otherPath,
    relativeSrcPath : otherPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
    // breakingDstSoftLink : 1,
    // breakingDstHardLink : 0
  });
  test.is( provider.isHardLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, srcFile );
  test.identical( otherFile, srcFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, srcFile );
  test.is( srcFile !== otherFile );

  //qqq: move this test case to one of fileCopy test routines

  // test.case = 'dst is a hard link, breakingDstHardLink : 1';
  // provider.filesDelete( routinePath );
  // provider.fileWrite( srcPath, srcPath );
  // provider.fileWrite( otherPath, otherPath );
  // provider.hardLink( dstPath, srcPath );
  // debugger
  // provider.fileCopyAct
  // ({
  //   dstPath,
  //   srcPath : otherPath,
  //   relativeSrcPath : otherPath,
  //   relativeDstPath : dstPath,
  //   sync : 1,
  //   // breakingDstSoftLink : 0,
  //   // breakingDstHardLink : 1
  // });
  // test.is( !provider.isHardLink( dstPath ) );
  // var dstFile = provider.fileRead( dstPath );
  // var srcFile = provider.fileRead( srcPath );
  // var otherFile = provider.fileRead( otherPath );
  // test.identical( otherFile, dstFile );
  // test.is( srcFile !== dstFile );
  // provider.fileWrite( srcPath, srcPath );
  // var dstFile = provider.fileRead( dstPath );
  // var srcFile = provider.fileRead( srcPath );
  // test.identical( dstFile, otherFile );
  // test.is( srcFile !== dstFile );

  //qqq: move this test case to one of fileCopy test routines

  // test.case = 'dst is a hard link, breakingDstSoftLink : 1, breakingDstHardLink : 1';
  // provider.filesDelete( routinePath );
  // provider.fileWrite( srcPath, srcPath );
  // provider.fileWrite( otherPath, otherPath );
  // provider.hardLink( dstPath, srcPath );
  // provider.fileCopyAct
  // ({
  //   dstPath,
  //   srcPath : otherPath,
  //   relativeSrcPath : otherPath,
  //   relativeDstPath : dstPath,
  //   sync : 1,
  //   // breakingDstSoftLink : 1,
  //   // breakingDstHardLink : 1
  // });
  // test.is( !provider.isHardLink( dstPath ) );
  // var dstFile = provider.fileRead( dstPath );
  // var srcFile = provider.fileRead( srcPath );
  // var otherFile = provider.fileRead( otherPath );
  // test.identical( otherFile, dstFile );
  // test.is( srcFile !== dstFile );
  // provider.fileWrite( srcPath, srcPath );
  // var dstFile = provider.fileRead( dstPath );
  // var srcFile = provider.fileRead( srcPath );
  // test.identical( dstFile, otherFile );
  // test.is( srcFile !== dstFile );

  /* links */

  if( !test.context.softLinkIsSupported() )
  return;

  test.case = 'dst is a soft link';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, srcPath );
  provider.fileCopyAct
  ({
    dstPath,
    srcPath : otherPath,
    relativeSrcPath : otherPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
    // breakingDstSoftLink : 0,
    // breakingDstHardLink : 0
  });
  test.is( provider.isSoftLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, srcFile );
  test.identical( otherFile, srcFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, srcFile );
  test.is( srcFile !== otherFile );

  /* - */

  test.case = 'dst is a soft link';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, srcPath );
  provider.fileCopyAct
  ({
    dstPath,
    srcPath : otherPath,
    relativeSrcPath : otherPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
    // breakingDstSoftLink : 1,
    // breakingDstHardLink : 0
  });
  test.is( provider.isSoftLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, srcFile );
  test.identical( otherFile, srcFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, srcFile );
  test.is( srcFile !== otherFile );

  /* - */

  test.case = 'dst is a soft link';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, srcPath );
  provider.fileCopyAct
  ({
    dstPath,
    srcPath : otherPath,
    relativeSrcPath : otherPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
    // breakingDstSoftLink : 1,
    // breakingDstHardLink : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, srcFile );
  test.identical( otherFile, srcFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, srcFile );
  test.is( srcFile !== otherFile );

  /* - */

  test.case = 'should not create folders structure for path';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'parent/dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    // breakingSrcHardLink : 0,
    // breakingDstHardLink : 1,
    sync : 1,
    context : provider,
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct( o );
  })
  test.is( !provider.fileExists( dstPath ) );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    // breakingDstHardLink : 0,
    sync : 1,
    context : provider,
  }
  var expected = _.mapOwnKeys( o );
  provider.fileCopyAct( o );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst', 'src' ] );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'should path nativize all paths in options map if needed by its own means';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    // breakingDstHardLink : 0,
    sync : 1,
    context : provider,
  }

  var expected = _.mapExtend( null, o );

  provider.fileCopyAct( o );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst', 'src' ] );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );
  test.identical( o, expected );
  provider.filesDelete( routinePath );

  /* - */

  if( !Config.debug )
  return;

  test.case = 'should assert that path is absolute';
  var srcPath = './dst';
  var dstPath = path.join( routinePath, 'dst' );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      dstPath,
      srcPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      context : provider,
      breakingDstHardLink : 0
    });
  })

  /* - */

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath, 'src' );;
  var dstPath = path.join( routinePath, 'dst' );

  /* sync option is missed */

  var o =
  {
    srcPath,
    dstPath,
    context : provider,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingDstHardLink : 0
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct( o );
  });

  /* redundant option */

  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
    redundant : 'redundant'
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct( o );
  });

  /* - */

  test.case = 'should expect normalized path, but not nativized';
  var srcPath = routinePath + '\\src';
  provider.fileWrite( provider.path.normalize( srcPath ), srcPath );
  var dstPath = routinePath + '\\dst';
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
  }

  if( !context.providerIsInstanceOf( _.FileProvider.System ) )
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopyAct( o ) );
  else
  test.mustNotThrowError( () => provider.fileCopyAct( o ) );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'should expect ready options map, no complex arguments preprocessing';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath : [ srcPath ],
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
  }
  var expected = _.mapExtend( null, o );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct( o );
  })
  test.identical( o.srcPath, expected.srcPath );

}

//

function fileCopyActAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopyAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var got;
  var con = new _.Consequence().take( null );

  var routinePath = test.context.pathFor( 'written/fileCopy' );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );

  /* */

  con.then( () =>
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 0,
      context : provider,
    }
    return provider.fileCopyAct( o )
    .then( () =>
    {
      test.is( provider.isTerminal( srcPath ) );
      test.is( provider.isTerminal( dstPath ) );
      var file = provider.fileRead( dstPath );
      test.identical( file, srcPath );
      return null;
    })
  })

  /* */

  return con;
}

//

function fileCopySync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopyAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var got;

  var routinePath = test.context.pathFor( 'written/fileCopy' );

  context.provider.filesDelete( routinePath );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  /* - */

  test.case = 'src not exist';

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.fileCopy
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 1,
      rewriting : 1,
      throwing : 1,
    });
  });

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileCopy
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 1,
      rewriting : 1,
      throwing : 0,
    });
  });
  test.identical( got, null );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.fileCopy
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 1,
      rewriting : 0,
      throwing : 1,
    });
  });

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileCopy
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 1,
      rewriting : 0,
      throwing : 0,
    });
  });
  test.identical( got, null );

  /* - */

  test.case = 'dst path not exist';
  var srcPath = test.context.pathFor( 'written/fileCopy/src.txt' );
  var dstPath = test.context.pathFor( 'written/fileCopy/dst.txt' );
  provider.fileWrite( srcPath, ' ' );

  /**/

  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst.txt', 'src.txt' ] );

  /**/

  provider.filesDelete( dstPath );
  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst.txt', 'src.txt' ] );

  /**/

  provider.filesDelete( dstPath );
  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 0
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst.txt', 'src.txt' ] );

  /**/

  provider.filesDelete( dstPath );
  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 0
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst.txt', 'src.txt' ] );

  /* - */

  test.case = 'dst path exist';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );
  provider.fileWrite( dstPath, ' ' );

  /**/

  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst.txt', 'src.txt' ] );

  /**/

  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 0
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst.txt', 'src.txt' ] );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 0,
      throwing : 1
    });
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst.txt', 'src.txt' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 0,
      throwing : 0
    });
  });
  test.identical( got, null );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst.txt', 'src.txt' ] );

  /* - */

  test.case = 'src is equal to dst';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileCopy
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 1,
      throwing : 1
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src.txt' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileCopy
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      throwing : 1
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src.txt' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileCopy
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 1,
      throwing : 0
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src.txt' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileCopy
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      throwing : 0
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src.txt' ] );

  /* - */

  if( context.providerIsInstanceOf( _.FileProvider.Extract ) )
  return;

  test.case = 'src is not a terminal, dst present, check if nothing changed';

  /* rewritin & throwing on */

  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( dstPath, ' ' );
  var srcStatExpected = provider.statResolvedRead( srcPath );
  var dstBefore = provider.fileRead( dstPath );
  var dirBefore = provider.dirRead( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1,
      throwing : 1
    });
  });
  var srcStat = provider.statResolvedRead( srcPath );
  var dstNow = provider.fileRead( dstPath );
  test.is( srcStat.isDirectory() );
  test.identical( srcStat.size, srcStatExpected.size );
  test.identical( srcStat.mtime.getTime(), srcStatExpected.mtime.getTime() );
  test.identical( dstNow, dstBefore );
  var dirAfter = provider.dirRead( routinePath );
  test.identical( dirAfter, dirBefore );

  /* rewritin on & throwing off */

  var srcPath = test.context.pathFor( 'written/fileCopy/src.txt' );
  var dstPath = test.context.pathFor( 'written/fileCopy/dst.txt' );

  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( dstPath, ' ' );
  var srcStatExpected = provider.statResolvedRead( srcPath );
  var dstBefore = provider.fileRead( dstPath );
  var dirBefore = provider.dirRead( routinePath );
  var got = provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 0
  });
  test.identical( got, null );
  var srcStat = provider.statResolvedRead( srcPath );
  var dstNow = provider.fileRead( dstPath );
  test.is( srcStat.isDirectory() );
  test.identical( srcStat.size, srcStatExpected.size );
  test.identical( srcStat.mtime.getTime(), srcStatExpected.mtime.getTime() );
  test.identical( dstNow, dstBefore );
  var dirAfter = provider.dirRead( routinePath );
  test.identical( dirAfter, dirBefore );

  /* rewritin & throwing off */

  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( dstPath, ' ' );
  var srcStatExpected = provider.statResolvedRead( srcPath );
  var dstBefore = provider.fileRead( dstPath );
  var dirBefore = provider.dirRead( routinePath );
  var got = provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 0
  });
  test.identical( got, null );
  var srcStat = provider.statResolvedRead( srcPath );
  var dstNow = provider.fileRead( dstPath );
  test.is( srcStat.isDirectory() );
  test.identical( srcStat.size, srcStatExpected.size );
  test.identical( srcStat.mtime.getTime(), srcStatExpected.mtime.getTime() );
  test.identical( dstNow, dstBefore );
  var dirAfter = provider.dirRead( routinePath );
  test.identical( dirAfter, dirBefore );

  /* - */

  test.case = 'makingDirectory creates routinePath for a file, dstPath structure not exists'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'folder/structure/dst' );
  test.is( !provider.statResolvedRead( dstPath ) );
  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    makingDirectory : 1,
    throwing : 1
  });
  test.is( !!provider.statResolvedRead( dstPath ) );

  /* - */

  test.case = 'rewriting off, dstPath structure not exists'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'folder/structure/dst' );
  test.is( !provider.statResolvedRead( dstPath ) );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 0,
      throwing : 1
    });
  })
  test.is( !provider.statResolvedRead( dstPath ) );

  /* - */

  test.case = 'rewriting off, dstPath structure not exists'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'folder/structure/dst' );
  test.is( !provider.statResolvedRead( dstPath ) );
  test.mustNotThrowError( () =>
  {
    provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 0,
      throwing : 0
    });
  })
  test.is( !provider.statResolvedRead( dstPath ) );

  /* - */

  test.case = 'rewriting on, parentDir is a terminal file'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var terminalFilePath = path.join( routinePath, 'folder/structure' );
  provider.fileWrite( terminalFilePath, dstPath );
  var dstPath = path.join( routinePath, 'folder/structure/dst' );
  test.is( !!provider.statResolvedRead( terminalFilePath ) );
  test.is( !provider.statResolvedRead( dstPath ) );
  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    makingDirectory : 1,
    throwing : 1
  });
  test.is( provider.isDir( terminalFilePath ) );
  test.is( !!provider.statResolvedRead( dstPath ) );

  /* - */

  test.case = 'rewriting on, parentDir is a directory with files, routinePath must be preserved'
  provider.filesDelete( routinePath );
  var file1 = path.join( routinePath, 'dir', 'file1' );
  var file2 = path.join( routinePath, 'dir', 'file2' );
  provider.fileWrite( file1, file1 );
  provider.fileWrite( file2, file2 );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  test.is( !provider.statResolvedRead( dstPath ) );
  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dir', 'dst', 'src.txt' ];
  test.identical( files, expected );

  /* - */

  test.case = 'rewriting off, parentDir is a directory with files, routinePath must be preserved'
  provider.filesDelete( routinePath );
  var file1 = path.join( routinePath, 'dir', 'file1' );
  var file2 = path.join( routinePath, 'dir', 'file2' );
  provider.fileWrite( file1, file1 );
  provider.fileWrite( file2, file2 );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  test.is( !provider.statResolvedRead( dstPath ) );
  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 1
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dir', 'dst', 'src.txt' ];
  test.identical( files, expected );

  /* relative paths */

  test.case = 'relative path, dst path not exist';
  var routinePath = test.context.pathFor( 'written/fileCopy' );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );

  /* - */

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopy
  ({
    srcPath,
    dstPath : test.context.globalFromPreferred( '../dst' ),
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst', 'src' ] );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  /* - */

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopy
  ({
    srcPath : test.context.globalFromPreferred( '../src' ),
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst', 'src' ] );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  if( !Config.debug )
  return;

  /* both relative, throwing : 1 */

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopy
    ({
      srcPath : test.context.globalFromPreferred( '../src' ),
      dstPath : test.context.globalFromPreferred( '../dst' ),
      sync : 1,
      rewriting : 1,
      throwing : 1
    });
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );
  var srcFile = provider.fileRead( srcPath );
  test.identical( srcPath, srcFile );

  /* both relative, throwing : 0 */

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopy
    ({
      srcPath : path.relative( routinePath, srcPath ),
      dstPath : path.relative( routinePath, dstPath ),
      sync : 1,
      rewriting : 1,
      throwing : 0
    });
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );
  var srcFile = provider.fileRead( srcPath );
  test.identical( srcPath, srcFile );

  /* - */

  test.case = 'dst - terminal, rewrite by src - terminal'
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  test.is( !!provider.statResolvedRead( srcPath ) );
  test.is( !!provider.statResolvedRead( dstPath ) );
  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  var srcFile = provider.fileRead( srcPath );
  var dstFile = provider.fileRead( dstPath );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst', 'src' ] )
  test.identical( srcFile, srcPath );
  test.identical( dstFile, srcPath );
}

//

function fileCopyRelativePath( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopyAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileCopyRelativePath' );
  let pathToDir = test.context.pathFor( 'written/fileCopyRelativePath/dir' );
  let pathToFile = test.context.pathFor( 'written/fileCopyRelativePath/file' );

  test.open( 'src - relative path to a file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );

  var srcPath = '../file';
  var dstPath = test.context.pathFor( 'written/fileCopyRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesCanBeSame( pathToFile, dstPath ) );

  var srcPath = './../file';
  var dstPath = test.context.pathFor( 'written/fileCopyRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesCanBeSame( pathToFile, dstPath ) );

  var srcPath = '../../file';
  var dstPath = test.context.pathFor( 'written/fileCopyRelativePath/dstPath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesCanBeSame( pathToFile, dstPath ) );


  var srcPath = './../../file';
  var dstPath = test.context.pathFor( 'written/fileCopyRelativePath/dstPath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesCanBeSame( pathToFile, dstPath ) );


  var srcPath = './../../../file';
  var pathToFile2 = test.context.pathFor( 'written/fileCopyRelativePath/a/file' );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/fileCopyRelativePath/a/b/c/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesCanBeSame( pathToFile2, dstPath ) );

  var srcPath = '../../../file';
  var pathToFile2 = test.context.pathFor( 'written/fileCopyRelativePath/a/file' );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/fileCopyRelativePath/a/b/c/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesCanBeSame( pathToFile2, dstPath ) );

  test.close( 'src - relative path to a file' );

  /* - */

  test.open( 'dst - relative path to a file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );

  var srcPath = pathToFile;
  var dstPath = '../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesCanBeSame( srcPath, dstPathResolved ) );

  var srcPath = pathToFile;
  var dstPath = './../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesCanBeSame( srcPath, dstPathResolved ) );

  var srcPath = pathToFile;
  var dstPath = '../../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesCanBeSame( srcPath, dstPathResolved ) );

  var srcPath = pathToFile;
  var dstPath = './../../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesCanBeSame( srcPath, dstPathResolved ) );

  var srcPath = pathToFile;
  var dstPath = './../a/b/dstFile';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesCanBeSame( srcPath, dstPathResolved ) );

  test.close( 'dst - relative path to a file' );

  /* - */

  test.open( 'src - relative path to a dir' );

  provider.filesDelete( routinePath );
  provider.fileWrite( path.join( pathToDir, 'fileInDir' ), 'fileInDir' );
  provider.dirMake( pathToDir );

  var srcPath = '../dir';
  var dstPath = test.context.pathFor( 'written/fileCopyRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( dstPath, srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.close( 'src - relative path to a dir' );

  /* - */

  test.open( 'dst - relative path to a dir' );

  provider.filesDelete( routinePath );
  provider.fileWrite( path.join( pathToDir, 'fileInDir' ), 'fileInDir' );
  provider.dirMake( pathToDir );

  var srcPath = pathToDir;
  var dstPath = '../copyOfDir';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( dstPath, srcPath ) );
  test.is( !provider.fileExists( dstPathResolved ) );

  test.close( 'dst - relative path to a dir' );

  test.open( 'same paths' );

  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );

  var srcPath = '../file';
  var dstPath = pathToFile;
  var statBefore = provider.statResolvedRead( pathToFile );
  var got = provider.fileCopy( dstPath, srcPath );
  var statNow = provider.statResolvedRead( pathToFile );
  test.identical( got, true );
  test.identical( statBefore.mtime.getTime(), statNow.mtime.getTime() );

  var srcPath = pathToFile;
  var dstPath = '../file';
  var statBefore = provider.statResolvedRead( pathToFile );
  var got = provider.fileCopy( dstPath, srcPath );
  var statNow = provider.statResolvedRead( pathToFile );
  test.identical( got, true );
  test.identical( statBefore.mtime.getTime(), statNow.mtime.getTime() );

  test.close( 'same paths' );
}

//

function fileCopyLinksSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopyAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var routinePath = test.context.pathFor( 'written/' + test.name );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  var otherPath = path.join( routinePath, 'other' );
  var dstLinkPath = path.join( dstPath, 'link' );
  var srcLinkPath = path.join( srcPath, 'link' );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  /* - */

  /* hardLink */

  test.case = 'dst is a hard link, breaking disabled';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, srcPath );
  provider.fileCopy
  ({
    dstPath,
    srcPath : otherPath,
    sync : 1,
    // breakingDstSoftLink : 0,
    breakingDstHardLink : 0
  });
  test.is( provider.isHardLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, srcFile );
  test.identical( otherFile, srcFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, srcFile );
  test.is( srcFile !== otherFile );

  /* - */

  test.case = 'dst is a hard link, breakingDstSoftLink : 1,breakingDstHardLink : 0';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, srcPath );
  provider.fileCopy
  ({
    dstPath,
    srcPath : otherPath,
    sync : 1,
    // breakingDstSoftLink : 1,
    breakingDstHardLink : 0
  });
  test.is( provider.isHardLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, srcFile );
  test.identical( otherFile, srcFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, srcFile );
  test.is( srcFile !== otherFile );

  /* - */

  test.case = 'dst is a hard link, breakingDstHardLink : 1';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, srcPath );
  provider.fileCopy
  ({
    dstPath,
    srcPath : otherPath,
    sync : 1,
    // breakingDstSoftLink : 0,
    breakingDstHardLink : 1
  });
  test.is( !provider.isHardLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  test.is( srcFile !== dstFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, otherFile );
  test.is( srcFile !== dstFile );

  /* - */

  test.case = 'dst is a hard link, breakingDstSoftLink : 1, breakingDstHardLink : 1';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, srcPath );
  provider.fileCopy
  ({
    dstPath,
    srcPath : otherPath,
    sync : 1,
    // breakingDstSoftLink : 1,
    breakingDstHardLink : 1
  });
  test.is( !provider.isHardLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  test.is( srcFile !== dstFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, otherFile );
  test.is( srcFile !== dstFile );

  /* - */

  test.case = 'src - not terminal, dst - hard link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, otherPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 1,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 0
    });
  })
  test.is( !!provider.isHardLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  /* - */

  test.case = 'src - not terminal, dst - hard link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, otherPath );
  test.mustNotThrowError( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 0,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 0
    });
  })
  test.is( !!provider.isHardLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  /* - */

  test.case = 'src - not terminal, dst - hard link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, otherPath );
  test.mustNotThrowError( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 0,
      // breakingDstSoftLink : 1,
      breakingDstHardLink : 0
    });
  })
  test.is( !!provider.isHardLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  /* - */

  test.case = 'src - not terminal, dst - hard link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, otherPath );
  test.mustNotThrowError( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 0,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 1
    });
  })
  test.is( !!provider.isHardLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  /* - */

  test.case = 'src - not terminal, dst - hard link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, otherPath );
  test.mustNotThrowError( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 0,
      // breakingDstSoftLink : 1,
      breakingDstHardLink : 1
    });
  })
  test.is( !!provider.isHardLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  /* - */

  if( !test.context.softLinkIsSupported() )
  return;

  test.case = 'dst is a soft link, breaking disabled';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, srcPath );
  provider.fileCopy
  ({
    dstPath,
    srcPath : otherPath,
    sync : 1,
    // breakingDstSoftLink : 0,
    breakingDstHardLink : 0
  });
  test.is( !provider.isSoftLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );
  test.identical( otherFile, otherFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, otherFile );

  /* - */

  test.case = 'dst is a soft link, breakingDstSoftLink : 0,breakingDstHardLink : 1';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, srcPath );
  provider.fileCopy
  ({
    dstPath,
    srcPath : otherPath,
    sync : 1,
    // breakingDstSoftLink : 0,
    breakingDstHardLink : 1
  });
  test.is( !provider.isSoftLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );
  test.identical( otherFile, otherFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, otherFile );

  /* - */

  test.case = 'src - not terminal, dst - soft link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, otherPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 1,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 0
    });
  })
  test.is( !!provider.isSoftLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  /* - */

  test.case = 'src - not terminal, dst - soft link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, otherPath );
  test.mustNotThrowError( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 0,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 0
    });
  })
  test.is( !!provider.isSoftLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  /* - */

  test.case = 'src - not terminal, dst - soft link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, otherPath );
  test.mustNotThrowError( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 0,
      // breakingDstSoftLink : 1,
      breakingDstHardLink : 0
    });
  })
  test.is( !!provider.isSoftLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  /* - */

  test.case = 'src - not terminal, dst - soft link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, otherPath );
  test.mustNotThrowError( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 0,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 1
    });
  })
  test.is( !!provider.isSoftLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  /* - */

  test.case = 'src - not terminal, dst - soft link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, otherPath );
  test.mustNotThrowError( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 0,
      // breakingDstSoftLink : 1,
      breakingDstHardLink : 1
    });
  })
  test.is( !!provider.isSoftLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  /* - */

  test.case = 'src link is broken, src resolving is on'
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    srcPath : path.join( srcPath, 'fileNotExists' ),
    dstPath : srcLinkPath,
    allowingMissed : 1,
    makingDirectory : 1
  })
  provider.fileWrite( path.join( dstPath, 'terminal' ), 'file' );
  provider.softLink
  ({
    srcPath : path.join( dstPath, 'terminal' ),
    dstPath : dstLinkPath,
    makingDirectory : 1
  })
  var records = provider.fileCopy
  ({
    srcPath : srcLinkPath,
    dstPath : dstLinkPath,
    allowingMissed : 1,
    resolvingSrcSoftLink : 2,
  });

  test.is( !provider.fileExists( dstLinkPath ) );
  test.is( !provider.fileExists( path.join( dstPath, 'fileNotExists' ) ) );
  test.is( provider.fileExists( path.join( dstPath, 'terminal' ) ) );

  /* - */

  test.case = 'src link is broken, src resolving is on'
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    srcPath : path.join( srcPath, 'fileNotExists' ),
    dstPath : srcLinkPath,
    allowingMissed : 1,
    makingDirectory : 1
  })
  provider.fileWrite( path.join( dstPath, 'terminal' ), 'file' );
  provider.softLink
  ({
    srcPath : path.join( dstPath, 'terminal' ),
    dstPath : dstLinkPath,
    makingDirectory : 1
  })
  var records = provider.fileCopy
  ({
    srcPath : srcLinkPath,
    dstPath : dstLinkPath,
    allowingMissed : 1,
    resolvingSrcSoftLink : 1,
  });

  test.is( provider.isSoftLink( dstLinkPath ) );
  test.identical( provider.pathResolveSoftLink( dstLinkPath ), path.join( srcPath, 'fileNotExists' ) );
  test.is( !provider.fileExists( path.join( dstPath, 'fileNotExists' ) ) );
  test.is( provider.fileExists( path.join( dstPath, 'terminal' ) ) );

  /* - */

  test.case = 'src link is broken, src resolving is off'
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    srcPath : path.join( srcPath, 'fileNotExists' ),
    dstPath : srcLinkPath,
    allowingMissed : 1,
    makingDirectory : 1,
  })
  provider.fileWrite( path.join( dstPath, 'terminal' ), 'file' );
  provider.softLink
  ({
    srcPath : path.join( dstPath, 'terminal' ),
    dstPath : dstLinkPath,
    makingDirectory : 1,
  })
  var records = provider.fileCopy
  ({
    srcPath : srcLinkPath,
    dstPath : dstLinkPath,
    allowingMissed : 0,
    resolvingSrcSoftLink : 0,
  });

  test.is( provider.fileExists( dstLinkPath ) );
  test.is( !provider.fileExists( path.join( dstPath, 'fileNotExists' ) ) );
  test.is( provider.fileExists( path.join( dstPath, 'terminal' ) ) );

  /* - */

  test.case = 'src link is broken, src resolving is on, allowingMissed is off'
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    srcPath : path.join( srcPath, 'fileNotExists' ),
    dstPath : srcLinkPath,
    allowingMissed : 1,
    makingDirectory : 1,
  })
  provider.fileWrite( path.join( dstPath, 'terminal' ), 'file' );
  provider.softLink
  ({
    srcPath : path.join( dstPath, 'terminal' ),
    dstPath : dstLinkPath,
    makingDirectory : 1,
  })

  test.shouldThrowErrorSync( () =>
  {
    var records = provider.fileCopy
    ({
      srcPath : srcLinkPath,
      dstPath : dstLinkPath,
      allowingMissed : 0,
      resolvingSrcSoftLink : 1,
    });
  });

  test.is( provider.fileExists( dstLinkPath ) );
  test.is( !provider.fileExists( path.join( dstPath, 'fileNotExists' ) ) );
  test.is( provider.fileExists( path.join( dstPath, 'terminal' ) ) );

  /* - */

  test.case = 'src link is cycled, src resolving is on'
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    srcPath : srcLinkPath,
    dstPath : srcLinkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    makingDirectory : 1
  });
  provider.fileWrite( path.join( dstPath, 'terminal' ), 'file' );
  provider.softLink
  ({
    srcPath : path.join( dstPath, 'terminal' ),
    dstPath : dstLinkPath,
    makingDirectory : 1
  });
  var records = provider.fileCopy
  ({
    srcPath : srcLinkPath,
    dstPath : dstLinkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingSrcSoftLink : 1,
  });

  test.identical( provider.pathResolveSoftLink( dstLinkPath ), srcLinkPath );
  test.is( provider.fileExists( dstLinkPath ) );
  test.is( provider.fileExists( path.join( dstPath, 'terminal' ) ) );

  /* - */

  test.case = 'src link is cycled, src resolving is off'
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    srcPath : srcLinkPath,
    dstPath : srcLinkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    makingDirectory : 1,
  })
  provider.fileWrite( path.join( dstPath, 'terminal' ), 'file' );
  provider.softLink
  ({
    srcPath : path.join( dstPath, 'terminal' ),
    dstPath : dstLinkPath,
    makingDirectory : 1,
  })
  var records = provider.fileCopy
  ({
    srcPath : srcLinkPath,
    dstPath : dstLinkPath,
    allowingMissed : 0,
    allowingCycled : 0,
    resolvingSrcSoftLink : 0,
  });

  test.identical( provider.pathResolveSoftLink( dstLinkPath ), srcLinkPath );
  test.is( provider.fileExists( dstLinkPath ) );
  test.is( provider.fileExists( path.join( dstPath, 'terminal' ) ) );

  /* - */

  test.case = 'src link is cycled, src resolving is on, allowingMissed is off'
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    srcPath : srcLinkPath,
    dstPath : srcLinkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    makingDirectory : 1,
  })
  provider.fileWrite( path.join( dstPath, 'terminal' ), 'file' );
  provider.softLink
  ({
    srcPath : path.join( dstPath, 'terminal' ),
    dstPath : dstLinkPath,
    makingDirectory : 1,
  })

  test.shouldThrowErrorSync( () =>
  {
    var records = provider.fileCopy
    ({
      srcPath : srcLinkPath,
      dstPath : dstLinkPath,
      allowingMissed : 1,
      allowingCycled : 0,
      resolvingSrcSoftLink : 1,
    });
  });

  test.identical( provider.pathResolveSoftLink( dstLinkPath ), path.join( dstPath, 'terminal' ) );
  test.is( provider.fileExists( dstLinkPath ) );
  test.is( provider.fileExists( path.join( dstPath, 'terminal' ) ) );

  /* */

}

//

function fileCopyAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopyAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var routinePath = test.context.pathFor( 'written/fileCopyAsync' );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var srcPath = test.context.pathFor( 'written/fileCopyAsync/src.txt' );
  var dstPath = test.context.pathFor( 'written/fileCopyAsync/dst.txt' );

  var consequence = new _.Consequence().take( null );

  /* - */

  consequence
  .ifNoErrorThen( function( arg )
  {
    test.case = 'src not exist';
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 0,
      rewriting : 1,
      throwing : 1,
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    debugger
    var con = provider.fileCopy
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 0,
      rewriting : 1,
      throwing : 0,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 0,
      rewriting : 0,
      throwing : 1,
    });
    return test.shouldThrowErrorOfAnyKind( con )
  })

  /**/

  .finally( function()
  {
    var con = provider.fileCopy
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 0,
      rewriting : 0,
      throwing : 0,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      return got;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'copy bigger file';
    var data = _.strDup( 'Lorem Ipsum is simply text', 10000 );
    provider.fileWrite( srcPath, data );
    provider.filesDelete( dstPath );
    var srcStat = provider.statResolvedRead( srcPath );
    return provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    })
    .ifNoErrorThen( function( got )
    {
      var dstStat = provider.statResolvedRead( dstPath );
      test.identical( srcStat.size, dstStat.size );
      var dstFile = provider.fileRead( dstPath );
      test.is( dstFile === data );
      return got;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dst path not exist';
    provider.fileWrite( srcPath, ' ' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst.txt', 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( dstPath );
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst.txt', 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( dstPath );
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst.txt', 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( dstPath );
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst.txt', 'src.txt' ] );
      return null;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dst path exist';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    provider.fileWrite( dstPath, ' ' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst.txt', 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst.txt', 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( function()
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst.txt', 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    })
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst.txt', 'src.txt' ] );
      return null;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'src is equal to dst';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src.txt' ] );
      return null;
    });
  });

  /* - */

  if( context.providerIsInstanceOf( _.FileProvider.Extract ) )
  return consequence;

  consequence.finally( () =>
  {
    test.case = 'src is not a terminal, dst present, check if nothing changed';
    return true;
  })

  /* rewritin & throwing on */

  .finally( () =>
  {
    provider.filesDelete( routinePath );
    provider.dirMake( srcPath );
    provider.fileWrite( dstPath, ' ' );
    var srcStatExpected = provider.statResolvedRead( srcPath );
    var dstBefore = provider.fileRead( dstPath );
    var dirBefore = provider.dirRead( routinePath );
    return test.shouldThrowErrorOfAnyKind( () =>
    {
      return provider.fileCopy
      ({
        srcPath,
        dstPath,
        sync : 0,
        rewriting : 1,
        throwing : 1
      });
    })
    .finally( () =>
    {
      var srcStat = provider.statResolvedRead( srcPath );
      var dstNow = provider.fileRead( dstPath );
      test.is( srcStat.isDirectory() );
      test.identical( srcStat.size, srcStatExpected.size );
      test.identical( srcStat.mtime.getTime(), srcStatExpected.mtime.getTime() );
      test.identical( dstNow, dstBefore );
      var dirAfter = provider.dirRead( routinePath );
      test.identical( dirAfter, dirBefore );
      return true;
    })

  })

  /* rewritin on & throwing off */

  .finally( () =>
  {
    provider.filesDelete( routinePath );
    provider.dirMake( srcPath );
    provider.fileWrite( dstPath, ' ' );
    var srcStatExpected = provider.statResolvedRead( srcPath );
    var dstBefore = provider.fileRead( dstPath );
    var dirBefore = provider.dirRead( routinePath );
    return provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    })
    .then( ( got ) =>
    {
      test.identical( got, null );
      var srcStat = provider.statResolvedRead( srcPath );
      var dstNow = provider.fileRead( dstPath );
      test.is( srcStat.isDirectory() );
      test.identical( srcStat.size, srcStatExpected.size );
      test.identical( srcStat.mtime.getTime(), srcStatExpected.mtime.getTime() );
      test.identical( dstNow, dstBefore );
      var dirAfter = provider.dirRead( routinePath );
      test.identical( dirAfter, dirBefore );
      return got;
    })

  })

  /* rewritin & throwing off */

  .finally( () =>
  {
    provider.filesDelete( routinePath );
    provider.dirMake( srcPath );
    provider.fileWrite( dstPath, ' ' );
    var srcStatExpected = provider.statResolvedRead( srcPath );
    var dstBefore = provider.fileRead( dstPath );
    var dirBefore = provider.dirRead( routinePath );
    return provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    })
    .then( ( got ) =>
    {
      test.identical( got, null );
      var srcStat = provider.statResolvedRead( srcPath );
      var dstNow = provider.fileRead( dstPath );
      test.is( srcStat.isDirectory() );
      test.identical( srcStat.size, srcStatExpected.size );
      test.identical( srcStat.mtime.getTime(), srcStatExpected.mtime.getTime() );
      test.identical( dstNow, dstBefore );
      var dirAfter = provider.dirRead( routinePath );
      test.identical( dirAfter, dirBefore );
      return got;
    })

  })

  return consequence;
}

//

function fileCopyLinksAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  // !!!needs adjusting

  if( !_.routineIs( provider.fileCopyAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var routinePath = test.context.pathFor( 'written/' + test.name );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  var otherPath = path.join( routinePath, 'other' );

  var con = new _.Consequence().take( null )

  /* - */

  /* hardLink */

  .ifNoErrorThen( () =>
  {
    test.case = 'dst is a hard link, breaking disabled';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( otherPath, otherPath );
    provider.hardLink( dstPath, srcPath );
    return provider.fileCopy
    ({
      dstPath,
      srcPath : otherPath,
      sync : 0,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 0
    })
    .ifNoErrorThen( ( arg ) =>
    {
      test.is( provider.isHardLink( dstPath ) );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      var otherFile = provider.fileRead( otherPath );
      test.identical( dstFile, srcFile );
      test.identical( otherFile, srcFile );
      provider.fileWrite( srcPath, srcPath );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      test.identical( dstFile, srcFile );
      test.is( srcFile !== otherFile );
      return null;
    })
  })

  /* - */

  .ifNoErrorThen( () =>
  {
    test.case = 'dst is a hard link, breakingDstSoftLink : 1,breakingDstHardLink : 0';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( otherPath, otherPath );
    provider.hardLink( dstPath, srcPath );
    return provider.fileCopy
    ({
      dstPath,
      srcPath : otherPath,
      sync : 0,
      // breakingDstSoftLink : 1,
      breakingDstHardLink : 0
    })
    .ifNoErrorThen( ( arg ) =>
    {
      test.is( provider.isHardLink( dstPath ) );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      var otherFile = provider.fileRead( otherPath );
      test.identical( dstFile, srcFile );
      test.identical( otherFile, srcFile );
      provider.fileWrite( srcPath, srcPath );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      test.identical( dstFile, srcFile );
      test.is( srcFile !== otherFile );
      return null;
    })
  })

  /* - */

  .ifNoErrorThen( () =>
  {
    test.case = 'dst is a hard link, breakingDstHardLink : 1';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( otherPath, otherPath );
    provider.hardLink( dstPath, srcPath );
    return provider.fileCopy
    ({
      dstPath,
      srcPath : otherPath,
      sync : 0,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 1
    })
    .ifNoErrorThen( ( arg ) =>
    {
      test.is( !provider.isHardLink( dstPath ) );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      var otherFile = provider.fileRead( otherPath );
      test.identical( otherFile, dstFile );
      test.is( srcFile !== dstFile );
      provider.fileWrite( srcPath, srcPath );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      test.identical( dstFile, otherFile );
      test.is( srcFile !== dstFile );
      return null;
    })
  })

  /* - */

  .ifNoErrorThen( () =>
  {
    test.case = 'dst is a hard link, breakingDstSoftLink : 1, breakingDstHardLink : 1';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( otherPath, otherPath );
    provider.hardLink( dstPath, srcPath );
    return provider.fileCopy
    ({
      dstPath,
      srcPath : otherPath,
      sync : 0,
      // breakingDstSoftLink : 1,
      breakingDstHardLink : 1
    })
    .ifNoErrorThen( ( arg ) =>
    {
      test.is( !provider.isHardLink( dstPath ) );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      var otherFile = provider.fileRead( otherPath );
      test.identical( otherFile, dstFile );
      test.is( srcFile !== dstFile );
      provider.fileWrite( srcPath, srcPath );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      test.identical( dstFile, otherFile );
      test.is( srcFile !== dstFile );
      return null;
    })
  });

  /* - */

  if( !test.context.softLinkIsSupported() )
  return con;

  /* soft links */

  con.finally( () =>
  {
    test.case = 'dst is a soft link, breaking disabled';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( otherPath, otherPath );
    provider.softLink( dstPath, srcPath );
    return provider.fileCopy
    ({
      dstPath,
      srcPath : otherPath,
      sync : 0,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 0
    })
    .ifNoErrorThen( ( arg ) =>
    {
      test.is( provider.isTerminal( dstPath ) );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      var otherFile = provider.fileRead( otherPath );
      test.identical( srcPath, srcFile );
      test.identical( otherFile, dstFile );
      return null;
    })
  })

  /* - */

  .finally( () =>
  {
    test.case = 'dst is a soft link, breakingDstSoftLink : 0,breakingDstHardLink : 1';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( otherPath, otherPath );
    provider.softLink( dstPath, srcPath );
    return provider.fileCopy
    ({
      dstPath,
      srcPath : otherPath,
      sync : 0,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 1
    })
    .ifNoErrorThen( ( arg ) =>
    {
      test.is( provider.isTerminal( dstPath ) );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      var otherFile = provider.fileRead( otherPath );
      test.identical( srcPath, srcFile );
      test.identical( otherFile, dstFile );
      return null;
    })
  })

  return con;
}

//

function fileCopySoftLinkResolving( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopy ) )
  {
    test.identical( 1, 1 );
    return;
  }

  /*

  resolvingSrcSoftLink : [ 0, 1 ]
  resolvingDstSoftLink : [ 0, 1 ]
  link : [ normal, double, broken, context cycled, cycled, dst and src resolving to the same file ]

  */

  function fileCopy( o )
  {
    let o2 =
    {
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1
    }
    _.mapSupplement( o, o2 )
    return provider.fileCopy( o );
  }

  let routinePath = test.context.pathFor( 'written/fileCopySoftLinkResolving' );
  let srcPath = provider.path.join( routinePath, 'src' );
  let srcPath2 = provider.path.join( routinePath, 'src2' );
  let dstPath = provider.path.join( routinePath, 'dst' );
  let dstPath2 = provider.path.join( routinePath, 'dst2' );
  let srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  let dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );

  /**/

  test.open( 'normal' );

  // provider.filesDelete( routinePath );
  // provider.fileWrite( srcPathTerminal, srcPathTerminal );
  // provider.fileWrite( dstPathTerminal, dstPathTerminal );
  // provider.softLink( srcPath, srcPathTerminal );
  // provider.softLink( dstPath, dstPathTerminal );
  // var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  // fileCopy( o );
  // test.identical( o.srcPath, srcPath );
  // test.identical( o.dstPath, dstPath );
  // test.is( provider.isSoftLink( srcPath ) );
  // test.is( provider.isSoftLink( dstPath ) );
  // test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  // test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  // test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  // test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 0 };
  debugger
  fileCopy( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 1 };
  fileCopy( o )
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  test.close( 'normal' );

  // /**/

  test.open( 'double' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveLinkFull( srcPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 0 };
  fileCopy( o )
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveLinkFull( srcPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveLinkFull( dstPath2 ).absolutePath, dstPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.identical( provider.pathResolveLinkFull( srcPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 1 };
  fileCopy( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.identical( provider.pathResolveLinkFull( srcPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, dstPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  test.close( 'double' );

  /**/

  test.open( 'broken' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => fileCopy( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => fileCopy( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'broken' );

  /**/

  test.open( 'context cycled' );

  /* dst does not exist */

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0, allowingMissed : 0, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( o.srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0, allowingMissed : 0, throwing : 1 };
  test.shouldThrowErrorOfAnyKind( () => fileCopy( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0, allowingMissed : 1, allowingCycled : 1, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  // test.is( !provider.fileExists( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0, allowingMissed : 1, allowingCycled : 1, throwing : 1 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  // test.is( !provider.fileExists( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );

  /* both are context links */

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0, allowingMissed : 0, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0, allowingMissed : 1, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0, allowingMissed : 0, throwing : 1 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0, allowingMissed : 1, throwing : 1 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  /* - */

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 0, allowingMissed : 0,  throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, null );
  test.identical( o.srcPath, null );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0, allowingMissed : 1, allowingCycled : 1, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0, allowingMissed : 0, throwing : 1 };
  test.shouldThrowErrorOfAnyKind( () => fileCopy( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0, allowingMissed : 1, allowingCycled : 1, throwing : 1 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  /* - */

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1, allowingMissed : 0, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1, allowingMissed : 1, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1, allowingMissed : 0, throwing : 1 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1, allowingMissed : 1, throwing : 1 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  /* - */

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1, allowingMissed : 0, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, null );
  test.identical( o.srcPath, null );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1, allowingMissed : 1, allowingCycled : 1, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1, allowingMissed : 0, throwing : 1 };
  test.shouldThrowErrorOfAnyKind( () => fileCopy( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1, allowingMissed : 1, allowingCycled : 1, throwing : 1 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'context cycled' );

  /* */

  test.open( 'cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => fileCopy( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => fileCopy( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'cycled' );

  /**/

  test.open( 'links to same file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, srcPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPathTerminal ), srcPath );
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( srcPath ) )
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( dstPath ) )

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 1 };
  var statSrcPathTerminal1 = provider.statRead( srcPathTerminal );
  fileCopy( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, srcPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  var statSrcPathTerminal2 = provider.statRead( srcPathTerminal );
  test.will = 'terminal must not be changed';
  test.identical( statSrcPathTerminal1.mtime.getTime(), statSrcPathTerminal2.mtime.getTime() );

  test.close( 'links to same file' );
}

//

function fileCopyLinks( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  /*
    resolving off
    link : [ normal, double, broken, context cycled, cycled, dst and src resolving to the same file ]
  */

  function fileCopy( o )
  {
    let o2 =
    {
      srcPath,
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 0,
      resolvingDstSoftLink : 0,
      resolvingDstTextLink : 0,
      sync : 1,
      rewriting : 1
    }
    _.mapSupplement( o, o2 )
    return provider.fileCopy( o );
  }

  let routinePath = test.context.pathFor( 'written/fileCopySoftLinkResolving' );
  let srcPath = provider.path.join( routinePath, 'src' );
  let srcPath2 = provider.path.join( routinePath, 'src2' );
  let dstPath = provider.path.join( routinePath, 'dst' );
  let dstPath2 = provider.path.join( routinePath, 'dst2' );
  let srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  let dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );

  test.case = 'src normal link'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'both normal links'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'src double link'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveLinkFull( srcPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'both double links'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveLinkFull( srcPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'src broken link'
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'both broken links'
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'src context link';
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0, allowingMissed : 0, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );

  test.case = 'both are context links';
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0, allowingMissed : 0, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );

  test.case = 'src cycled';
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );

  test.case = 'cycled';
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );

  test.case = 'links to same file';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  var dstStatBefore = provider.statRead( dstPath );
  _.time.out( 1000 ).deasync();
  fileCopy( o );
  var dstStatAfter = provider.statRead( dstPath );
  test.is( dstStatBefore.mtime.getTime() !== dstStatAfter.mtime.getTime() );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
}

//

function fileCopyError( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/fileCopyError' );
  let srcPath = test.context.pathFor( 'written/fileCopyError/src' );
  let dstPath = test.context.pathFor( 'written/fileCopyError/dst' );
  let missingPath = test.context.pathFor( 'written/fileCopyError/missing' );

  /**/

  test.case = 'missing';
  provider.filesDelete( routinePath );
  var o =
  {
    srcPath,
    dstPath,
    allowingMissed : 0,
    throwing : 1
  }
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( o ) );
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  /* - */

  test.case = 'missing';
  provider.filesDelete( routinePath );
  var o =
  {
    srcPath,
    dstPath,
    allowingMissed : 0,
    throwing : 0
  }
  var got = provider.fileCopy( o );
  test.identical( got, null );
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  /* - */

  test.case = 'try to copy dir';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  var o =
  {
    srcPath,
    dstPath,
    throwing : 1
  }
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( o ) );
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.isDir( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  /* - */

  test.case = 'try to copy dir';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  var o =
  {
    srcPath,
    dstPath,
    throwing : 1
  }
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( o ) );
  test.identical( got, null );
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.isDir( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  /* - */

  test.case = 'try to copy soft link to dir';
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink( srcPath, routinePath );
  var o =
  {
    srcPath,
    dstPath,
    resolvingSrcSoftLink : 0,
    throwing : 1
  }
  var got = provider.fileCopy( o );
  test.identical( got, true );
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  /* - */

  test.case = 'try to copy soft link to dir';
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink( srcPath, routinePath );
  var o =
  {
    srcPath,
    dstPath,
    resolvingSrcSoftLink : 1,
    throwing : 1
  }
  provider.fileCopy( o )
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), routinePath );

  /* - */

  test.case = 'try to copy soft link to dir';
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink( srcPath, routinePath );
  var o =
  {
    srcPath,
    dstPath,
    resolvingSrcSoftLink : 1,
    throwing : 0
  }
  provider.fileCopy( o )
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), routinePath );

  test.case = 'rewriting terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  var o =
  {
    srcPath,
    dstPath,
    rewriting : 0,
    throwing : 1
  }
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( o ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPath );
  test.identical( provider.fileRead( dstPath ), dstPath );

  /* - */

  test.case = 'rewriting terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  var o =
  {
    srcPath,
    dstPath,
    rewriting : 0,
    throwing : 0
  }
  var got = provider.fileCopy( o );
  test.identical( got, null );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPath );
  test.identical( provider.fileRead( dstPath ), dstPath );

  /* - */

  test.case = 'rewriting routinePath by terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  var o =
  {
    srcPath,
    dstPath,
    rewriting : 1,
    rewritingDirs : 0,
    throwing : 1
  }
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( o ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isDir( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPath );
  test.identical( provider.dirRead( dstPath ), [] );

  /* - */

  test.case = 'rewriting routinePath by terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  var o =
  {
    srcPath,
    dstPath,
    rewriting : 1,
    rewritingDirs : 0,
    throwing : 0
  }
  var got = provider.fileCopy( o );
  test.identical( got, null );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isDir( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPath );
  test.identical( provider.dirRead( dstPath ), [] );

  /* - */

  test.case = 'error on resolve src';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  var o =
  {
    srcPath,
    dstPath,
    allowingMissed : 0,
    throwing : 1
  }
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( o ) );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), dstPath );

  /* - */

  test.case = 'error on resolve src';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  var o =
  {
    srcPath,
    dstPath,
    allowingMissed : 0,
    throwing : 0
  }
  var got = provider.fileCopy( o );
  test.identical( got, null );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), dstPath );

  /* - */

  test.case = 'error on resolve src';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
  var o =
  {
    srcPath,
    dstPath,
    resolvingSrcSoftLink : 0,
    throwing : 1,
    allowingMissed : 0,
  }
  test.mustNotThrowError( () => provider.fileCopy( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  /* - */

  test.case = 'error on resolve src';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
  var o =
  {
    srcPath,
    dstPath,
    resolvingSrcSoftLink : 0,
    throwing : 0,
    allowingMissed : 0,
  }
  test.mustNotThrowError( () => provider.fileCopy( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  /* - */

  test.case = 'error on fileCopy missed link should not be throwen';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
  var o =
  {
    srcPath,
    dstPath,
    resolvingSrcSoftLink : 0,
    throwing : 1,
    allowingMissed : 0,
  }
  var r = provider.fileCopy( o );
  test.is( r );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );

  /* - */

  test.case = 'error on fileCopy missed link should not be throwen';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
  var o =
  {
    srcPath,
    dstPath,
    resolvingSrcSoftLink : 0,
    throwing : 0,
    allowingMissed : 0,
  }
  var r = provider.fileCopy( o );
  test.is( r );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );

  /* - */

  test.case = 'error on resolve src';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
  var o =
  {
    srcPath,
    dstPath,
    allowingMissed : 0,
    resolvingSrcSoftLink : 1,
    throwing : 1
  }
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
  test.identical( provider.fileRead( dstPath ), dstPath );

  /* - */

  test.case = 'error on resolve src';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
  var o =
  {
    srcPath,
    dstPath,
    allowingMissed : 0,
    resolvingSrcSoftLink : 1,
    throwing : 0
  }
  var got = provider.fileCopy( o );
  test.identical( got, null );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
  test.identical( provider.fileRead( dstPath ), dstPath );

}

//

function fileCopySoftLinkExtended( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/fileCopySoftLinkExtended' );
  let srcPath = test.context.pathFor( 'written/fileCopySoftLinkExtended/src' );
  let dstPath = test.context.pathFor( 'written/fileCopySoftLinkExtended/dst' );
  let terminalPath = test.context.pathFor( 'written/fileCopySoftLinkExtended/terminal' );
  let dirPath = test.context.pathFor( 'written/fileCopySoftLinkExtended/dir' );
  let terminalInDirPath = test.context.pathFor( 'written/fileCopySoftLinkExtended/dir/terminal' );
  let missingPath = test.context.pathFor( 'written/fileCopySoftLinkExtended/missing' );

  /* */

  test.open( 'src soft link to terminal, dst missing' );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( srcPath, terminalPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath )

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( srcPath, terminalPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.identical( provider.pathResolveSoftLink( dstPath ), terminalPath )

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( srcPath, terminalPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), terminalPath );

  test.close( 'src soft link to terminal, dst missing' );

  /* */

  test.open( 'src soft link to terminal, dst terminal' );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink( srcPath, terminalPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath )

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink( srcPath, terminalPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.identical( provider.pathResolveSoftLink( dstPath ), terminalPath )

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( srcPath, terminalPath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), terminalPath );

  test.close( 'src soft link to terminal, dst terminal' );

  /* */

  test.open( 'src soft link to dir, dst missing' );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink( srcPath, dirPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath )

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink( srcPath, dirPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.identical( provider.pathResolveSoftLink( dstPath ), dirPath )

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink( srcPath, dirPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( srcPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), dirPath );
  test.is( provider.isDir( dirPath ) );
  test.is( provider.isDir( dstPath ) );

  test.close( 'src soft link to dir, dst missing' );

  /* */

  test.open( 'src dir, dst missing' );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 })
  });
  test.is( provider.isDir( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 })
  });
  test.is( provider.isDir( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 })
  test.is( provider.isDir( srcPath ) );
  test.is( provider.isDir( dstPath ) );
  test.identical( provider.dirRead( dstPath ), [] );

  test.close( 'src dir, dst missing' );

  /* */

  test.open( 'src missing, dst missing' );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 })
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 1, allowingMissed : 1 '
  provider.filesDelete( routinePath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 })
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 2, allowingMissed : 1 '
  provider.filesDelete( routinePath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 })
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.close( 'src missing, dst missing' );

  /* */

  test.open( 'src missing, dst terminal' );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 })
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 1, allowingMissed : 1 '
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 })
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 2, allowingMissed : 1 '
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 })
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.close( 'src missing, dst terminal' );

  /* */

  test.open( 'src missing, dst empty directory' );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );

  test.close( 'src missing, dst empty directory' );

  /* */

  test.open( 'src missing, dst directory' );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath : dirPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dirPath ) );

  test.case = 'resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath : dirPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1  })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dirPath ) );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath : dirPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dirPath ) );

  test.case = 'resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath : dirPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1  })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dirPath ) );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath : dirPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dirPath ) );

  test.case = 'resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath : dirPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1  })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dirPath ) );

  test.close( 'src missing, dst directory' );

  /* */

  test.open( 'src soft link to missing, dst missing' );

  test.case = 'resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath )

  test.case = 'resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath )

  test.case = 'resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 0 });
  });
  test.is( provider.isSoftLink( srcPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )

  test.case = 'resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), terminalPath );

  test.case = 'resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 0 });
  });
  test.is( provider.isSoftLink( srcPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )

  test.case = 'resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )

  test.close( 'src soft link to missing, dst missing' );

  /* */

  test.open( 'src soft link to missing, dst terminal' );

  test.case = 'resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath )

  test.case = 'resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath )

  test.case = 'resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 0 });
  });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )

  test.case = 'resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), terminalPath );

  test.case = 'resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 0 });
  });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )

  test.case = 'resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )

  test.close( 'src soft link to missing, dst terminal' );
}

//

function fileCopyResolvingBasic( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/fileCopyResolvingBasic' );
  let src1Path = test.context.pathFor( 'written/fileCopyResolvingBasic/src1' );
  let src2Path = test.context.pathFor( 'written/fileCopyResolvingBasic/src2' );
  let src3Path = test.context.pathFor( 'written/fileCopyResolvingBasic/src3' );
  let dstPath = test.context.pathFor( 'written/fileCopyResolvingBasic/dst' );

  /*
      src1 -> src2 -> src3
      resolvingSrcSoftLink : 0
      fileCopy
        - link dst -> src1

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 1
      fileCopy
        - link dst -> src3

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 2
      fileCopy
        - copy src3 -> dst
  */

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src3Path );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src3Path );

  /* text link */

  provider.fieldPush( 'usingTextLink', 1 )

  test.case = 'resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, src3Path );
  provider.textLink( src1Path, src2Path );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, src3Path );
  provider.textLink( src1Path, src2Path );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src3Path );

  test.case = 'resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, src3Path );
  provider.textLink( src1Path, src2Path );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 2 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src3Path );

  provider.fieldPop( 'usingTextLink', 1 )
}

//

function fileCopyRelativeLinking( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopy ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileCopyRelativeLinking' );
  let src1Path = test.context.pathFor( 'written/fileCopyRelativeLinking/src1' );
  let src2Path = test.context.pathFor( 'written/fileCopyRelativeLinking/src2' );
  let src3Path = test.context.pathFor( 'written/fileCopyRelativeLinking/src3' );
  let dstPath = test.context.pathFor( 'written/fileCopyRelativeLinking/dst' );

  /*
    src1 -> ../src2
    fileCopy dst src1
    resolvingSrcSoftLink : 0
    - link dst -> src1

    src1 -> ../src2
    fileCopy dst src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 -> ../src2
    fileCopy dst ../src1
    resolvingSrcSoftLink : 0
    - link dst -> ../src1

    src1 -> ../src2
    fileCopy dst ../src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 as :
    - missing file
    - link

    src2 as :
    - terminal
    - intermediate link
    - missing

  */

  /* src1 missing */

  test.case = '../src1 is missing, allowingMissed:0';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = '../src1 is missing, allowingMissed:1';
  provider.filesDelete( routinePath );
  provider.fileCopy
  ({
    srcPath : '../src1',
    dstPath,
    resolvingSrcSoftLink : 0,
    resolvingSrcTextLink : 0,
    makingDirectory : 1,
    allowingMissed : 1
  });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /*  */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src2Path );

  /* */

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src2Path );

  /* missing absolute src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /* missing relative src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileCopy({ srcPath : test.context.globalFromPreferred( '../src1' ), dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /* chain */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.fileRead( dstPath ), src3Path );

  /*  */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.fileRead( dstPath ), src3Path );
}

//

function fileCopyGlobal( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( provider instanceof _.FileProvider.System )
  {
    test.identical( 1, 1 )
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileCopyGlobal' );
  let srcPath = test.context.pathFor( 'written/fileCopyGlobal/src' );
  let dstPath = test.context.pathFor( 'written/fileCopyGlobal/dst' );

  var srcPathDefault = path.globalFromPreferred( srcPath );
  var dstPathDefault = path.globalFromPreferred( dstPath );

  var srcPathSecond = 'second://' + srcPath;
  var dstPathSecond = 'second://' + dstPath;

  var dstPathUnknown = 'unknown://' + dstPath;

  test.identical( provider.protocols, [ 'current', 'second' ] )

  /*  */

  test.open( 'with system' )

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopy( dstPathDefault, srcPathDefault );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), srcPath );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopy( dstPathSecond, srcPathSecond );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), srcPath );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.fileCopy( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.close( 'with system' )

  /* */

  test.open( 'without system' )

  context.system.providerUnregister( provider );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopy( dstPathDefault, srcPathDefault );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), srcPath );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopy( dstPathSecond, srcPathSecond );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), srcPath );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.fileCopy( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  context.system.providerRegister( provider );

  test.close( 'without system' )

}

//

function fileCopyAsyncThrowingError( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/fileCopyAsyncThrowingError' );
  let srcPath = test.context.pathFor( 'written/fileCopyAsyncThrowingError/src' );
  let dstPath = test.context.pathFor( 'written/fileCopyAsyncThrowingError/dst' );
  let missingPath = test.context.pathFor( 'written/fileCopyAsyncThrowingError/missing' );

  let con = new _.Consequence().take( null )

  /**/

  .then( () =>
  {
    test.case = 'missing';
    provider.filesDelete( routinePath );
    var o =
    {
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    }
    return test.shouldThrowErrorOfAnyKind( provider.fileCopy( o ) )
    .then( () =>
    {
      test.is( !provider.fileExists( srcPath ) );
      test.is( !provider.fileExists( dstPath ) );
      return true;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'missing';
    provider.filesDelete( routinePath );
    var o =
    {
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 0
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.identical( got, null );
      test.is( !provider.fileExists( srcPath ) );
      test.is( !provider.fileExists( dstPath ) );
      return true;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'try to copy dir';
    provider.filesDelete( routinePath );
    provider.dirMake( srcPath );
    var o =
    {
      srcPath,
      dstPath,
      sync : 0,
      throwing : 1
    }
    return test.shouldThrowErrorOfAnyKind( provider.fileCopy( o ) )
    .then( () =>
    {
      test.is( provider.fileExists( srcPath ) );
      test.is( provider.isDir( srcPath ) );
      test.is( !provider.fileExists( dstPath ) );
      return true;
    })

  })

  /* - */

  .then( () =>
  {
    test.case = 'try to copy dir';
    provider.filesDelete( routinePath );
    provider.dirMake( srcPath );
    var o =
    {
      srcPath,
      dstPath,
      sync : 0,
      throwing : 0
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.identical( got, null );
      test.is( provider.fileExists( srcPath ) );
      test.is( provider.isDir( srcPath ) );
      test.is( !provider.fileExists( dstPath ) );
      return true;
    })

  })

  /* - */

  .then( () =>
  {
    test.case = 'try to copy soft link to dir';
    provider.filesDelete( routinePath );
    provider.dirMake( routinePath );
    provider.softLink( srcPath, routinePath );
    var o =
    {
      srcPath,
      dstPath,
      resolvingSrcSoftLink : 1,
      sync : 0,
      throwing : 1
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.identical( got, true );
      test.is( provider.fileExists( srcPath ) );
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( dstPath ), routinePath );
      return true;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'try to copy soft link to dir';
    provider.filesDelete( routinePath );
    provider.dirMake( routinePath );
    provider.softLink( srcPath, routinePath );
    var o =
    {
      srcPath,
      dstPath,
      resolvingSrcSoftLink : 1,
      sync : 0,
      throwing : 1
    }
    return provider.fileCopy( o )
    .then( () =>
    {
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( dstPath ), routinePath );
      return true;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'try to copy soft link to dir';
    provider.filesDelete( routinePath );
    provider.dirMake( routinePath );
    provider.softLink( srcPath, routinePath );
    var o =
    {
      srcPath,
      dstPath,
      resolvingSrcSoftLink : 1,
      sync : 0,
      throwing : 0
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.identical( got, true );
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( dstPath ), routinePath );
      return true;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'rewriting terminal';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( dstPath, dstPath );
    var o =
    {
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    }
    return test.shouldThrowErrorOfAnyKind( provider.fileCopy( o ) )
    .then( () =>
    {
      test.is( provider.isTerminal( srcPath ) );
      test.is( provider.isTerminal( dstPath ) );
      test.identical( provider.fileRead( srcPath ), srcPath );
      test.identical( provider.fileRead( dstPath ), dstPath );
      return true;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'rewriting terminal';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( dstPath, dstPath );
    var o =
    {
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.identical( got, null );
      test.is( provider.isTerminal( srcPath ) );
      test.is( provider.isTerminal( dstPath ) );
      test.identical( provider.fileRead( srcPath ), srcPath );
      test.identical( provider.fileRead( dstPath ), dstPath );
      return true;
    })

  })

  /* - */

  .then( () =>
  {
    test.case = 'rewriting routinePath by terminal';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.dirMake( dstPath );
    var o =
    {
      srcPath,
      dstPath,
      rewriting : 1,
      rewritingDirs : 0,
      sync : 0,
      throwing : 1
    }
    return test.shouldThrowErrorOfAnyKind( provider.fileCopy( o ) )
    .then( () =>
    {
      test.is( provider.isTerminal( srcPath ) );
      test.is( provider.isDir( dstPath ) );
      test.identical( provider.fileRead( srcPath ), srcPath );
      test.identical( provider.dirRead( dstPath ), [] );
      return true;
    })

  })

  /* - */

  .then( () =>
  {
    test.case = 'rewriting routinePath by terminal';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.dirMake( dstPath );
    var o =
    {
      srcPath,
      dstPath,
      rewriting : 1,
      rewritingDirs : 0,
      sync : 0,
      throwing : 0
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.identical( got, null );
      test.is( provider.isTerminal( srcPath ) );
      test.is( provider.isDir( dstPath ) );
      test.identical( provider.fileRead( srcPath ), srcPath );
      test.identical( provider.dirRead( dstPath ), [] );
      return true;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'error on resolve src';
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, dstPath );
    var o =
    {
      srcPath,
      dstPath,
      allowingMissed : 0,
      sync : 0,
      throwing : 1
    }
    return test.shouldThrowErrorOfAnyKind( provider.fileCopy( o ) )
    .then( () =>
    {
      test.is( !provider.fileExists( srcPath ) );
      test.is( provider.isTerminal( dstPath ) );
      test.identical( provider.fileRead( dstPath ), dstPath );
      return true;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'error on resolve src';
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, dstPath );
    var o =
    {
      srcPath,
      dstPath,
      allowingMissed : 0,
      sync : 0,
      throwing : 0
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.identical( got, null );
      test.is( !provider.fileExists( srcPath ) );
      test.is( provider.isTerminal( dstPath ) );
      test.identical( provider.fileRead( dstPath ), dstPath );
      return true;
    })

  })

  .then( () =>
  {
    test.case = 'error on resolve src';
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, dstPath );
    provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
    var o =
    {
      srcPath,
      dstPath,
      resolvingSrcSoftLink : 1,
      throwing : 1,
      sync : 0,
      allowingMissed : 1,
    }
    return provider.fileCopy( o )
    .then( () =>
    {
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
      test.identical( provider.pathResolveSoftLink( dstPath ), missingPath );
      return true;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'error on resolve src';
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, dstPath );
    provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
    var o =
    {
      srcPath,
      dstPath,
      resolvingSrcSoftLink : 1,
      throwing : 1,
      sync : 0,
      allowingMissed : 0,
    }
    return test.shouldThrowErrorAsync( provider.fileCopy( o ) )
    .then( () =>
    {
      test.is( provider.isSoftLink( srcPath ) );
      test.is( !provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
      test.identical( provider.pathResolveSoftLink( dstPath ), dstPath );
      return true;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'error on fileCopy missed link should not be throwen';
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, dstPath );
    provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
    var o =
    {
      srcPath,
      dstPath,
      resolvingSrcSoftLink : 0,
      throwing : 1,
      sync : 0,
      allowingMissed : 0,
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.is( got );
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
      return true;
    })

  })

  /* - */

  .then( () =>
  {
    test.case = 'error on fileCopy missed link should not be throwen';
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, dstPath );
    provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
    var o =
    {
      srcPath,
      dstPath,
      resolvingSrcSoftLink : 0,
      sync : 0,
      throwing : 0,
      allowingMissed : 0,
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.is( got );
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
      return true;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'error on resolve src';
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, dstPath );
    provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
    var o =
    {
      srcPath,
      dstPath,
      allowingMissed : 0,
      sync : 0,
      resolvingSrcSoftLink : 1,
      throwing : 1
    }
    return test.shouldThrowErrorOfAnyKind( provider.fileCopy( o ) )
    .then( () =>
    {
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isTerminal( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
      test.identical( provider.fileRead( dstPath ), dstPath );
      return true;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'error on resolve src';
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, dstPath );
    provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
    var o =
    {
      srcPath,
      dstPath,
      allowingMissed : 0,
      sync : 0,
      resolvingSrcSoftLink : 1,
      throwing : 0
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.identical( got, null );
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isTerminal( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
      test.identical( provider.fileRead( dstPath ), dstPath );
      return true;
    })

  })

  return con;
}

//

// function fileCopyAsyncThrowingError( test )
// {
//   let context = this;
//   let provider = context.provider;

//   if( !_.routineIs( provider.fileCopy ) )
//   return;

//   var routinePath = test.context.pathFor( 'written/fileCopyAsync' );

//   if( !provider.statResolvedRead( routinePath ) )
//   provider.dirMake( routinePath );

//   var consequence = new _.Consequence().take( null );

//   consequence
//   .ifNoErrorThen( function( arg )
//   {
//     test.case = 'async, throwing error';
//     var con = provider.fileCopy
//     ({
//       srcPath : test.context.pathFor( 'invalid.txt' ),
//       dstPath : test.context.pathFor( 'dstPath.txt' ),
//       sync : 0,
//     });

//     return test.shouldThrowErrorOfAnyKind( con );
//   })
//   .ifNoErrorThen( function( arg )
//   {
//     test.case = 'async, try rewrite dir';
//     var con = provider.fileCopy
//     ({
//       srcPath : test.context.pathFor( 'invalid.txt' ),
//       dstPath : test.context.pathFor( 'tmp' ),
//       sync : 0,
//     });

//     return test.shouldThrowErrorAsync( con );
//   })
//   .ifNoErrorThen( function( arg )
//   {
//     test.case = 'async copy dir';
//     try
//     {
//       provider.dirMake
//       ({
//         filePath : test.context.pathFor( 'written/fileCopyAsync/copydir' ),
//         sync : 1
//       });
//       provider.fileWrite
//       ({
//         filePath : test.context.pathFor( 'written/fileCopyAsync/copydir/copyfile.txt' ),
//         data : 'Lorem',
//         sync : 1
//       });
//     } catch ( err ) { }

//     debugger;
//     var con = provider.fileCopy
//     ({
//         srcPath : test.context.pathFor( 'written/fileCopyAsync/copydir' ),
//         dstPath : test.context.pathFor( 'written/fileCopyAsync/copydir2' ),
//         sync : 0,
//     });

//     return test.shouldThrowErrorAsync( con );
//   });

//   return consequence;
// }

//

function fileCopyHardLinkedSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopy ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  let routinePath = test.context.pathFor( 'written/fileCopyHardLinkedSync' );
  let srcPath = test.context.pathFor( 'written/fileCopyHardLinkedSync/src' );
  let dstPath = test.context.pathFor( 'written/fileCopyHardLinkedSync/dst' );

  /* - */

  test.case = 'breakingDstHardLink=0'
  provider.filesDelete( routinePath )
  provider.fileWrite( srcPath, 'data' );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
  provider.fileCopy({ dstPath, srcPath, breakingDstHardLink : 0 });
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );

  /* - */

  test.case = 'breakingDstHardLink=1'
  provider.filesDelete( routinePath )
  provider.fileWrite( srcPath, 'data' );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
  provider.fileCopy({ dstPath, srcPath, breakingDstHardLink : 1 });
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), false );
}

//

function fileCopyHardLinkedAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopy ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  let routinePath = test.context.pathFor( 'written/fileCopyHardLinkedAsync' );
  let srcPath = test.context.pathFor( 'written/fileCopyHardLinkedAsync/src' );
  let dstPath = test.context.pathFor( 'written/fileCopyHardLinkedAsync/dst' );

  let ready = new _.Consequence().take( null )

  /* - */

  .then( () =>
  {
    test.case = 'breakingDstHardLink=0'
    provider.filesDelete( routinePath )
    provider.fileWrite( srcPath, 'data' );
    provider.hardLink( dstPath, srcPath );
    if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
    else
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
    return provider.fileCopy
    ({
      dstPath,
      srcPath,
      breakingDstHardLink : 0,
      sync : 0
    });
  })
  .then( () =>
  {
    if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
    else
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
    return null;
  })

  /* - */

  .then( () =>
  {
    test.case = 'breakingDstHardLink=1'
    provider.filesDelete( routinePath )
    provider.fileWrite( srcPath, 'data' );
    provider.hardLink( dstPath, srcPath );
    if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
    else
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
    return provider.fileCopy
    ({
      dstPath,
      srcPath,
      breakingDstHardLink : 1,
      sync : 0
    });
  })
  .then( () =>
  {
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), false );
    return null;
  })

  /* - */

  return ready;
}

//

function fileRenameSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRenameAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var got;
  var srcPath = test.context.pathFor( 'written/fileRename/src' );
  var dstPath = test.context.pathFor( 'written/fileRename/dst' );
  var routinePath  = context.provider.path.dir( srcPath );

  /* - */

  test.case = 'src not exist';

  test.shouldThrowErrorSync( function()
  {
    provider.fileRename
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 1,
      rewriting : 1,
      throwing : 1,
    });
  });

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 1,
      rewriting : 1,
      throwing : 0,
    });
  });
  test.identical( got, null );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.fileRename
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 1,
      rewriting : 0,
      throwing : 1,
    });
  });

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 1,
      rewriting : 0,
      throwing : 0,
    });
  });
  test.identical( got, null );

  /* - */

  test.case = 'rename in same directory, dst not exist';

  /**/

  provider.fileWrite( srcPath, ' ' );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 0
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 1
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 0
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /* - */

  test.case = 'rename with rewriting in same directory';

  /**/

  provider.fileWrite( srcPath, ' ' );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.fileWrite( srcPath, ' ' );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 0
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.fileWrite( srcPath, ' ' );
  test.shouldThrowErrorSync( function()
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 0,
      throwing : 1
    });
  });

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 0,
      throwing : 0
    });
  });
  test.identical( got, null );

  /* - */

  test.case = 'rename routinePath, dst not exist';
  provider.filesDelete( routinePath );

  /**/

  provider.dirMake( srcPath );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( dstPath );
  provider.dirMake( srcPath );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 0
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( dstPath );
  provider.dirMake( srcPath );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 1
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( dstPath );
  provider.dirMake( srcPath );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 0
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /* - */

  test.case = 'rename moving to other existing dir';

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  provider.dirMake( context.provider.path.dir( dstPath ) );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  test.identical( got, true );
  var files = provider.dirRead( context.provider.path.dir( dstPath ) );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  provider.dirMake( context.provider.path.dir( dstPath ) );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 1
  });
  test.identical( got, true );
  var files = provider.dirRead( context.provider.path.dir( dstPath ) );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  provider.dirMake( context.provider.path.dir( dstPath ) );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 0
  });
  test.identical( got, true );
  var files = provider.dirRead( context.provider.path.dir( dstPath ) );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  provider.dirMake( context.provider.path.dir( dstPath ) );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 0
  });
  test.identical( got, true );
  var files = provider.dirRead( context.provider.path.dir( dstPath ) );
  test.identical( files, [ 'dst' ] );

  /* - */

  test.case = 'rename moving to not existing dir';

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  test.shouldThrowErrorSync( function()
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1,
      throwing : 1
    });
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 0,
      throwing : 1
    });
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1,
      throwing : 0
    });
  });
  test.identical( got, null )
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 0,
      throwing : 0
    });
  });
  test.identical( got, null )
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /* - */

  test.case = 'dst is not empty dir';

  /**/

  debugger
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  provider.fileWrite( dstPath, ' ' );
  got = provider.fileRename
  ({
    srcPath,
    dstPath : context.provider.path.dir( dstPath ),
    sync : 1,
    rewriting : 1,
    rewritingDirs : 1,
    throwing : 1
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'routinePath' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  provider.fileWrite( dstPath, ' ' );
  got = provider.fileRename
  ({
    srcPath,
    dstPath : context.provider.path.dir( dstPath ),
    sync : 1,
    rewriting : 1,
    rewritingDirs : 1,
    throwing : 0
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'routinePath' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  provider.fileWrite( dstPath, ' ' );
  test.shouldThrowErrorSync( function()
  {
    provider.fileRename
    ({
      srcPath,
      dstPath : context.provider.path.dir( dstPath ),
      sync : 1,
      rewriting : 0,
      throwing : 1
    });
  });

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  provider.fileWrite( dstPath, ' ' );
  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath,
      dstPath : context.provider.path.dir( dstPath ),
      sync : 1,
      rewriting : 0,
      throwing : 0
    });
  });
  test.identical( got, null );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'routinePath', 'src' ] );

  //src is equal to dst

  test.case = 'src is equal to dst';

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 1,
      throwing : 1
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      throwing : 1
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 1,
      throwing : 0
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      throwing : 0
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

}

//

function fileRenameSync2( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRenameAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var got;
  var srcPath = test.context.pathFor( 'written/fileRename/src' );
  var dstPath = test.context.pathFor( 'written/fileRename/dst' );
  var routinePath  = context.provider.path.dir( srcPath );

  test.open( 'rewriting terminal' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      rewritingDirs : 0,
      throwing : 1
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  var dstRead = provider.fileRead( dstPath );
  test.identical( srcRead, srcPath );
  test.identical( dstRead, dstPath );

  /* - */

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      rewritingDirs : 1,
      throwing : 1
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  var dstRead = provider.fileRead( dstPath );
  test.identical( srcRead, srcPath );
  test.identical( dstRead, dstPath );

  /* - */

  test.mustNotThrowError( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      rewritingDirs : 0,
      throwing : 0
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  var dstRead = provider.fileRead( dstPath );
  test.identical( srcRead, srcPath );
  test.identical( dstRead, dstPath );

  /* - */

  test.mustNotThrowError( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      rewritingDirs : 1,
      throwing : 0
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  var dstRead = provider.fileRead( dstPath );
  test.identical( srcRead, srcPath );
  test.identical( dstRead, dstPath );

  /* - */

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileRename
  ({
    srcPath,
    dstPath,
    rewriting : 1,
    rewritingDirs : 0,
    throwing : 1
  })
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var dstRead = provider.fileRead( dstPath );
  test.identical( dstRead, srcPath );

  /* - */

  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileRename
  ({
    srcPath,
    dstPath,
    rewriting : 1,
    rewritingDirs : 1,
    throwing : 1
  })
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var dstRead = provider.fileRead( dstPath );
  test.identical( dstRead, srcPath );

  test.close( 'rewriting terminal' );

  /**/

  test.open( 'rewriting directory' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      rewritingDirs : 0,
      throwing : 1
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  test.identical( srcRead, srcPath );

  /* - */

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      rewritingDirs : 1,
      throwing : 1
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  test.identical( srcRead, srcPath );

  /* - */

  test.mustNotThrowError( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      rewritingDirs : 0,
      throwing : 0
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  test.identical( srcRead, srcPath );

  /* - */

  test.mustNotThrowError( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      rewritingDirs : 1,
      throwing : 0
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  test.identical( srcRead, srcPath );

  /* - */

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      rewritingDirs : 0,
      throwing : 1
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  test.identical( srcRead, srcPath );

  /* - */

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  provider.fileRename
  ({
    srcPath,
    dstPath,
    rewriting : 1,
    rewritingDirs : 1,
    throwing : 1
  })
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var dstRead = provider.fileRead( dstPath );
  test.identical( dstRead, srcPath );

  test.close( 'rewriting directory' );

  /**/

  test.open( 'making directory' );

  dstPath = provider.path.join( dstPath, 'dstFile' );
  provider.filesDelete( routinePath );

  /* - */

  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      rewritingDirs : 1,
      makingDirectory : 0,
      throwing : 1
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  test.identical( srcRead, srcPath );

  /* - */

  provider.fileWrite( srcPath, srcPath );
  test.mustNotThrowError( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      rewritingDirs : 1,
      makingDirectory : 0,
      throwing : 0
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  test.identical( srcRead, srcPath );

  /* - */

  provider.fileWrite( srcPath, srcPath );
  provider.fileRename
  ({
    srcPath,
    dstPath,
    rewriting : 1,
    rewritingDirs : 1,
    makingDirectory : 1,
    throwing : 1
  })
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var dstRead = provider.fileRead( dstPath );
  test.identical( dstRead, srcPath );

  test.close( 'making directory' );
}

//

function fileRenameRelativePath( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRenameAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileRenameRelativePath' );
  let pathToDir = test.context.pathFor( 'written/fileRenameRelativePath/dir' );
  let pathToFile = test.context.pathFor( 'written/fileRenameRelativePath/file' );

  test.open( 'src - relative path to a file' );

  var srcPath = '../file';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.fileRead( dstPath );
  test.identical( got, pathToFile );

  var srcPath = './../file';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.fileRead( dstPath );
  test.identical( got, pathToFile );


  var srcPath = '../../file';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/dstPath/dstFile' );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.dirMakeForFile( dstPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.fileRead( dstPath );
  test.identical( got, pathToFile );

  var srcPath = './../../file';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/dstPath/dstFile' );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.dirMakeForFile( dstPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.fileRead( dstPath );
  test.identical( got, pathToFile );

  var srcPath = './../../../file';
  var pathToFile2 = test.context.pathFor( 'written/fileRenameRelativePath/a/file' );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/a/b/c/dstFile' );
  provider.dirMakeForFile( dstPath )
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile2 ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.fileRead( dstPath );
  test.identical( got, pathToFile2 );

  var srcPath = '../../../file';
  var pathToFile2 = test.context.pathFor( 'written/fileRenameRelativePath/a/file' );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/a/b/c/dstFile' );
  provider.dirMakeForFile( dstPath )
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile2 ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.fileRead( dstPath );
  test.identical( got, pathToFile2 );

  test.close( 'src - relative path to a file' );

  /* - */

  test.open( 'dst - relative path to a file' );

  pathToFile = test.context.pathFor( 'written/fileRenameRelativePath/a/b/c/file' );

  var srcPath = pathToFile;
  var dstPath = '../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.fileRead( dstPathResolved );
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = './../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.fileRead( dstPathResolved );
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = '../../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.fileRead( dstPathResolved );
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = './../../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.fileRead( dstPathResolved );
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = './../../../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.fileRead( dstPathResolved );
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = '../../../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.fileRead( dstPathResolved );
  test.identical( got, pathToFile );

  test.close( 'dst - relative path to a file' );

  /* - */

  test.open( 'src - relative path to a dir' );

  var srcPath = '../dir';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/dstPath' );
  var fileInDirPath = provider.path.join( routinePath, 'dir', 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToDir ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.dirRead( dstPath );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = './../dir';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/dstPath' );
  var fileInDirPath = provider.path.join( routinePath, 'dir', 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToDir ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.dirRead( dstPath );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = '../../dir';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/dst/dstPath' );
  var fileInDirPath = provider.path.join( routinePath, 'dir', 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.dirMakeForFile( dstPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToDir ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.dirRead( dstPath );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = './../../dir';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/dst/dstPath' );
  var fileInDirPath = provider.path.join( routinePath, 'dir', 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.dirMakeForFile( dstPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToDir ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.dirRead( dstPath );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = '../../../dir';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/a/b/dstPath' );
  var fileInDirPath = provider.path.join( routinePath, 'dir', 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.dirMakeForFile( dstPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToDir ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.dirRead( dstPath );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = './../../../dir';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/a/b/dstPath' );
  var fileInDirPath = provider.path.join( routinePath, 'dir', 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.dirMakeForFile( dstPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToDir ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.dirRead( dstPath );
  test.identical( got, [ 'fileInDir' ] );

  test.close( 'src - relative path to a dir' );

  /* - */

  test.open( 'dst - relative path to a dir' );

  pathToDir = test.context.pathFor( 'written/fileRenameRelativePath/1/2/3/dir' )

  var srcPath = pathToDir;
  var dstPath = '../dstPath';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  var fileInDirPath = provider.path.join( pathToDir, 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( srcPath ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.dirRead( dstPathResolved );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = './../dstPath';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  var fileInDirPath = provider.path.join( pathToDir, 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( srcPath ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.dirRead( dstPathResolved );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = '../../dstPath';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  var fileInDirPath = provider.path.join( pathToDir, 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( srcPath ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.dirRead( dstPathResolved );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = './../../dstPath';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  var fileInDirPath = provider.path.join( pathToDir, 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( srcPath ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.dirRead( dstPathResolved );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = '../../../dstPath';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  var fileInDirPath = provider.path.join( pathToDir, 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( srcPath ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.dirRead( dstPathResolved );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = './../../../dstPath';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  var fileInDirPath = provider.path.join( pathToDir, 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( srcPath ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.dirRead( dstPathResolved );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = '../a/b/dstPath';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  var fileInDirPath = provider.path.join( pathToDir, 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( srcPath ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.dirRead( dstPathResolved );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = './../a/b/dstPath';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  var fileInDirPath = provider.path.join( pathToDir, 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( srcPath ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.dirRead( dstPathResolved );
  test.identical( got, [ 'fileInDir' ] );

  test.close( 'dst - relative path to a dir' );

  test.open( 'same paths' );

  pathToFile =  test.context.pathFor( 'written/fileRenameRelativePath/file' )

  var srcPath = pathToFile;
  var dstPath = '../file';
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  var statBefore = provider.statResolvedRead( pathToFile );
  var got = provider.fileRename( dstPath, srcPath );
  test.identical( got, true );
  var statNow = provider.statResolvedRead( pathToFile );
  test.identical( statBefore.mtime.getTime(), statNow.mtime.getTime() );

  var srcPath = '../file';
  var dstPath = pathToFile;
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  var statBefore = provider.statResolvedRead( pathToFile );
  var got = provider.fileRename( dstPath, srcPath );
  test.identical( got, true );
  var statNow = provider.statResolvedRead( pathToFile );
  test.identical( statBefore.mtime.getTime(), statNow.mtime.getTime() );

  test.close( 'same paths' );

}

//

function fileRenameAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRenameAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var got;
  var srcPath = test.context.pathFor( 'written/fileRenameAsync/src' );
  var dstPath = test.context.pathFor( 'written/fileRenameAsync/dst' );
  var routinePath  = context.provider.path.dir( srcPath );


  var consequence = new _.Consequence().take( null );

  consequence
  .ifNoErrorThen( function( arg )
  {
    test.case = 'src not exist';
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRename
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 0,
      rewriting : 1,
      throwing : 1,
    });

    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  consequence
  .finally( function()
  {
    var con = provider.fileRename
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 0,
      rewriting : 1,
      throwing : 0,
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      return got;
    });
  })

  /**/

  consequence
  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRename
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 0,
      rewriting : 0,
      throwing : 1,
    });

    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    var con = provider.fileRename
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 0,
      rewriting : 0,
      throwing : 0,
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      return got;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'rename in same directory, dst not exist';
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'rename with rewriting in same directory';
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });

  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });

  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    });

    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      return got;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'rename routinePath, dst not exist';
    provider.filesDelete( routinePath );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.dirMake( srcPath );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( dstPath );
    provider.dirMake( srcPath );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( dstPath );
    provider.dirMake( srcPath );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( dstPath );
    provider.dirMake( srcPath );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'rename moving to other existing dir';
    dstPath = test.context.pathFor( 'written/fileRenameAsync/routinePath/dst' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    provider.dirMake( context.provider.path.dir( dstPath ) );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( context.provider.path.dir( dstPath ) );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    provider.dirMake( context.provider.path.dir( dstPath ) );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( context.provider.path.dir( dstPath ) );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    provider.dirMake( context.provider.path.dir( dstPath ) );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( context.provider.path.dir( dstPath ) );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    provider.dirMake( context.provider.path.dir( dstPath ) );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( context.provider.path.dir( dstPath ) );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'rename moving to not existing dir';
    dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });

    return test.shouldThrowErrorOfAnyKind( con )
    .then( ( got ) =>
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    });

    return test.shouldThrowErrorOfAnyKind( con )
    .then( ( got ) =>
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null )
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null )
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return got;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dst is not empty dir';
    dstPath = test.context.pathFor( 'written/fileRenameAsync/routinePath/dst' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    provider.fileWrite( dstPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath : context.provider.path.dir( dstPath ),
      sync : 0,
      rewriting : 1,
      rewritingDirs : 1,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true )
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'routinePath' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    provider.fileWrite( dstPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath : context.provider.path.dir( dstPath ),
      sync : 0,
      rewriting : 1,
      rewritingDirs : 1,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true )
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'routinePath' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    provider.fileWrite( dstPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath : context.provider.path.dir( dstPath ),
      sync : 0,
      rewriting : 0,
      throwing : 1
    });

    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    provider.fileWrite( dstPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath : context.provider.path.dir( dstPath ),
      sync : 0,
      rewriting : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .then( ( got ) =>
    {
      test.identical( got, null );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'routinePath', 'src' ] );
      return got;
    });
  })

  //src is equal to dst

  .ifNoErrorThen( function( arg )
  {
    test.case = 'src is equal to dst';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRename
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRename
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRename
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return got;
    });
  })

  return consequence;
}

//

function fileRenameActSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRenameAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var got;

  var routinePath = test.context.pathFor( 'written/fileCopy' );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );

  /* - */

  test.case = 'no src';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
    })
  })

  /* - */

  test.case = 'no src';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
    })
  })

  /* - */

  test.case = 'no src';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
    })
  })

  /* - */

  test.case = 'no src';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
    })
  })

  /* - */

  test.case = 'no src, dst exists';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
    })
  })
  var dstFile = provider.fileRead( dstPath );
  test.identical( dstFile, dstPath );

  /* - */

  test.case = 'src : directory, no dst';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileRenameAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] )

  /* - */

  test.case = 'no structure before dst';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      context : provider,
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /* - */

  test.case = 'src - terminal, dst - directory';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      context : provider,
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dstPath', 'src' ] );
  var files = provider.dirRead( dstPath );
  test.identical( files, [] );
  /* - */

  test.case = 'simple rename';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileRenameAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  /* - */

  test.case = 'dst exists';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    provider.fileRenameAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      context : provider,
    });
    var files1 = provider.dirRead( routinePath );
    var expected1 = [ 'dst' ];
    test.identical( files1, expected1 );
    var dstFile1 = provider.fileRead( dstPath );
    test.identical( srcPath, dstFile1 );
  }
  else
  {
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.fileRenameAct
      ({
        srcPath,
        dstPath,
        relativeSrcPath : srcPath,
        relativeDstPath : dstPath,
        sync : 1,
        context : provider,
      });
    })
    var files2 = provider.dirRead( routinePath );
    var expected2 = [ 'dst', 'src' ];
    test.identical( files2, expected2 );
    var srcFile = provider.fileRead( srcPath );
    test.identical( srcFile, srcPath );
    var dstFile2 = provider.fileRead( dstPath );
    test.identical( dstFile2, dstPath );
  }

  /* - */

  var routinePath = test.context.pathFor( 'written/' + test.name );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  var otherPath = path.join( routinePath, 'other' );

  /* - */

  test.case = 'should not create folders structure for path';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'parent/dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct( o );
  })
  test.is( !provider.fileExists( dstPath ) );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
  }
  var expected = _.mapOwnKeys( o );
  provider.fileRenameAct( o );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'should path nativize all paths in options map if needed by its own means';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
  }

  var expected = _.mapExtend( null, o );

  provider.fileRenameAct( o );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );
  test.identical( o, expected );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'use terminal as parent directory';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath2 = path.join( srcPath, 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    srcPath,
    dstPath : dstPath2,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath2,
    sync : 1,
    context : provider,
  }
  test.shouldThrowErrorSync( () => provider.fileRenameAct( o ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath2 ) );

  /* - */

  if( !Config.debug )
  return;

  test.case = 'should assert that path is absolute';
  var srcPath = './dst';
  var dstPath = path.join( routinePath, 'dst' );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct
    ({
      dstPath,
      srcPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      context : provider,
    });
  })

  /* - */

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath, 'src' );;
  var dstPath = path.join( routinePath, 'dst' );

  /* sync option is missed */

  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    context : provider,
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct( o );
  });

  /* redundant option */

  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
    redundant : 'redundant'
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct( o );
  });

  /* - */

  test.case = 'should expect normalized path, but not nativized';
  var srcPath = routinePath + '\\src';
  provider.fileWrite( provider.path.normalize( srcPath ), srcPath );
  var dstPath = routinePath + '\\dst';
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
  }
  if( !context.providerIsInstanceOf( _.FileProvider.System ) )
  test.shouldThrowErrorOfAnyKind( () => provider.fileRenameAct( o ) );
  else
  test.mustNotThrowError( () => provider.fileRenameAct( o ) );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'should expect ready options map, no complex arguments preprocessing';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath : [ srcPath ],
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    context : provider,
  }
  var expected = _.mapExtend( null, o );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct( o );
  })
  test.identical( o.srcPath, expected.srcPath );
}

//

function fileRenameSoftLinkResolving( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRename ) )
  {
    test.identical( 1, 1 );
    return;
  }

  /*

  resolvingSrcSoftLink : [ 0, 1 ]
  resolvingDstSoftLink : [ 0, 1 ]
  link : [ normal, double, broken, context cycled, cycled, dst and src resolving to the same file ]

  */

  function fileRename( o )
  {
    let o2 =
    {
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1
    }
    _.mapSupplement( o, o2 )
    return provider.fileRename( o );
  }

  let routinePath = test.context.pathFor( 'written/fileRenameSoftLinkResolving' );
  let srcPath = provider.path.join( routinePath, 'src' );
  let srcPath2 = provider.path.join( routinePath, 'src2' );
  let dstPath = provider.path.join( routinePath, 'dst' );
  let dstPath2 = provider.path.join( routinePath, 'dst2' );
  let srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  let dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );

  /**/

  test.open( 'normal' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( provider.fileExists( srcPathTerminal ) );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileRename( o );
  test.is( provider.fileExists( srcPathTerminal ) );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  fileRename( o );
  test.is( provider.fileExists( srcPathTerminal ) );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathTerminal );

  test.close( 'normal' );

  /**/

  test.open( 'double' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( provider.fileExists( srcPathTerminal ) );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath2 );
  test.identical( provider.pathResolveLinkFull( srcPath2 ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveLinkFull( dstPath2 ).absolutePath, dstPathTerminal );
  test.identical( provider.fileRead( srcPath2 ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath2 ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );

  test.close( 'double' );

  /**/

  test.open( 'broken' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => fileRename( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => fileRename( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'broken' );

  /**/

  test.open( 'context cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => fileRename( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => fileRename( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'context cycled' );

  /* */

  test.open( 'cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, srcPath );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => fileRename( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  test.identical( provider.pathResolveLinkFull( dstPath2 ).absolutePath, srcPath );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => fileRename( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'cycled' );

  /**/

  test.open( 'links to same file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPathTerminal ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  fileRename( o );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );

  test.close( 'links to same file' );
}

//

function fileRenameResolvingBasic( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRename ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileRenameResolvingBasic' );
  let src1Path = test.context.pathFor( 'written/fileRenameResolvingBasic/src1' );
  let src2Path = test.context.pathFor( 'written/fileRenameResolvingBasic/src2' );
  let src3Path = test.context.pathFor( 'written/fileRenameResolvingBasic/src3' );
  let dstPath = test.context.pathFor( 'written/fileRenameResolvingBasic/dst' );

  /*
      src1 -> src2 -> src3
      resolvingSrcSoftLink : 0
      fileRename
        - link dst -> src2
        - delete src1

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 1
      fileRename
        - link dst -> src3
        - delete src1
        - delete src2

    src1 -> src2 -> src3
    resolvingSrcSoftLink : 2
    fileRename
      - copy src3 -> dst
      - delete src1
      - delete src2
      - delete src3
  */

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src2Path );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src3Path );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( src3Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src3Path );

  /*  */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, src3Path );
  provider.textLink( src1Path, src2Path );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src2Path );

  test.case = 'resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, src3Path );
  provider.textLink( src1Path, src2Path );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 1 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src3Path );

  test.case = 'resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, src3Path );
  provider.textLink( src1Path, src2Path );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 2 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( src3Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src3Path );

  provider.fieldPop( 'usingTextLink', 1 );
}

//

function fileRenameGlobal( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( provider instanceof _.FileProvider.System )
  {
    test.identical( 1, 1 )
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileRenameGlobal' );
  let srcPath = test.context.pathFor( 'written/fileRenameGlobal/src' );
  let dstPath = test.context.pathFor( 'written/fileRenameGlobal/dst' );

  var srcPathDefault = path.globalFromPreferred( srcPath );
  var dstPathDefault = path.globalFromPreferred( dstPath );

  var srcPathSecond = 'second://' + srcPath;
  var dstPathSecond = 'second://' + dstPath;

  var dstPathUnknown = 'unknown://' + dstPath;

  /* */

  test.open( 'with system' );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileRename( dstPathDefault, srcPathDefault );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), srcPath );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileRename( dstPathSecond, srcPathSecond );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), srcPath );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.fileRename( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.close( 'with system' );

  /* */

  test.open( 'without system' );

  context.system.providerUnregister( provider );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileRename( dstPathDefault, srcPathDefault );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), srcPath );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileRename( dstPathSecond, srcPathSecond );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), srcPath );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.fileRename( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  context.system.providerRegister( provider );

  test.close( 'without system' );
}

//

function fileRenameRelativeSoftLinking( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRename ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileRenameRelativeSoftLinking' );
  let src1Path = test.context.pathFor( 'written/fileRenameRelativeSoftLinking/src1' );
  let src2Path = test.context.pathFor( 'written/fileRenameRelativeSoftLinking/src2' );
  let src3Path = test.context.pathFor( 'written/fileRenameRelativeSoftLinking/src3' );
  let dstPath = test.context.pathFor( 'written/fileRenameRelativeSoftLinking/dst' );

  /*
    src1 -> ../src2
    fileRename dst src1
    resolvingSrcSoftLink : 0
    - link dst -> src1

    src1 -> ../src2
    fileRename dst src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 -> ../src2
    fileRename dst ../src1
    resolvingSrcSoftLink : 0
    - link dst -> ../src1

    src1 -> ../src2
    fileRename dst ../src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 as :
    - missing file
    - link

    src2 as :
    - terminal
    - intermediate link
    - missing

  */

  /*  */

  test.case = 'relative link to dir';
  provider.filesDelete( routinePath );
  provider.dirMake( src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.isDir( dstPath ) );
  test.identical( provider.dirRead( dstPath ), [] );

  /* src1 missing soft*/

  test.case = '../src1 is missing, allowingMissed:0';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileRename
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = '../src1 is missing, allowingMissed:1';
  provider.filesDelete( routinePath );
  provider.fileRename
  ({
    srcPath : '../src1',
    dstPath,
    resolvingSrcSoftLink : 0,
    resolvingSrcTextLink : 0,
    allowingMissed : 1
  });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /*  */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.isTerminal( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src2Path );

  /* */

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.isTerminal( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src2Path );

  /* missing absolute src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileRename
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileRename
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename
  ({
    srcPath : src1Path,
    dstPath,
    resolvingSrcSoftLink : 2,
    resolvingSrcTextLink : 0,
    rewriting : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /* missing relative src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileRename
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileRename
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename
  ({
    srcPath : '../src1',
    dstPath,
    resolvingSrcSoftLink : 2,
    resolvingSrcTextLink : 0,
    rewriting : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /* chain */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( src3Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src3Path );

  /*  */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( src3Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src3Path );
}

//

function fileRenameRelativeTextLinking( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRename ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileRenameRelativeTextLinking' );
  let src1Path = test.context.pathFor( 'written/fileRenameRelativeTextLinking/src1' );
  let src2Path = test.context.pathFor( 'written/fileRenameRelativeTextLinking/src2' );
  let src3Path = test.context.pathFor( 'written/fileRenameRelativeTextLinking/src3' );
  let dstPath = test.context.pathFor( 'written/fileRenameRelativeTextLinking/dst' );

  /*
    src1 -> ../src2
    fileRename dst src1
    resolvingSrcTextLink : 0
    - link dst -> src1

    src1 -> ../src2
    fileRename dst src1
    resolvingSrcTextLink : 1
    - link dst -> ../src2

    src1 -> ../src2
    fileRename dst ../src1
    resolvingSrcTextLink : 0
    - link dst -> ../src1

    src1 -> ../src2
    fileRename dst ../src1
    resolvingSrcTextLink : 1
    - link dst -> ../src2

    src1 as :
    - missing file
    - link

    src2 as :
    - terminal
    - intermediate link
    - missing

  */

  provider.fieldPush( 'usingTextLink', 1 )

  /*  */

  test.case = 'relative link to dir';
  provider.filesDelete( routinePath );
  provider.dirMake( src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 2 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.isDir( dstPath ) );
  test.identical( provider.dirRead( dstPath ), [] );

  /* src1 missing text*/

  test.case = '../src1 is missing, allowingMissed:0';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileRename
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = '../src1 is missing, allowingMissed:1';
  provider.filesDelete( routinePath );
  provider.fileRename
  ({
    srcPath : '../src1',
    dstPath,
    resolvingSrcSoftLink : 0,
    resolvingSrcTextLink : 0,
    allowingMissed : 1
  });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /*  */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 1 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 2 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.isTerminal( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src2Path );

  /* */

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 1 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 2 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.isTerminal( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src2Path );

  /* missing absolute src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileRename
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 1,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 1, allowingMissed : 1 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileRename
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 2,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename
  ({
    srcPath : src1Path,
    dstPath,
    resolvingSrcSoftLink : 0,
    resolvingSrcTextLink : 2,
    rewriting : 1,
    allowingMissed : 1
  });
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /* missing relative src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileRename
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 1,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 1, allowingMissed : 1 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileRename
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 2,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename
  ({
    srcPath : '../src1',
    dstPath,
    resolvingSrcSoftLink : 0,
    resolvingSrcTextLink : 2,
    rewriting : 1,
    allowingMissed : 1
  });
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /* chain */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 1 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 2 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( src3Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src3Path );

  /*  */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 1 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 2 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( src3Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src3Path );

  /*  */

  provider.fieldPop( 'usingTextLink', 1 )

}

//

function fileRenameHardLinkedSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopy ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  let routinePath = test.context.pathFor( 'written/fileRenameHardLinkedSync' );
  let srcPath = test.context.pathFor( 'written/fileRenameHardLinkedSync/src' );
  let dstPath = test.context.pathFor( 'written/fileRenameHardLinkedSync/dst' );

  /* - */

  test.case = 'src is a terminal, dst has 5 hardlinks, breakingDstHardLink=0'
  provider.filesDelete( routinePath )
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  makeHardLinksToPath( dstPath, 5 );
  test.identical( provider.fileRead( dstPath ), dstPath );
  provider.fileRename({ dstPath, srcPath, rewriting : 1, breakingDstHardLink : 0 });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var nlink = provider.statResolvedRead( dstPath).nlink;
  test.identical( Number( nlink ), 6 );
  test.identical( provider.fileRead( dstPath ), srcPath );

  /* - */

  test.case = 'src is a terminal, dst has 5 hardlinks, breakingDstHardLink=1'
  provider.filesDelete( routinePath )
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  makeHardLinksToPath( dstPath, 5 );
  test.identical( provider.fileRead( dstPath ), dstPath );
  provider.fileRename({ dstPath, srcPath, rewriting : 1, breakingDstHardLink : 1 });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var nlink = provider.statResolvedRead( dstPath).nlink;
  test.identical( Number( nlink ), 1 );
  test.identical( provider.fileRead( dstPath ), srcPath );

  /* - */

  test.case = 'src and dst are not linked together, breakingDstHardLink=0'
  provider.filesDelete( routinePath )
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  makeHardLinksToPath( srcPath, 3 );
  makeHardLinksToPath( dstPath, 5 );
  test.identical( provider.fileRead( dstPath ), dstPath );
  provider.fileRename({ dstPath, srcPath, rewriting : 1, breakingDstHardLink : 0 });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var nlink = provider.statResolvedRead( dstPath).nlink;
  test.identical( Number( nlink ), 6 );
  test.identical( provider.fileRead( dstPath ), srcPath );

  /* - */

  test.case = 'src and dst are linked together, breakingDstHardLink=0'
  provider.filesDelete( routinePath )
  provider.fileWrite( srcPath, srcPath );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
  provider.fileRename({ dstPath, srcPath, rewriting : 1, breakingDstHardLink : 0 });
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), false );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var nlink = provider.statResolvedRead( dstPath).nlink;
  test.identical( Number( nlink ), 1 );
  test.identical( provider.fileRead( dstPath ), srcPath );


  /* - */

  test.case = 'src and dst are linked together, breakingDstHardLink=0'
  provider.filesDelete( routinePath )
  provider.fileWrite( srcPath, 'data' );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
  provider.fileRename({ dstPath, srcPath, rewriting : 1, breakingDstHardLink : 1 });
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), false );
  test.is( !provider.fileExists( srcPath ) );
  test.identical( provider.fileRead( dstPath ), 'data' );

  /* - */

  test.case = 'src and dst are not linked together, breakingDstHardLink=1'
  provider.filesDelete( routinePath )
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  makeHardLinksToPath( srcPath, 3 );
  makeHardLinksToPath( dstPath, 4 );
  test.identical( provider.fileRead( dstPath ), dstPath );
  provider.fileRename({ dstPath, srcPath, rewriting : 1, breakingDstHardLink : 1 });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var nlink = provider.statResolvedRead( dstPath ).nlink;
  test.identical( Number( nlink ), 1 );
  test.identical( provider.fileRead( dstPath ), srcPath );

  /* - */

  function makeHardLinksToPath( filePath, amount )
  {
    let routinePath = path.join( context.provider.path.dir( filePath ), _.idWithDateAndTime() );
    provider.dirMake( routinePath )
    for( var i = 0; i < amount; i++ )
    provider.hardLink( path.join( routinePath, 'file' + i ), filePath );
  }

}

//

function fileRenameHardLinkedAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRenameAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  let routinePath = test.context.pathFor( 'written/fileRenameHardLinkedAsync' );
  let srcPath = test.context.pathFor( 'written/fileRenameHardLinkedAsync/src' );
  let dstPath = test.context.pathFor( 'written/fileRenameHardLinkedAsync/dst' );

  let ready = new _.Consequence().take( null )

  /* - */

  .then( () =>
  {
    test.case = 'src is a terminal, dst has 5 hardlinks, breakingDstHardLink=0'
    provider.filesDelete( routinePath )
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( dstPath, dstPath );
    makeHardLinksToPath( dstPath, 5 );
    test.identical( provider.fileRead( dstPath ), dstPath );
    return provider.fileRename({ dstPath, srcPath, rewriting : 1, breakingDstHardLink : 0, sync : 0 });
  })
  .then( () =>
  {
    test.is( !provider.fileExists( srcPath ) );
    test.is( provider.fileExists( dstPath ) );
    var nlink = provider.statResolvedRead( dstPath).nlink;
    test.identical( Number( nlink ), 6 );
    test.identical( provider.fileRead( dstPath ), srcPath );
    return null;
  })

  /* - */

  .then( () =>
  {
    test.case = 'src is a terminal, dst has 5 hardlinks, breakingDstHardLink=1'
    provider.filesDelete( routinePath )
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( dstPath, dstPath );
    makeHardLinksToPath( dstPath, 5 );
    test.identical( provider.fileRead( dstPath ), dstPath );
    return provider.fileRename({ dstPath, srcPath, rewriting : 1, breakingDstHardLink : 1, sync : 0 });
  })
  .then( () =>
  {
    test.is( !provider.fileExists( srcPath ) );
    test.is( provider.fileExists( dstPath ) );
    var nlink = provider.statResolvedRead( dstPath).nlink;
    test.identical( Number( nlink ), 1 );
    test.identical( provider.fileRead( dstPath ), srcPath );
    return null;
  })

  /* - */

  .then( () =>
  {
    test.case = 'src and dst are not linked together, breakingDstHardLink=0'
    provider.filesDelete( routinePath )
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( dstPath, dstPath );
    makeHardLinksToPath( srcPath, 3 );
    makeHardLinksToPath( dstPath, 5 );
    test.identical( provider.fileRead( dstPath ), dstPath );
    return provider.fileRename({ dstPath, srcPath, rewriting : 1, breakingDstHardLink : 0, sync : 0 });
  })
  .then( () =>
  {
    test.is( !provider.fileExists( srcPath ) );
    test.is( provider.fileExists( dstPath ) );
    var nlink = provider.statResolvedRead( dstPath).nlink;
    test.identical( Number( nlink ), 6 );
    test.identical( provider.fileRead( dstPath ), srcPath );
    return null;
  })

  /* - */

  .then( () =>
  {
    test.case = 'src and dst are linked together, breakingDstHardLink=0'
    provider.filesDelete( routinePath )
    provider.fileWrite( srcPath, srcPath );
    provider.hardLink( dstPath, srcPath );
    if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
    else
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
    return provider.fileRename({ dstPath, srcPath, rewriting : 1, breakingDstHardLink : 0, sync : 0 });
  })
  .then( () =>
  {
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), false );
    test.is( !provider.fileExists( srcPath ) );
    test.is( provider.fileExists( dstPath ) );
    var nlink = provider.statResolvedRead( dstPath).nlink;
    test.identical( Number( nlink ), 1 );
    test.identical( provider.fileRead( dstPath ), srcPath );
    return null;
  })

  /* - */

  .then( () =>
  {
    test.case = 'src and dst are linked together, breakingDstHardLink=0'
    provider.filesDelete( routinePath )
    provider.fileWrite( srcPath, 'data' );
    provider.hardLink( dstPath, srcPath );
    if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
    else
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
    return provider.fileRename({ dstPath, srcPath, rewriting : 1, breakingDstHardLink : 1, sync : 0 });
  })
  .then( () =>
  {
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), false );
    test.is( !provider.fileExists( srcPath ) );
    test.identical( provider.fileRead( dstPath ), 'data' );
    return null;
  })

  /* - */

  .then( () =>
  {
    test.case = 'src and dst are not linked together, breakingDstHardLink=1'
    provider.filesDelete( routinePath )
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( dstPath, dstPath );
    makeHardLinksToPath( srcPath, 3 );
    makeHardLinksToPath( dstPath, 4 );
    test.identical( provider.fileRead( dstPath ), dstPath );
    return provider.fileRename({ dstPath, srcPath, rewriting : 1, breakingDstHardLink : 1, sync : 0 });
  })
  .then( () =>
  {
    test.is( !provider.fileExists( srcPath ) );
    test.is( provider.fileExists( dstPath ) );
    var nlink = provider.statResolvedRead( dstPath ).nlink;
    test.identical( Number( nlink ), 1 );
    test.identical( provider.fileRead( dstPath ), srcPath );
    return null;
  })

  /* - */

  return ready;

  /* - */

  function makeHardLinksToPath( filePath, amount )
  {
    let routinePath = path.join( context.provider.path.dir( filePath ), _.idWithDateAndTime() );
    provider.dirMake( routinePath )
    for( var i = 0; i < amount; i++ )
    provider.hardLink( path.join( routinePath, 'file' + i ), filePath );
  }


}

//

function fileDeleteSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileDeleteAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var isExtract = false;

  if( context.providerIsInstanceOf( _.FileProvider.Extract ) )
  isExtract = true;

  var routinePath = test.context.pathFor( 'written/fileDelete' );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  /* - */

  test.case = 'removing not existing path';

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.fileDelete
    ({
      filePath : test.context.pathFor( 'not_existing_path' ),
      sync : 1,
      throwing : 1
    })
  });

  /**/

  test.mustNotThrowError( function()
  {
    var got = provider.fileDelete
    ({
      filePath : test.context.pathFor( 'not_existing_path' ),
      sync : 1,
      throwing : 0
    });
    test.identical( got, null );
  });

  /* - */

  test.case = 'removing existing file';
  var filePath = test.context.pathFor( 'written/fileDelete/file.txt');

  /**/

  provider.fileWrite( filePath, ' ' );
  provider.fileDelete
  ({
    filePath,
    sync : 1,
    throwing : 0
  });
  var stat = provider.statResolvedRead( filePath );
  test.identical( stat, null );

  /**/

  provider.fileWrite( filePath, ' ' );
  provider.fileDelete
  ({
    filePath,
    sync : 1,
    throwing : 1
  });
  var stat = provider.statResolvedRead( filePath );
  test.identical( stat, null );

  /* - */

  test.case = 'removing empty folder';
  var filePath = test.context.pathFor( 'written/fileDelete/folder');

  /**/

  provider.dirMake( filePath );
  provider.fileDelete
  ({
    filePath,
    sync : 1,
    throwing : 0
  });
  var stat = provider.statResolvedRead( filePath );
  test.identical( stat, null );

  /**/

  provider.dirMake( filePath );
  provider.fileDelete
  ({
    filePath,
    sync : 1,
    throwing : 1
  });
  var stat = provider.statResolvedRead( filePath );
  test.identical( stat, null );

  /* - */

  test.case = 'try removing folder with file';
  var filePath = test.context.pathFor( 'written/fileDelete/folder/file.txt');
  var folder = context.provider.path.dir( filePath );

  /**/

  provider.fileWrite( filePath, ' ' );
  test.shouldThrowErrorSync( function()
  {
    provider.fileDelete
    ({
      filePath : folder,
      sync : 1,
      throwing : 1
    })
  });
  var stat = provider.statResolvedRead( folder );
  test.is( !!stat );

  /**/

  test.mustNotThrowError( () =>
  {
    provider.fileDelete
    ({
      filePath : folder,
      sync : 1,
      throwing : 0
    });
  })

  var stat = provider.statResolvedRead( folder );
  test.is( !!stat );

  if( provider.constructor.name === 'wFileProviderExtract' )
  {
    test.case = 'try to remove filesTree';

    /* - */

    // test.shouldThrowErrorSync( function()
    // {
    //   provider.fileDelete
    //   ({
    //     filePath : '.',
    //     sync : 1,
    //     throwing : 1
    //   });
    // })

    /**/

    test.shouldThrowErrorSync( function()
    {
      provider.filesTree = {};
      provider.fileDelete
      ({
        filePath : '/',
        sync : 1,
        throwing : 1
      });
    })

    /**/

    // test.mustNotThrowError( function()
    // {
    //   var got = provider.fileDelete
    //   ({
    //     filePath : '.',
    //     sync : 1,
    //     throwing : 0
    //   });
    //   test.identical( got, null );
    // })
    // var stat = provider.statResolvedRead( '.' );
    // test.is( !!stat );

    /**/

    test.shouldThrowErrorSync( function()
    {
      provider.filesTree = {};
      provider.fileDelete
      ({
        filePath : '/',
        sync : 1,
        throwing : 1
      });
    })
    var stat1 = provider.statResolvedRead( '/' );
    test.is( !!stat1 );
  }

  /* - */

  var filePath = path.join( routinePath, 'file' );

  /* - */

  // test.case = 'delete soft link, resolvingHardLink 1';
  // provider.filesDelete( routinePath );
  // provider.fieldPush( 'resolvingHardLink', 1 );
  // var dst = path.join( routinePath, 'link' );
  // provider.fileWrite( filePath, ' ');
  // provider.hardLink( dst, filePath );
  // provider.fileDelete( dst )
  // var stat = provider.statResolvedRead( dst );
  // test.identical( stat, null );
  // var stat = provider.statResolvedRead( filePath );
  // test.is( !!stat );
  // provider.fieldPop( 'resolvingHardLink', 1 );

  // test.case = 'delete soft link, resolvingHardLink 0';
  // provider.filesDelete( routinePath );
  // provider.fieldPush( 'resolvingHardLink', 0 );
  // var dst = path.join( routinePath, 'link' );
  // provider.fileWrite( filePath, ' ');
  // provider.hardLink( dst, filePath );
  // provider.fileDelete( dst )
  // var stat = provider.statResolvedRead( dst );
  // test.identical( stat, null );
  // var stat = provider.statResolvedRead( filePath );
  // test.is( !!stat );
  // provider.fieldPop( 'resolvingHardLink', 0 );

  /* - */

  if( !test.context.softLinkIsSupported() )
  return;

  test.case = 'delete soft link, resolvingSoftLink 1';
  provider.fieldPush( 'resolvingSoftLink', 1 );
  var dst = path.join( routinePath, 'link' );
  provider.fileWrite( filePath, ' ');
  provider.softLink( dst, filePath );
  provider.fileDelete( dst )
  var stat = provider.statResolvedRead( dst );
  test.identical( stat, null );
  var stat = provider.statResolvedRead( filePath );
  test.is( !!stat );
  provider.fieldPop( 'resolvingSoftLink', 1 );

  test.case = 'delete soft link, resolvingSoftLink 0';
  provider.filesDelete( routinePath );
  provider.fieldPush( 'resolvingSoftLink', 0 );
  var dst = path.join( routinePath, 'link' );
  provider.fileWrite( filePath, ' ');
  provider.softLink( dst, filePath );
  provider.fileDelete( dst )
  var stat = provider.statResolvedRead( dst );
  test.identical( stat, null );
  var stat = provider.statResolvedRead( filePath );
  test.is( !!stat );
  provider.fieldPop( 'resolvingSoftLink', 0 );
}

//

function fileDeleteActSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileDeleteAct ) )
  {
    test.case = 'fileDeleteAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  var mp = _.routineJoin( test.context, test.context.pathFor );
  var routinePath = mp( 'fileDeleteActSync' );

  /* - */

  test.case = 'basic usage';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    filePath : srcPath,
    sync : 1
  }
  var expected = _.mapExtend( null, o );
  provider.fileDeleteAct( o );
  test.identical( o, expected );
  var stat = provider.statResolvedRead( srcPath );
  test.is( !stat );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'no src';
  var srcPath = path.join( routinePath, 'src' );
  var o =
  {
    filePath : srcPath,
    sync : 1
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileDeleteAct( o );
  })
  var stat = provider.statResolvedRead( srcPath );
  test.is( !stat );

  /* - */

  test.case = 'src is empty dir';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath, 'src' );
  provider.dirMake( srcPath );
  var o =
  {
    filePath : srcPath,
    sync : 1
  }
  provider.fileDeleteAct( o );
  var stat = provider.statResolvedRead( srcPath );
  test.is( !stat );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'src is empty dir';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    filePath : routinePath,
    sync : 1
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileDeleteAct( o );
  })
  var stat = provider.statResolvedRead( routinePath );
  test.is( !!stat );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'should path nativize all paths in options map if needed by its own means';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    filePath : srcPath,
    sync : 1
  }
  var expected = _.mapExtend( null, o );
  provider.fileDeleteAct( o );
  test.identical( o, expected );
  var stat = provider.statResolvedRead( srcPath );
  test.is( !stat );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    filePath : srcPath,
    sync : 1
  }
  var expected = _.mapOwnKeys( o );
  provider.fileDeleteAct( o );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  var stat = provider.statResolvedRead( srcPath );
  test.is( !stat );
  provider.filesDelete( routinePath );

  /* - */

  if( !Config.debug )
  return;

  test.case = 'should assert that path is absolute';
  var srcPath = './src';

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileDeleteAct
    ({
      filePath : srcPath,
      sync : 1
    });
  })

  /* - */

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath, 'src' );

  /* sync option is missed */

  var o =
  {
    filePath : srcPath,
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileDeleteAct( o );
  });

  /* redundant option */

  var o =
  {
    filePath : srcPath,
    redundant : 'redundant'
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileDeleteAct( o );
  });

  /* - */

  if( !context.providerIsInstanceOf( _.FileProvider.System ) )
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.case = 'should expect normalized path, but not nativized';
    var srcPath2 = path.join( routinePath, 'src' );
    provider.fileWrite( srcPath2, srcPath2 );
    var o2 =
    {
      filePath : srcPath2,
      sync : 1
    }
    var originalPath = provider.path.preferredFromGlobal( o2.filePath );
    o2.filePath = provider.path.nativize( o2.filePath );
    if( o2.filePath !== originalPath )
    {
      test.shouldThrowErrorOfAnyKind( () =>
      {
        provider.fileDeleteAct( o2 );
      })
    }
    else
    {
      test.mustNotThrowError( () =>
      {
        provider.fileDeleteAct( o2 );
      })
    }
    provider.filesDelete( routinePath );
  }

  /* - */

  test.case = 'should expect ready options map, no complex arguments preprocessing';
  var srcPath = path.join( routinePath, 'src' );
  var o =
  {
    filePath : [ srcPath ],
    sync : 1
  }
  var expected = _.mapExtend( null, o );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileDeleteAct( o );
  })
  test.identical( o.filePath, expected.filePath );
}

//

function fileDeleteAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileDeleteAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var isExtract = false;

  if( context.providerIsInstanceOf( _.FileProvider.Extract ) )
  isExtract = true;

  var filePath, folder;

  var routinePath = test.context.pathFor( 'written/fileDeleteAsync' );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var consequence = new _.Consequence().take( null );

  consequence
  .ifNoErrorThen( function( arg )
  {
    test.case = 'removing not existing path';
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileDelete
    ({
      filePath : test.context.pathFor( 'not_existing_path' ),
      sync : 0,
      throwing : 1
    });

    return test.shouldThrowErrorAsync( con );
  })

  /**/

  .finally( function()
  {
    var con = provider.fileDelete
    ({
      filePath : test.context.pathFor( 'not_existing_path' ),
      sync : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( ( got ) => test.identical( got, null ) );

  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'removing file';
    filePath = test.context.pathFor( 'written/fileDeleteAsync/file.txt');
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath, ' ' );
    var con = provider.fileDelete
    ({
      filePath,
      sync : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var stat = provider.statResolvedRead( filePath );
      test.identical( stat, null );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath, ' ' );
    var con = provider.fileDelete
    ({
      filePath,
      sync : 0,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var stat = provider.statResolvedRead( filePath );
      test.identical( stat, null );
      return null;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'removing existing empty folder';
    filePath = test.context.pathFor( 'written/fileDeleteAsync/folder');
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.dirMake( filePath );
    var con = provider.fileDelete
    ({
      filePath,
      sync : 0,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var stat = provider.statResolvedRead( filePath );
      test.identical( stat, null );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.dirMake( filePath );
    var con = provider.fileDelete
    ({
      filePath,
      sync : 0,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var stat = provider.statResolvedRead( filePath );
      test.identical( stat, null );
      return null;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'removing existing folder with file';
    filePath = test.context.pathFor( 'written/fileDeleteAsync/folder/file.txt');
    return null;

  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    folder = context.provider.path.dir( filePath );
    provider.fileWrite( filePath, ' ' );
    var con = provider.fileDelete
    ({
      filePath : folder,
      sync : 0,
      throwing : 1
    });

    return test.shouldThrowErrorAsync( con )
    .finally( function()
    {
      var stat = provider.statResolvedRead( folder );
      test.is( !!stat );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileDelete
    ({
      filePath : folder,
      sync : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      var stat = provider.statResolvedRead( folder );
      test.is( !!stat );
      test.identical( got, null )
      return got;
    });
  })
  .ifNoErrorThen( function( arg )
  {
    if( provider.constructor.name !== 'wFileProviderExtract' )
    return null;

    test.case = 'try to remove filesTree';

    /* - */

    return test.shouldThrowErrorOfAnyKind( function()
    {
      return provider.fileDelete
      ({
        filePath : '.',
        sync : 0,
        throwing : 1
      });
    })
    .finally( function()
    {
      return test.shouldThrowErrorAsync( function()
      {
        provider.filesTree = {};
        return provider.fileDelete
        ({
          filePath : '/',
          sync : 0,
          throwing : 1
        });
      })
    })
    .finally( function()
    {
      return test.shouldThrowErrorOfAnyKind( function()
      {
        return provider.fileDelete
        ({
          filePath : '.',
          sync : 0,
          throwing : 1
        });
      })
    })
    .finally( function()
    {
      provider.filesTree = {};
      let con = provider.fileDelete
      ({
        filePath : '/',
        sync : 0,
        throwing : 1
      });
      return test.shouldThrowErrorAsync( con );
    })
  })
  .finally( () =>
  {
    filePath = path.join( routinePath, 'file' );
    return null;
  })
  // .ifNoErrorThen( ( arg ) =>
  // {
  //   test.case = 'delete hard link, resolvingHardLink 1';
  //   provider.filesDelete( routinePath );
  //   provider.fieldPush( 'resolvingHardLink', 1 );
  //   var dst = path.join( routinePath, 'link' );
  //   provider.fileWrite( filePath, ' ');
  //   provider.hardLink( dst, filePath );
  //   return provider.fileDelete
  //   ({
  //     filePath : dst,
  //     sync : 0,
  //     throwing : 1
  //   })
  //   .ifNoErrorThen( ( arg ) =>
  //   {
  //     var stat = provider.statResolvedRead( dst );
  //     test.identical( stat, null );
  //     var stat = provider.statResolvedRead( filePath );
  //     test.is( !!stat );
  //     provider.fieldPop( 'resolvingHardLink', 1 );
  //   })
  // })
  // .ifNoErrorThen( ( arg ) =>
  // {
  //   test.case = 'delete hard link, resolvingHardLink 0';
  //   provider.filesDelete( routinePath );
  //   provider.fieldPush( 'resolvingHardLink', 0 );
  //   var dst = path.join( routinePath, 'link' );
  //   provider.fileWrite( filePath, ' ');
  //   provider.hardLink( dst, filePath );
  //   return provider.fileDelete
  //   ({
  //     filePath : dst,
  //     sync : 0,
  //     throwing : 1
  //   })
  //   .ifNoErrorThen( ( arg ) =>
  //   {
  //     var stat = provider.statResolvedRead( dst );
  //     test.identical( stat, null );
  //     var stat = provider.statResolvedRead( filePath );
  //     test.is( !!stat );
  //     provider.fieldPop( 'resolvingHardLink', 0 );
  //   })
  // });

  if( !test.context.softLinkIsSupported() )
  return consequence;

  consequence.ifNoErrorThen( ( arg ) =>
  {
    var filePath = path.join( routinePath, 'file' );
    test.case = 'delete soft link, resolvingSoftLink 1';
    provider.fieldPush( 'resolvingSoftLink', 1 );
    var dst = path.join( routinePath, 'link' );
    provider.fileWrite( filePath, ' ');
    provider.softLink( dst, filePath );
    return provider.fileDelete
    ({
      filePath : dst,
      sync : 0,
      throwing : 1
    })
    .ifNoErrorThen( ( arg ) =>
    {
      var stat = provider.statResolvedRead( dst );
      test.identical( stat, null );
      var stat = provider.statResolvedRead( filePath );
      test.is( !!stat );
      provider.fieldPop( 'resolvingSoftLink', 1 );
      return null;
    })

  })
  .ifNoErrorThen( ( arg ) =>
  {
    test.case = 'delete soft link, resolvingSoftLink 0';
    provider.filesDelete( routinePath );
    provider.fieldPush( 'resolvingSoftLink', 0 );
    var dst = path.join( routinePath, 'link' );
    provider.fileWrite( filePath, ' ');
    provider.softLink( dst, filePath );
    return provider.fileDelete
    ({
      filePath : dst,
      sync : 0,
      throwing : 1
    })
    .ifNoErrorThen( ( arg ) =>
    {
      var stat = provider.statResolvedRead( dst );
      test.identical( stat, null );
      var stat = provider.statResolvedRead( filePath );
      test.is( !!stat );
      provider.fieldPop( 'resolvingSoftLink', 0 );
      return null;
    })
  })

  return consequence;

}

//

// qqq Vova:investigate why fileDeleteLocked fails when executed with other tests

function fileDeleteLocked( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let skip = !context.providerIsInstanceOf( _.FileProvider.HardDrive ) || context.providerIsInstanceOf( _.FileProvider.System );

  if( skip )
  {
    test.identical( 1, 1 );
    return;
  }

  if( process.platform !== 'win32' )
  {
    test.identical( 1, 1 );
    return;
  }

  /* - */

  let fs = require( 'fs' );
  let routinePath = context.pathFor( 'write/fileDeleteLocked' );
  let terminalPath = path.join( routinePath, 'terminal' );

  test.case = 'try to delete opened file, using fs.openSync';
  provider.fileWrite( terminalPath, terminalPath );
  var fd = fs.openSync( provider.path.nativize( terminalPath ), 'r' );
  var got = fs.unlinkSync( path.nativize( terminalPath ) );
  test.will = 'no errors from fs module';
  test.identical( got, undefined );
  test.will = 'test dir can`t be deleted because is not empty';
  test.shouldThrowErrorSync( () => fs.rmdirSync( path.nativize( routinePath ) ) );
  test.will = 'terminal still exists';
  test.is( provider.fileExists( terminalPath ) );
  test.will = 'can`t be read';
  test.shouldThrowErrorSync( () => provider.fileRead( terminalPath ) );
  test.will = 'can`t be written';
  test.shouldThrowErrorSync( () => provider.fileWrite( terminalPath, terminalPath ) );
  fs.closeSync( fd );
  test.will = 'terminal is closed and removed';
  test.is( !provider.fileExists( terminalPath ) );

  /* - */

  test.case = 'try to delete opened file, using fileDelete';
  provider.fileWrite( terminalPath, terminalPath );
  var fd = fs.openSync( provider.path.nativize( terminalPath ), 'r' );
  var got = provider.fileDelete( terminalPath );
  test.will = 'terminal should be removed';
  test.is( !provider.fileExists( terminalPath ) );
  var read = provider.dirRead( routinePath );
  test.identical( read, [] );
  provider.fileDelete( routinePath );
  test.is( !provider.fileExists( routinePath ) );
  test.will = 'file is still available through fd';
  var buffer = BufferNode.alloc( 50 );
  fs.readSync( fd, buffer, 0, buffer.byteLength );
  var got =  buffer.toString();
  test.is( got.length > 0 )
  test.is( _.strHas( terminalPath, got ) )
  fs.closeSync( fd );
  test.will = 'terminal is closed and removed';
  test.is( !provider.fileExists( terminalPath ) );

  /* - */

  // for( let i = 0; i < 1000; i++ )
  // {
  //   provider.fileWrite( terminalPath, terminalPath );
  //   var fd = fs.openSync( provider.path.nativize( terminalPath ), 'r' );
  //   provider.fileDelete( terminalPath );
  //   test.is( !provider.fileExists( terminalPath ) );
  //   fs.closeSync( fd );
  // }

  /* - */

  test.case = 'try to delete opened file using fs.createReadStream';
  provider.fileWrite( terminalPath, terminalPath );
  var stream = provider.streamRead( terminalPath );
  _.time.out( 100 ).deasync();
  var got = fs.unlinkSync( path.nativize( terminalPath ) );
  test.will = 'no errors from fs module';
  test.identical( got, undefined );
  test.will = 'test dir can`t be deleted because is not empty';
  test.shouldThrowErrorSync( () => fs.rmdirSync( path.nativize( routinePath ) ) );
  test.will = 'terminal still exists';
  test.is( provider.fileExists( terminalPath ) );
  test.will = 'can`t be read';
  test.shouldThrowErrorSync( () => provider.fileRead( terminalPath ) );
  test.will = 'can`t be written';
  test.shouldThrowErrorSync( () => provider.fileWrite( terminalPath, terminalPath ) );
  stream.close();
  return _.time.out( 1000, () =>
  {
    test.will = 'terminal is closed and removed';
    test.is( stream.closed );
    test.is( !provider.fileExists( terminalPath ) );
  })

}

//

function fileDeletePathEscaped( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;
  let providerEffective = context.providerEffective || context.provider;

  if( !_.routineIs( provider.fileDeleteAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let isSystem = provider instanceof _.FileProvider.System;

  var routinePath = test.context.pathFor( 'written/fileDeletePathEscaped' );
  var routinePathLocal = providerEffective.path.preferredFromGlobal( routinePath )
  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  /* */

  test.case = 'filename contains @, global path'
  var filePath = provider.path.join( routinePath, '@file' );
  var localPath = providerEffective.path.preferredFromGlobal( filePath );
  if( !providerEffective.pathAllowedAct( localPath ) )
  test.shouldThrowErrorSync( () =>
  {
    provider.fileWrite( filePath, filePath );
  })
  else
  {
    provider.fileWrite( filePath, filePath );
    provider.fileDelete( filePath );
  }
  test.is( !provider.fileExists( filePath ) );

  /* */

  test.case = 'filename contains @, local path'
  var filePath = provider.path.join( routinePath, '@file' );
  var localPath = providerEffective.path.preferredFromGlobal( filePath );
  if( !providerEffective.pathAllowedAct( localPath ) )
  test.shouldThrowErrorSync( () =>
  {
    provider.fileWrite( filePath, filePath );
  })
  else
  {
    provider.fileWrite( filePath, filePath );
    provider.fileDelete( providerEffective.path.preferredFromGlobal( filePath ) );
  }
  test.is( !provider.fileExists( filePath ) );

  /* */

  test.case = 'filename contains #, global path'
  var filePath = provider.path.join( routinePath, isSystem ? '"#file"' : '#file' );
  var localPath = providerEffective.path.join( routinePathLocal, '#file' );
  if( !providerEffective.pathAllowedAct( localPath ) )
  {
    provider.fileWrite( filePath, filePath );
  }
  else
  {
    provider.fileWrite( filePath, filePath );
    provider.fileDelete( filePath );
  }

  test.is( !provider.fileExists( filePath ) );

  /* */

  test.case = 'filename contains #, local path'
  var filePath = provider.path.join( routinePath, isSystem ? '"#file"' : '#file' );
  var localPath = providerEffective.path.join( routinePathLocal, '#file' );
  if( !providerEffective.pathAllowedAct( localPath ) )
  test.shouldThrowErrorSync( () =>
  {
    provider.fileWrite( filePath, filePath );
  })
  else
  {
    provider.fileWrite( filePath, filePath );
    provider.fileDelete( providerEffective.path.preferredFromGlobal( filePath ) );
  }
  test.is( !provider.fileExists( filePath ) );

  /* */

  test.case = 'filename contains ?, global path'
  var filePath = provider.path.join( routinePath, isSystem ? '"?file=a"' : '?file=a' );
  var localPath = providerEffective.path.join( routinePathLocal, '?file=a' );
  if( !providerEffective.pathAllowedAct( localPath ) )
  test.shouldThrowErrorSync( () =>
  {
    provider.fileWrite( filePath, filePath );
  })
  else
  {
    provider.fileWrite( filePath, filePath );
    provider.fileDelete( filePath );
  }
  test.is( !provider.fileExists( filePath ) );

  /* */

  test.case = 'filename contains ?, local path'
  var filePath = provider.path.join( routinePath, isSystem ? '"?file=a"' : '?file=a' );
  var localPath = providerEffective.path.join( routinePathLocal, '?file=a' );
  if( !providerEffective.pathAllowedAct( localPath ) )
  test.shouldThrowErrorSync( () =>
  {
    provider.fileWrite( filePath, filePath );
  })
  else
  {
    provider.fileWrite( filePath, filePath );
    provider.fileDelete( providerEffective.path.preferredFromGlobal( filePath ) );
  }
  test.is( !provider.fileExists( filePath ) );
}

//

function fileDeletePerfomance( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;
  let routinePath = context.pathFor( 'write/fileDeletePerfomance' );
  let files = 1;

  var data = _.strDup( 'terminal', 1000000 );
  data = _.strDup( data, 1000 );
  var filePaths = [];

  for( let i = 0; i < files; i++ )
  {
    let filePath = path.join( routinePath, 'terminal' + i );
    filePaths.push( filePath );
    provider.fileWrite( filePath, data )
  }

  var t = _.time.now();
  for( let i = 0; i < files; i++ )
  provider.fileDeleteAct({ filePath : filePaths[ i ], sync : 1 });
  var spent = _.time.spent( t );
  console.log( spent, 'for', files, 'files' );

}

fileDeletePerfomance.experimental = 1;

//

function statResolvedReadSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.statReadAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var routinePath = test.context.pathFor( 'read/statResolvedRead' );
  var filePath, expected;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  /* - */

  filePath = test.context.pathFor( 'read/statResolvedRead/src.txt' );
  provider.fileWrite( filePath, 'Excepteur sint occaecat cupidatat non proident' );
  test.case = 'synchronous file stat default options';
  expected = 46;

  /**/

  var got = provider.statResolvedRead( filePath );
  if( _.bigIntIs( got.size ) )
  expected = BigInt( expected );
  test.identical( got.size, expected );

  /**/

  var got = provider.statResolvedRead
  ({
    sync : 1,
    filePath,
    throwing : 1
  });
  if( _.bigIntIs( got.size ) )
  expected = BigInt( expected );
  test.identical( got.size, expected );

  /* - */

  test.case = 'invalid path';
  filePath = test.context.pathFor( '///bad path///test.txt' );

  /**/

  var got = provider.statResolvedRead
  ({
    sync : 1,
    filePath,
    throwing : 0
  });
  var expected = null;
  test.identical( got, expected );

  /**/

  test.shouldThrowErrorSync( function()
  {
    var got = provider.statResolvedRead
    ({
      sync : 1,
      filePath,
      throwing : 1
    });
  });
}

function fileLockWaitingSharingSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileLockAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileLockWaitingSharingSync' );
  let filePath = path.join( routinePath, 'terminal' );

  /* */

  test.case = 'trivial'
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 1,
    timeOut : 5000,
    sharing : 'process',
    waiting : 1
  });
  test.identical( got, true );
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileUnlock( filePath );
  test.is( !provider.fileIsLocked( filePath ) );

  /* - */

  test.case = 'fileFile is missing'
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileLock
    ({
      filePath,
      sync : 1,
      throwing : 1,
      timeOut : 5000,
      sharing : 'process',
      waiting : 1
    });
  });

  /* - */

  test.case = 'fileFile is missing, throwing off'
  provider.filesDelete( routinePath );
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 0,
    timeOut : 5000,
    sharing : 'process',
    waiting : 1
  });
  test.identical( got, null );

  /* - */

  test.case = 'try to lock file for second time';
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 1,
    timeOut : 5000,
    sharing : 'process',
    waiting : 1
  });
  test.identical( got, true );
  test.is( provider.fileIsLocked( filePath ) );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileLock
    ({
      filePath,
      sync : 1,
      throwing : 1,
      timeOut : 5000,
      sharing : 'process',
      waiting : 1
    });
  })
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileUnlock( filePath );
  test.is( !provider.fileIsLocked( filePath ) );


  /* - */

  test.case = 'try to lock file for second time, throwing off';
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 0,
    timeOut : 5000,
    sharing : 'process',
    waiting : 1
  });
  test.identical( got, true );
  test.is( provider.fileIsLocked( filePath ) );
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 0,
    timeOut : 5000,
    sharing : 'process',
    waiting : 1
  });
  test.identical( got, null );
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileUnlock( filePath );
  test.is( !provider.fileIsLocked( filePath ) );
}

//

function fileLockWaitingNotSharingSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileLockAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileLockWaitingNotSharingSync' );
  let filePath = path.join( routinePath, 'terminal' );

  /* */

  test.case = 'trivial'
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 1,
    timeOut : 5000,
    sharing : 0,
    waiting : 1
  });
  test.identical( got, true );
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileUnlock( filePath );
  test.is( !provider.fileIsLocked( filePath ) );

  /* - */

  test.case = 'fileFile is missing'
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileLock
    ({
      filePath,
      sync : 1,
      throwing : 1,
      timeOut : 5000,
      sharing : 0,
      waiting : 1
    });
  });

  /* - */

  test.case = 'fileFile is missing, throwing off'
  provider.filesDelete( routinePath );
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 0,
    timeOut : 5000,
    sharing : 0,
    waiting : 1
  });
  test.identical( got, null );

  /* - */

  test.case = 'try to lock file for second time';
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 1,
    timeOut : 5000,
    sharing : 0,
    waiting : 1
  });
  test.identical( got, true );
  test.is( provider.fileIsLocked( filePath ) );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileLock
    ({
      filePath,
      sync : 1,
      throwing : 1,
      timeOut : 5000,
      sharing : 0,
      waiting : 1
    });
  })
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileUnlock( filePath );
  test.is( !provider.fileIsLocked( filePath ) );


  /* - */

  test.case = 'try to lock file for second time, throwing off';
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 0,
    timeOut : 5000,
    sharing : 0,
    waiting : 1
  });
  test.identical( got, true );
  test.is( provider.fileIsLocked( filePath ) );
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 0,
    timeOut : 5000,
    sharing : 0,
    waiting : 1
  });
  test.identical( got, null );
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileUnlock( filePath );
  test.is( !provider.fileIsLocked( filePath ) );
}

//

function fileLockWaitingNotSharingAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileLockAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileLockWaitingNotSharingAsync' );
  let filePath = path.join( routinePath, 'terminal' );

  let t1;
  let ready = new _.Consequence().take( null )

  /* */

  .then( () =>
  {
    test.case = 'trivial'
    provider.filesDelete( routinePath )
    provider.fileWrite( filePath, filePath )
    return provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 1,
      timeOut : 5000,
      sharing : 0,
      waiting : 1
    })
    .then( ( got ) =>
    {
      test.identical( got, true );
      test.is( provider.fileIsLocked( filePath ) );
      provider.fileUnlock( filePath );
      test.is( !provider.fileIsLocked( filePath ) );
      return null;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'fileFile is missing'
    provider.filesDelete( routinePath );
    let con = provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 1,
      timeOut : 5000,
      sharing : 0,
      waiting : 1
    });

    return test.shouldThrowErrorAsync( con )
    .then( () =>
    {
      test.is( !provider.fileExists( filePath ) );
      return null;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'fileFile is missing, throwing off'
    provider.filesDelete( routinePath );
    return provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 0,
      timeOut : 5000,
      sharing : 0,
      waiting : 1
    })
    .then( ( got ) =>
    {
      test.identical( got, null )
      test.is( !provider.fileExists( filePath ) );
      return null;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'try to lock file for second time';
    provider.filesDelete( routinePath )
    provider.fileWrite( filePath, filePath )
    var con = provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 1,
      timeOut : 5000,
      sharing : 0,
      waiting : 1
    });

    con.then( ( got ) =>
    {
      test.identical( got, true );
      test.is( provider.fileIsLocked( filePath ) );
      return null;
    })

    con.then( () =>
    {
      t1 = _.time.now();
      let con2 = provider.fileLock
      ({
        filePath,
        sync : 0,
        throwing : 1,
        timeOut : 5000,
        sharing : 0,
        waiting : 1
      });
      return test.shouldThrowErrorAsync( con2 )
    })

    con.then( ( got ) =>
    {
      let t2 = _.time.now();
      test.le( t2 - t1, 1000 );

      test.is( provider.fileIsLocked( filePath ) );
      provider.fileUnlock( filePath );
      test.is( !provider.fileIsLocked( filePath ) );
      return null;
    })

    return con;
  })

  /* - */

  .then( () =>
  {
    test.case = 'try to lock file for second time, throwing off';
    provider.filesDelete( routinePath )
    provider.fileWrite( filePath, filePath )
    var con = provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 0,
      timeOut : 5000,
      sharing : 0,
      waiting : 1
    });

    con.then( ( got ) =>
    {
      test.identical( got, true );
      test.is( provider.fileIsLocked( filePath ) );
      return null;
    })

    con.then( () =>
    {
      t1 = _.time.now();
      let con2 = provider.fileLock
      ({
        filePath,
        sync : 0,
        throwing : 0,
        timeOut : 5000,
        sharing : 0,
        waiting : 1
      });
      return test.mustNotThrowError( con2 )
    })

    con.then( ( got ) =>
    {
      let t2 = _.time.now();
      test.identical( got, null );
      test.le( t2 - t1, 1000 );

      test.is( provider.fileIsLocked( filePath ) );
      provider.fileUnlock( filePath );
      test.is( !provider.fileIsLocked( filePath ) );
      return null;
    })

    return con;
  })

  /* - */

  return ready;
}

//

function fileLockWaitingSharingAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileLockAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileLockWaitingSharingAsync' );
  let filePath = path.join( routinePath, 'terminal' );

  let t1;
  let ready = new _.Consequence().take( null )

  /* */

  .then( () =>
  {
    test.case = 'trivial'
    provider.filesDelete( routinePath )
    provider.fileWrite( filePath, filePath )
    return provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 1,
      timeOut : 5000,
      sharing : 'process',
      waiting : 1
    })
    .then( ( got ) =>
    {
      test.identical( got, true );
      test.is( provider.fileIsLocked( filePath ) );
      provider.fileUnlock( filePath );
      test.is( !provider.fileIsLocked( filePath ) );
      return null;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'fileFile is missing'
    provider.filesDelete( routinePath );
    let con = provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 1,
      timeOut : 5000,
      sharing : 'process',
      waiting : 1
    });

    return test.shouldThrowErrorAsync( con )
    .then( () =>
    {
      test.is( !provider.fileExists( filePath ) );
      return null;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'fileFile is missing, throwing off'
    provider.filesDelete( routinePath );
    return provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 0,
      timeOut : 5000,
      sharing : 'process',
      waiting : 1
    })
    .then( ( got ) =>
    {
      test.identical( got, null )
      test.is( !provider.fileExists( filePath ) );
      return null;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'try to lock file for second time';
    provider.filesDelete( routinePath )
    provider.fileWrite( filePath, filePath )
    var con = provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 1,
      timeOut : 5000,
      sharing : 'process',
      waiting : 1
    });

    con.then( ( got ) =>
    {
      test.identical( got, true );
      test.is( provider.fileIsLocked( filePath ) );
      return null;
    })

    con.then( () =>
    {
      t1 = _.time.now();
      let con2 = provider.fileLock
      ({
        filePath,
        sync : 0,
        throwing : 1,
        timeOut : 5000,
        sharing : 'process',
        waiting : 1
      });
      return test.shouldThrowErrorAsync( con2 )
    })

    con.then( ( got ) =>
    {
      let t2 = _.time.now();
      test.ge( t2 - t1, 5000 );

      test.is( provider.fileIsLocked( filePath ) );
      provider.fileUnlock( filePath );
      test.is( !provider.fileIsLocked( filePath ) );
      return null;
    })

    return con;
  })

  /* - */

  .then( () =>
  {
    test.case = 'try to lock file for second time, throwing off';
    provider.filesDelete( routinePath )
    provider.fileWrite( filePath, filePath )
    var con = provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 0,
      timeOut : 5000,
      sharing : 'process',
      waiting : 1
    });

    con.then( ( got ) =>
    {
      test.identical( got, true );
      test.is( provider.fileIsLocked( filePath ) );
      return null;
    })

    con.then( () =>
    {
      t1 = _.time.now();
      let con2 = provider.fileLock
      ({
        filePath,
        sync : 0,
        throwing : 0,
        timeOut : 5000,
        sharing : 'process',
        waiting : 1
      });
      return test.mustNotThrowError( con2 )
    })

    con.then( ( got ) =>
    {
      let t2 = _.time.now();
      test.identical( got, null );
      test.ge( t2 - t1, 5000 );

      test.is( provider.fileIsLocked( filePath ) );
      provider.fileUnlock( filePath );
      test.is( !provider.fileIsLocked( filePath ) );
      return null;
    })

    return con;
  })

  /* - */

  .then( () =>
  {
    test.case = 'try to lock file for second time, first lock is released after short timeout';
    provider.filesDelete( routinePath )
    provider.fileWrite( filePath, filePath )
    var con = provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 0,
      timeOut : 5000,
      sharing : 'process',
      waiting : 1
    });

    con.then( ( got ) =>
    {
      test.identical( got, true );
      test.is( provider.fileIsLocked( filePath ) );
      return null;
    })

    con.then( () =>
    {
      t1 = _.time.now();
      let con2 = provider.fileLock
      ({
        filePath,
        sync : 0,
        throwing : 1,
        timeOut : 5000,
        sharing : 'process',
        waiting : 1
      });

      _.time.out( 2000, () =>
      {
        provider.fileUnlock( filePath );
        return null;
      });

      return test.mustNotThrowError( con2 )
    })

    con.then( ( got ) =>
    {
      let t2 = _.time.now();

      test.ge( t2 - t1, 2000 );
      test.lt( t2 - t1, 5000 );

      test.is( provider.fileIsLocked( filePath ) );
      provider.fileUnlock( filePath );
      test.is( !provider.fileIsLocked( filePath ) );
      return null;
    })

    return con;
  })

  return ready;
}

//

function fileLockNotWaitingSharingSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileLockAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileLockNotWaitingSharingSync' );
  let filePath = path.join( routinePath, 'terminal' );

  /* */

  test.case = 'trivial'
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 1,
    timeOut : 5000,
    sharing : 'process',
    waiting : 0
  });
  test.identical( got, true );
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileUnlock( filePath );
  test.is( !provider.fileIsLocked( filePath ) );

  /* - */

  test.case = 'fileFile is missing'
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileLock
    ({
      filePath,
      sync : 1,
      throwing : 1,
      timeOut : 5000,
      sharing : 'process',
      waiting : 0
    });
  });

  /* - */

  test.case = 'fileFile is missing, throwing off'
  provider.filesDelete( routinePath );
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 0,
    timeOut : 5000,
    sharing : 'process',
    waiting : 0
  });
  test.identical( got, null );

  /* - */

  test.case = 'try to lock file for second time';
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 1,
    timeOut : 5000,
    sharing : 'process',
    waiting : 0
  });
  test.identical( got, true );
  test.is( provider.fileIsLocked( filePath ) );
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 1,
    timeOut : 5000,
    sharing : 'process',
    waiting : 0
  });
  test.identical( got, true );
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileUnlock( filePath );
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileUnlock( filePath );
  test.is( !provider.fileIsLocked( filePath ) );

  /* - */

  test.case = 'try to lock file for second time, throwing off';
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 0,
    timeOut : 5000,
    sharing : 'process',
    waiting : 0
  });
  test.identical( got, true );
  test.is( provider.fileIsLocked( filePath ) );
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 0,
    timeOut : 5000,
    sharing : 'process',
    waiting : 0
  });
  test.identical( got, true );
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileUnlock( filePath );
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileUnlock( filePath );
  test.is( !provider.fileIsLocked( filePath ) );
}

//

function fileLockNotWaitingSharingAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileLockAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileLockNotWaitingSharingAsync' );
  let filePath = path.join( routinePath, 'terminal' );

  let t1;
  let ready = new _.Consequence().take( null )

  /* */

  .then( () =>
  {
    test.case = 'trivial'
    provider.filesDelete( routinePath )
    provider.fileWrite( filePath, filePath )
    return provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 1,
      timeOut : 5000,
      sharing : 'process',
      waiting : 0
    })
    .then( ( got ) =>
    {
      test.identical( got, true );
      test.is( provider.fileIsLocked( filePath ) );
      provider.fileUnlock( filePath );
      test.is( !provider.fileIsLocked( filePath ) );
      return null;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'fileFile is missing'
    provider.filesDelete( routinePath );
    let con = provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 1,
      timeOut : 5000,
      sharing : 'process',
      waiting : 0
    });

    return test.shouldThrowErrorAsync( con )
    .then( () =>
    {
      test.is( !provider.fileExists( filePath ) );
      return null;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'fileFile is missing, throwing off'
    provider.filesDelete( routinePath );
    return provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 0,
      timeOut : 5000,
      sharing : 'process',
      waiting : 0
    })
    .then( ( got ) =>
    {
      test.identical( got, null )
      test.is( !provider.fileExists( filePath ) );
      return null;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'try to lock file for second time';
    provider.filesDelete( routinePath )
    provider.fileWrite( filePath, filePath )
    var con = provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 1,
      timeOut : 5000,
      sharing : 'process',
      waiting : 0
    });

    con.then( ( got ) =>
    {
      test.identical( got, true );
      test.is( provider.fileIsLocked( filePath ) );
      return null;
    })

    con.then( () =>
    {
      t1 = _.time.now();
      let con2 = provider.fileLock
      ({
        filePath,
        sync : 0,
        throwing : 1,
        timeOut : 5000,
        sharing : 'process',
        waiting : 0
      });
      return test.mustNotThrowError( con2 )
    })

    con.then( ( got ) =>
    {
      let t2 = _.time.now();
      test.le( t2 - t1, 1000 );

      test.is( provider.fileIsLocked( filePath ) );
      provider.fileUnlock( filePath );
      test.is( provider.fileIsLocked( filePath ) );
      provider.fileUnlock( filePath );
      test.is( !provider.fileIsLocked( filePath ) );
      return null;
    })

    return con;
  })

  /* - */

  .then( () =>
  {
    test.case = 'try to lock file for second time, throwing off';
    provider.filesDelete( routinePath )
    provider.fileWrite( filePath, filePath )
    var con = provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 0,
      timeOut : 5000,
      sharing : 'process',
      waiting : 0
    });

    con.then( ( got ) =>
    {
      test.identical( got, true );
      test.is( provider.fileIsLocked( filePath ) );
      return null;
    })

    con.then( () =>
    {
      t1 = _.time.now();
      let con2 = provider.fileLock
      ({
        filePath,
        sync : 0,
        throwing : 0,
        timeOut : 5000,
        sharing : 'process',
        waiting : 0
      });
      return test.mustNotThrowError( con2 )
    })

    con.then( ( got ) =>
    {
      let t2 = _.time.now();
      test.identical( got, true );
      test.le( t2 - t1, 500 );

      test.is( provider.fileIsLocked( filePath ) );
      provider.fileUnlock( filePath );
      test.is( provider.fileIsLocked( filePath ) );
      provider.fileUnlock( filePath );
      test.is( !provider.fileIsLocked( filePath ) );
      return null;
    })

    return con;
  })

  return ready;
}

//

function fileLockNotWaitingNotSharingSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileLockAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileLockNotWaitingNotSharingSync' );
  let filePath = path.join( routinePath, 'terminal' );

  /* */

  test.case = 'trivial'
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 1,
    timeOut : 5000,
    sharing : 0,
    waiting : 0
  });
  test.identical( got, true );
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileUnlock( filePath );
  test.is( !provider.fileIsLocked( filePath ) );

  /* - */

  test.case = 'fileFile is missing'
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileLock
    ({
      filePath,
      sync : 1,
      throwing : 1,
      timeOut : 5000,
      sharing : 0,
      waiting : 0
    });
  });

  /* - */

  test.case = 'fileFile is missing, throwing off'
  provider.filesDelete( routinePath );
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 0,
    timeOut : 5000,
    sharing : 0,
    waiting : 0
  });
  test.identical( got, null );

  /* - */

  test.case = 'try to lock file for second time';
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 1,
    timeOut : 5000,
    sharing : 0,
    waiting : 0
  });
  test.identical( got, true );
  test.is( provider.fileIsLocked( filePath ) );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileLock
    ({
      filePath,
      sync : 1,
      throwing : 1,
      timeOut : 5000,
      sharing : 0,
      waiting : 0
    });
  });
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileUnlock( filePath );
  test.is( !provider.fileIsLocked( filePath ) );

  /* - */

  test.case = 'try to lock file for second time, throwing off';
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 0,
    timeOut : 5000,
    sharing : 0,
    waiting : 0
  });
  test.identical( got, true );
  test.is( provider.fileIsLocked( filePath ) );
  var got = provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 0,
    timeOut : 5000,
    sharing : 0,
    waiting : 0
  });
  test.identical( got, null );
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileUnlock( filePath );
  test.is( !provider.fileIsLocked( filePath ) );
}

//

function fileLockNotWaitingNotSharingAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileLockAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileLockNotWaitingNotSharingAsync' );
  let filePath = path.join( routinePath, 'terminal' );

  let t1;
  let ready = new _.Consequence().take( null )

  /* */

  .then( () =>
  {
    test.case = 'trivial'
    provider.filesDelete( routinePath )
    provider.fileWrite( filePath, filePath )
    return provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 1,
      timeOut : 5000,
      sharing : 0,
      waiting : 0
    })
    .then( ( got ) =>
    {
      test.identical( got, true );
      test.is( provider.fileIsLocked( filePath ) );
      provider.fileUnlock( filePath );
      test.is( !provider.fileIsLocked( filePath ) );
      return null;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'fileFile is missing'
    provider.filesDelete( routinePath );
    let con = provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 1,
      timeOut : 5000,
      sharing : 0,
      waiting : 0
    });

    return test.shouldThrowErrorAsync( con )
    .then( () =>
    {
      test.is( !provider.fileExists( filePath ) );
      return null;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'fileFile is missing, throwing off'
    provider.filesDelete( routinePath );
    return provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 0,
      timeOut : 5000,
      sharing : 0,
      waiting : 0
    })
    .then( ( got ) =>
    {
      test.identical( got, null )
      test.is( !provider.fileExists( filePath ) );
      return null;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'try to lock file for second time';
    provider.filesDelete( routinePath )
    provider.fileWrite( filePath, filePath )
    var con = provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 1,
      timeOut : 5000,
      sharing : 0,
      waiting : 0
    });

    con.then( ( got ) =>
    {
      test.identical( got, true );
      test.is( provider.fileIsLocked( filePath ) );
      return null;
    })

    con.then( () =>
    {
      t1 = _.time.now();
      let con2 = provider.fileLock
      ({
        filePath,
        sync : 0,
        throwing : 1,
        timeOut : 5000,
        sharing : 0,
        waiting : 0
      });
      return test.shouldThrowErrorAsync( con2 )
    })

    con.then( ( got ) =>
    {
      let t2 = _.time.now();
      test.le( t2 - t1, 1000 );

      test.is( provider.fileIsLocked( filePath ) );
      provider.fileUnlock( filePath );
      test.is( !provider.fileIsLocked( filePath ) );
      return null;
    })

    return con;
  })

  /* - */

  .then( () =>
  {
    test.case = 'try to lock file for second time, throwing off';
    provider.filesDelete( routinePath )
    provider.fileWrite( filePath, filePath )
    var con = provider.fileLock
    ({
      filePath,
      sync : 0,
      throwing : 0,
      timeOut : 5000,
      sharing : 0,
      waiting : 0
    });

    con.then( ( got ) =>
    {
      test.identical( got, true );
      test.is( provider.fileIsLocked( filePath ) );
      return null;
    })

    con.then( () =>
    {
      t1 = _.time.now();
      let con2 = provider.fileLock
      ({
        filePath,
        sync : 0,
        throwing : 0,
        timeOut : 5000,
        sharing : 0,
        waiting : 0
      });
      return test.mustNotThrowError( con2 )
    })

    con.then( ( got ) =>
    {
      test.identical( got, null );

      let t2 = _.time.now();
      test.le( t2 - t1, 1000 );

      test.is( provider.fileIsLocked( filePath ) );
      provider.fileUnlock( filePath );
      test.is( !provider.fileIsLocked( filePath ) );
      return null;
    })

    return con;
  })

  return ready;
}

//

function fileUnlockSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileLockAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileUnlockSync' );
  let filePath = path.join( routinePath, 'terminal' );

  /* */

  test.case = 'filePath is missing'
  provider.filesDelete( routinePath )
  test.shouldThrowErrorSync( () =>
  {
    provider.fileUnlock
    ({
      filePath,
      sync : 1,
      throwing : 1,
    });
  })

  test.case = 'filePath is missing'
  provider.filesDelete( routinePath )
  var got = provider.fileUnlock
  ({
    filePath,
    sync : 1,
    throwing : 0,
  });
  test.identical( got, null )

  test.case = 'nothing locked, try to unlock'
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  test.is( !provider.fileIsLocked( filePath ) );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileUnlock
    ({
      filePath,
      sync : 1,
      throwing : 1,
    });
  })
  test.is( !provider.fileIsLocked( filePath ) );

  test.case = 'nothing locked, try to unlock'
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  test.is( !provider.fileIsLocked( filePath ) );
  var got = provider.fileUnlock
  ({
    filePath,
    sync : 1,
    throwing : 0,
  });
  test.identical( got, null )
  test.is( !provider.fileIsLocked( filePath ) );

  test.case = 'single lock + unlock'
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 1,
    timeOut : 5000,
    sharing : 'process',
    waiting : 0
  });
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileUnlock
  ({
    filePath,
    sync : 1,
    throwing : 1,
  });
  test.is( !provider.fileIsLocked( filePath ) );

  test.case = 'two locks + two unlock'
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 1,
    timeOut : 5000,
    sharing : 'process',
    waiting : 0
  });
  provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 1,
    timeOut : 5000,
    sharing : 'process',
    waiting : 0
  });
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileUnlock
  ({
    filePath,
    sync : 1,
    throwing : 1,
  });
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileUnlock
  ({
    filePath,
    sync : 1,
    throwing : 1,
  });
  test.is( !provider.fileIsLocked( filePath ) );

  test.case = 'lock exists, but file is not locked by provider, try to unlock'
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( filePath + '.lock', filePath )
  test.shouldThrowErrorSync( () =>
  {
    provider.fileUnlock
    ({
      filePath,
      sync : 1,
      throwing : 1,
    });
  })
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileDelete( filePath + '.lock' );
  test.is( !provider.fileIsLocked( filePath ) );

  test.case = 'lock exists, but file is not locked by provider, try to unlock'
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( filePath + '.lock', filePath )
  var got = provider.fileUnlock
  ({
    filePath,
    sync : 1,
    throwing : 0,
  });
  test.identical( got, null );
  test.is( provider.fileIsLocked( filePath ) );
  provider.fileDelete( filePath + '.lock' );
  test.is( !provider.fileIsLocked( filePath ) );

  test.case = 'single lock + unlock'
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  provider.fileLock
  ({
    filePath,
    sync : 1,
    throwing : 1,
    timeOut : 5000,
    sharing : 'process',
    waiting : 0
  });
  var got = provider.fileUnlock
  ({
    filePath,
    sync : 1,
    throwing : 1,
  });
  test.identical( got, true );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileUnlock
    ({
      filePath,
      sync : 1,
      throwing : 1,
    });

  })
}

//

function fileIsLockedSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileLockAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileIsLockedSync' );
  let filePath = path.join( routinePath, 'terminal' );

  test.case = 'filePath is missing'
  provider.filesDelete( routinePath )
  test.shouldThrowErrorSync( () =>
  {
    provider.fileIsLocked
    ({
      filePath,
      sync : 1,
      throwing : 1,
    });
  })

  test.case = 'filePath is missing, throwing off'
  provider.filesDelete( routinePath )
  var got = provider.fileIsLocked
  ({
    filePath,
    sync : 1,
    throwing : 0,
  });
  test.identical( got, null )

  test.case = 'nothing locked, check lock'
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  var got = provider.fileIsLocked
  ({
    filePath,
    sync : 1,
    throwing : 1,
  });
  test.identical( got, false );

  test.case = 'locked by other process, check lock'
  provider.filesDelete( routinePath )
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( filePath + '.lock', filePath )
  var got = provider.fileIsLocked
  ({
    filePath,
    sync : 1,
    throwing : 1,
  });
  test.identical( got, true );
  provider.fileDelete( filePath + '.lock' );
  var got = provider.fileIsLocked
  ({
    filePath,
    sync : 1,
    throwing : 1,
  });
  test.identical( got, false );

}


//

function statReadActSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.statReadAct ) )
  {
    test.case = 'statReadAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  var mp = _.routineJoin( test.context, test.context.pathFor );
  var routinePath = mp( 'statReadActSync' );

  let expectedNlinkDir = 1;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  if( process.platform !== 'win32' )
  expectedNlinkDir = 2;

  provider.fieldPush( 'usingTextLink', 1 );

  /* - */

  test.case = 'regular terminal';
  var file1Path = path.join( routinePath, 'file1' );
  var file2Path = path.join( routinePath, 'file2' );
  provider.fileWrite( file1Path, 'file1' );
  provider.fileWrite( file2Path, '' );

  test.description = 'file1';
  var o =
  {
    filePath : file1Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  if( provider.UsingBigIntForStat )
  test.identical( stat.size, BigInt( 5 ) );
  else
  test.identical( stat.size, 5 );

  test.description = 'file2';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  if( provider.UsingBigIntForStat )
  test.identical( stat.size, BigInt( 0 ) );
  else
  test.identical( stat.size, 0 );

  provider.filesDelete( routinePath );

  /* - */

  test.case = 'hard link';
  var file1Path = path.join( routinePath, 'file1' );
  var file2Path = path.join( routinePath, 'file2' );
  provider.fileWrite( file1Path, 'file1' );
  provider.hardLink( file2Path, file1Path );

  test.description = 'file1';
  var o =
  {
    filePath : file1Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 2 ) )
  else
  test.identical( stat.nlink, 2 );
  if( provider.UsingBigIntForStat )
  test.identical( stat.size, BigInt( 5 ) );
  else
  test.identical( stat.size, 5 );

  test.description = 'file2';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 2 ) )
  else
  test.identical( stat.nlink, 2 );
  if( provider.UsingBigIntForStat )
  test.identical( stat.size, BigInt( 5 ) );
  else
  test.identical( stat.size, 5 );

  provider.filesDelete( routinePath );

  /* - */

  test.case = 'soft link';
  var file1Path = path.join( routinePath, 'file1' );
  var file2Path = path.join( routinePath, 'file2' );
  provider.fileWrite( file1Path, 'file1' );
  provider.softLink( file2Path, file1Path );

  test.description = 'file1';
  var o =
  {
    filePath : file1Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  if( provider.UsingBigIntForStat )
  test.identical( stat.size, BigInt( 5 ) );
  else
  test.identical( stat.size, 5 );

  test.description = 'file2';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( !stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  // test.identical( stat.size, null );

  test.description = 'file2, resolving';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.size, BigInt( 5 ) );
  else
  test.identical( stat.size, 5 );

  provider.filesDelete( routinePath );

  // /* - */

  test.case = 'text link';
  var file1Path = path.join( routinePath, 'file1' );
  var file2Path = path.join( routinePath, 'file2' );
  provider.fileWrite( file1Path, 'file1' );
  provider.textLink( file2Path, file1Path );

  test.description = 'file1';
  var o =
  {
    filePath : file1Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  if( provider.UsingBigIntForStat )
  test.identical( stat.size, BigInt( 5 ) );
  else
  test.identical( stat.size, 5 );

  test.description = 'file2';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  var read = context.provider.fileRead( file2Path );
  if( provider.UsingBigIntForStat )
  test.ge( stat.size, BigInt( read.length ) );
  else
  test.identical( stat.size, read.length );

  /* - */

  provider.fieldPush( 'usingTextLink', 0 );

  test.description = 'file2, usingTextLink off';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  var read = context.provider.fileRead( file2Path );
  if( provider.UsingBigIntForStat )
  test.ge( stat.size, BigInt( read.length ) );
  else
  test.identical( stat.size, read.length );

  test.description = 'file2, resolving,, usingTextLink off';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  var read = context.provider.fileRead( file2Path );
  if( provider.UsingBigIntForStat )
  test.ge( stat.size, BigInt( read.length ) );
  else
  test.identical( stat.size, read.length );

  provider.fieldPop( 'usingTextLink', 0 );

  /* - */

  test.description = 'file2, resolving';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  var read = context.provider.fileRead( file2Path );
  if( provider.UsingBigIntForStat )
  test.ge( stat.size, BigInt( read.length ) );
  else
  test.identical( stat.size, read.length );

  provider.filesDelete( routinePath );

  /* - */

  test.case = 'directory';
  var file1Path = path.join( routinePath, 'file1' );
  var file2Path = path.join( routinePath, 'file2' );
  provider.dirMake( file1Path );
  provider.dirMake( file2Path );

  test.description = 'file1';
  var o =
  {
    filePath : file1Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( stat.isDir() );
  test.is( !stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( expectedNlinkDir ) )
  else
  test.identical( stat.nlink, expectedNlinkDir );
  if( provider.UsingBigIntForStat )
  test.is( stat.size >= BigInt( 0 ) || stat.size === null );
  else
  test.is( stat.size >= 0 || stat.size === null );

  test.description = 'file2';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( stat.isDir() );
  test.is( !stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( expectedNlinkDir ) )
  else
  test.identical( stat.nlink, expectedNlinkDir );
  if( provider.UsingBigIntForStat )
  test.is( stat.size >= BigInt( 0 ) || stat.size === null );
  else
  test.is( stat.size >= 0 || stat.size === null );

  /* - */

  test.case = 'basic usage, should path nativize all paths in options map if needed by its own means';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    filePath : srcPath,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var expected = _.mapExtend( null, o );
  // expected.filePath = provider.path.nativize( o.filePath );
  var stat = provider.statReadAct( o );
  test.identical( o, expected );
  test.is( !!stat );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'no src';
  var srcPath = path.join( routinePath, 'src' );
  var o =
  {
    filePath : srcPath,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1
  }
  var expected = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, expected );
  test.is( !stat );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'no src';
  var srcPath = path.join( routinePath, 'src' );
  var o =
  {
    filePath : srcPath,
    sync : 1,
    throwing : 1,
    resolvingSoftLink : 1
  }
  var expected = _.mapExtend( null, o );
  test.shouldThrowErrorOfAnyKind( () => provider.statReadAct( o ) );
  test.identical( o, expected );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    filePath : srcPath,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1
  }
  var expected = _.mapOwnKeys( o );
  // expected.filePath = provider.path.nativize( o.filePath );
  var stat = provider.statReadAct( o );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  test.is( !!stat );
  provider.filesDelete( routinePath );

  /* - */

  if( test.context.softLinkIsSupported() )
  {
    test.case = 'src is a soft link';
    var srcPath1 = path.join( routinePath, 'src' );
    var dstPath = path.join( routinePath, 'dst' );
    provider.fileWrite( srcPath1, srcPath1 );
    provider.softLink( dstPath, srcPath1 );
    var o1 =
    {
      filePath : dstPath,
      sync : 1,
      throwing : 0,
      resolvingSoftLink : 1
    }
    var stat1 = provider.statReadAct( o1 );
    test.is( !!stat1 );
    test.is( !stat1.isSoftLink() );
    provider.filesDelete( routinePath );

    /* - */

    test.case = 'src is a soft link';
    var srcPath1 = path.join( routinePath, 'src' );
    var dstPath = path.join( routinePath, 'dst' );
    provider.fileWrite( srcPath1, srcPath1 );
    provider.softLink( dstPath, srcPath1 );
    var o1 =
    {
      filePath : dstPath,
      sync : 1,
      throwing : 0,
      resolvingSoftLink : 0
    }
    var stat1 = provider.statReadAct( o1 );
    test.is( !!stat1 );
    test.is( stat1.isSoftLink() );
    provider.filesDelete( routinePath );
  }

  /* - */

  if( !Config.debug )
  return;

  if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.case = 'should assert that path is absolute';
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.statReadAct
      ({
        filePath : './src',
        sync : 1,
        throwing : 0,
        resolvingSoftLink : 1
      });
    })
  }

  /* - */

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.statReadAct
    ({
      filePath : srcPath,
      sync : 1,
      throwing : 1,
      resolvingSoftLink : 1
    });
  })

  /* - */

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath, 'src' );

  /* sync option is missed */

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.statReadAct
    ({
      filePath : srcPath,
      throwing : 0,
      resolvingSoftLink : 1
    });
  });

  /* - */

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.statReadAct
    ({
      filePath : srcPath,
      throwing : 1,
      resolvingSoftLink : 1
    });
  });

  /* redundant option */

  var o =
  {
    filePath : srcPath,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
    redundant : 'redundant'
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.statReadAct( o );
  });

  /* - */

  var o =
  {
    filePath : srcPath,
    sync : 1,
    throwing : 1,
    resolvingSoftLink : 1,
    redundant : 'redundant'
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.statReadAct( o );
  });

  /* - */

  test.case = 'should expect normalized path, but not nativized';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );

  /* - */

  if( !test.context.providerIsInstanceOf( _.FileProvider.System ) )
  if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    var o3 =
    {
      filePath : srcPath,
      sync : 1,
      throwing : 0,
      resolvingSoftLink : 1,
    }
    var originalPath = provider.path.preferredFromGlobal( o3.filePath );
    o3.filePath = provider.path.nativize( o3.filePath );
    if( o3.filePath !== originalPath )
    {
      test.shouldThrowErrorOfAnyKind( () =>
      {
        provider.statReadAct( o3 );
      })
    }
    else
    {
      test.mustNotThrowError( () =>
      {
        provider.statReadAct( o3 );
      })
    }
    provider.filesDelete( routinePath );

    /* - */

    var o3 =
    {
      filePath : srcPath,
      sync : 1,
      throwing : 1,
      resolvingSoftLink : 1,
    }
    o3.filePath = provider.path.nativize( o3.filePath );
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.statReadAct( o3 );
    })
    provider.filesDelete( routinePath );
  }

  /* - */

  test.case = 'should expect ready options map, no complex arguments preprocessing';
  var srcPath = path.join( routinePath, 'src' );

  /* - */

  var o =
  {
    filePath : [ srcPath ],
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var expected = _.mapExtend( null, o );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.statReadAct( o );
  })
  test.identical( o.filePath, expected.filePath );

  /* - */

  var o =
  {
    filePath : [ srcPath ],
    sync : 1,
    throwing : 1,
    resolvingSoftLink : 1,
  }
  var expected = _.mapExtend( null, o );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.statReadAct( o );
  })
  test.identical( o.filePath, expected.filePath );

  /*  */

  provider.fieldPop( 'usingTextLink', 1 );
}

//

function statResolvedReadAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.statReadAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var routinePath = test.context.pathFor( 'read/statResolvedReadAsync' );
  var filePath, expected;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var consequence = new _.Consequence().take( null );

  /* - */

  consequence
  .ifNoErrorThen( function( arg )
  {
    filePath = test.context.pathFor( 'read/statResolvedReadAsync/src.txt' );
    provider.fileWrite( filePath, 'Excepteur sint occaecat cupidatat non proident' );
    test.case = 'synchronous file stat default options';
    expected = 46;
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    debugger
    return provider.statResolvedRead
    ({
      sync : 0,
      filePath,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      if( _.bigIntIs( got.size ) )
      expected = BigInt( expected );
      test.identical( got.size, expected );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.statResolvedRead
    ({
      sync : 0,
      filePath,
      throwing : 1
    })
    .ifNoErrorThen( function( got )
    {
      if( _.bigIntIs( got.size ) )
      expected = BigInt( expected );
      test.identical( got.size, expected );
      return null;
    })
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'invalid path';
    filePath = test.context.pathFor( '///bad path///test.txt' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.statResolvedRead
    ({
      sync : 0,
      filePath,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      var expected = null;
      test.identical( got, expected );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.statResolvedRead
    ({
      sync : 0,
      filePath,
      throwing : 1
    });

    return test.shouldThrowErrorOfAnyKind( con )
  });

  return consequence;
}

//

function statReadActLinkedHead( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  var routinePath = test.context.pathFor( 'written/statReadActLinkedHead' )
  var dirPath = path.join( routinePath, 'dir' );
  var dirPath2 = path.join( routinePath, 'dir2' );
  var terminalPath = path.join( dirPath, 'terminal' );
  var terminalLinkPath = path.join( dirPath, 'terminalLink' );
  var linkPath = path.join( routinePath, 'link' );
  var linkPath2 = path.join( dirPath2, 'link2' );

  /**/

  test.case = 'intermediate soft link to directory with terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( linkPath, dirPath );
  var pathToRead = path.join( routinePath, 'link/terminal' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'intermediate soft link to directory with terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( linkPath, dirPath );
  var pathToRead = path.join( routinePath, 'link/terminal' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'intermediate soft link to directory with soft link';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( terminalLinkPath, terminalPath );
  provider.softLink( linkPath, dirPath );
  var pathToRead = path.join( routinePath, 'link/terminalLink' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isSoftLink() );

  /**/

  test.case = 'intermediate soft link to directory with soft link';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( terminalLinkPath, terminalPath );
  provider.softLink( linkPath, dirPath );
  var pathToRead = path.join( routinePath, 'link/terminalLink' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'intermediate soft link to directory with missing file';
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink( linkPath, dirPath );
  var pathToRead = path.join( routinePath, 'link/missing' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

  /**/

  test.case = 'intermediate soft link to directory with missing file';
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink( linkPath, dirPath );
  var pathToRead = path.join( routinePath, 'link/missing' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

  /**/

  test.case = 'intermediate soft link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( linkPath, terminalPath );
  var pathToRead = path.join( routinePath, 'link/terminal' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

  /**/

  test.case = 'intermediate soft link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( linkPath, terminalPath );
  var pathToRead = path.join( routinePath, 'link/terminal' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

  /**/

  test.case = 'soft->soft->dir/terminal';
  var linkPath2 = path.join( routinePath, 'link2' );
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, linkPath2 );
  var pathToRead = path.join( routinePath, 'link/terminal' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'soft->soft->dir/terminal';
  var linkPath2 = path.join( routinePath, 'link2' );
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, linkPath2 );
  var pathToRead = path.join( routinePath, 'link/terminal' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'soft->soft->dir/soft->terminal';
  var linkPath2 = path.join( routinePath, 'link2' );
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( terminalLinkPath, terminalPath );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, linkPath2 );
  var pathToRead = path.join( routinePath, 'link/terminalLink' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isSoftLink() );

  /**/

  test.case = 'soft->soft->dir/soft->terminal';
  var linkPath2 = path.join( routinePath, 'link2' );
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( terminalLinkPath, terminalPath );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, linkPath2 );
  var pathToRead = path.join( routinePath, 'link/terminalLink' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'soft->soft->dir/missing';
  var linkPath2 = path.join( routinePath, 'link2' );
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, linkPath2 );
  var pathToRead = path.join( routinePath, 'link/missing' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

  /**/

  test.case = 'soft->soft->dir/missing';
  var linkPath2 = path.join( routinePath, 'link2' );
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, linkPath2 );
  var pathToRead = path.join( routinePath, 'link/missing' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

  /**/

  test.case = 'two intermediate links in path, soft/soft/terminal';
  var linkPath2 = path.join( dirPath2, 'link2' );
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.dirMake( dirPath2 );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, dirPath2 );
  var pathToRead = path.join( routinePath, 'link/link2/terminal' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'two intermediate links in path, soft/soft/terminal';
  var linkPath2 = path.join( dirPath2, 'link2' );
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.dirMake( dirPath2 );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, dirPath2 );
  var pathToRead = path.join( routinePath, 'link/link2/terminal' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'two intermediate links in path, soft/soft/missing';
  var linkPath2 = path.join( dirPath2, 'link2' );
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.dirMake( dirPath2 );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, dirPath2 );
  var pathToRead = path.join( routinePath, 'link/link2/missing' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

  /**/

  test.case = 'two intermediate links in path, soft/soft/missing';
  var linkPath2 = path.join( dirPath2, 'link2' );
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.dirMake( dirPath2 );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, dirPath2 );
  var pathToRead = path.join( routinePath, 'link/link2/missing' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

  /**/

  test.case = 'two intermediate links in path, soft/soft/soft->terminal';
  var linkPath2 = path.join( dirPath2, 'link2' );
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( terminalLinkPath, terminalPath );
  provider.dirMake( dirPath2 );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, dirPath2 );
  var pathToRead = path.join( routinePath, 'link/link2/terminalLink' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isSoftLink() );

  /**/

  test.case = 'two intermediate links in path, soft/soft/soft->terminal';
  var linkPath2 = path.join( dirPath2, 'link2' );
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( terminalLinkPath, terminalPath );
  provider.dirMake( dirPath2 );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, dirPath2 );
  var pathToRead = path.join( routinePath, 'link/link2/terminalLink' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'two intermediate links in path, soft/soft/soft->missing';
  var linkPath2 = path.join( dirPath2, 'link2' );
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.dirMake( dirPath2 );
  provider.softLink({ dstPath : terminalLinkPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, dirPath2 );
  var pathToRead = path.join( routinePath, 'link/link2/terminalLink' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isSoftLink() );

  /**/

  test.case = 'two intermediate links in path, soft/soft/soft->missing';
  var linkPath2 = path.join( dirPath2, 'link2' );
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.dirMake( dirPath2 );
  provider.softLink({ dstPath : terminalLinkPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, dirPath2 );
  var pathToRead = path.join( routinePath, 'link/link2/terminalLink' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

}

//

function dirMakeSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.dirMakeAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  if( Config.interpreter === 'browser' )
  if( provider.filesTree )
  provider.filesTree = {};

  var routinePath = test.context.pathFor( 'written/dirMake' );
  var filePath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  /* - */

  test.case = 'synchronous mkdir';
  filePath = test.context.pathFor( 'written/dirMake/make_dir' );

  /**/

  provider.dirMake( filePath );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'make_dir' ] );

  /* - */

  test.case = 'synchronous mkdir force';
  provider.filesDelete( filePath );
  filePath = test.context.pathFor( 'written/dirMake/make_dir/dir1' );

  /**/
  provider.dirMake
  ({
    filePath,
    sync : 1,
    recursive : 1
  });
  var files = provider.dirRead( context.provider.path.dir( filePath ) );
  test.identical( files, [ 'dir1' ] );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.filesDelete( context.provider.path.dir( filePath ) );
    provider.dirMake
    ({
      filePath,
      sync : 1,
      recursive : 0
    });
  })

  /* - */

  test.case = 'try to rewrite terminal file';
  filePath = test.context.pathFor( 'written/dirMake/terminal.txt' );
  provider.fileWrite( filePath, ' ' );

  /**/

  provider.dirMake
  ({
    filePath,
    sync : 1,
    recursive : 1,
    rewritingTerminal : 1
  });

  var files = provider.dirRead( context.provider.path.dir( filePath ) );
  test.identical( files, [ 'terminal.txt' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, ' ' );
  test.shouldThrowErrorSync( function()
  {
    provider.dirMake
    ({
      filePath,
      sync : 1,
      recursive : 1,
      rewritingTerminal : 0
    });
  })

  /* - */

  test.case = 'try to rewrite empty dir';
  filePath = test.context.pathFor( 'written/dirMake/empty' );

  /**/

  provider.filesDelete( routinePath )
  provider.dirMake( filePath );
  provider.dirMake
  ({
    filePath,
    sync : 1,
    recursive : 1,
    rewritingTerminal : 1
  });

  var files = provider.dirRead( context.provider.path.dir( filePath ) );
  test.identical( files, [ 'empty' ] );

  /**/

  provider.filesDelete( routinePath )
  provider.dirMake( filePath );
  provider.dirMake
  ({
    filePath,
    sync : 1,
    recursive : 1,
    rewritingTerminal : 1
  });

  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'empty' ] );

  /**/

  provider.filesDelete( routinePath )
  provider.dirMake( filePath );
  provider.dirMake
  ({
    filePath,
    sync : 1,
    recursive : 1,
    rewritingTerminal : 0
  });

  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'empty' ] );

  /**/

  provider.filesDelete( routinePath )
  provider.dirMake( filePath );
  test.shouldThrowErrorSync( function()
  {
    provider.dirMake
    ({
      filePath,
      sync : 1,
      recursive : 0,
      rewritingTerminal : 1
    });
  });

  /**/

  provider.filesDelete( routinePath )
  provider.dirMake( filePath );
  test.shouldThrowErrorSync( function()
  {
    provider.dirMake
    ({
      filePath,
      sync : 1,
      recursive : 0,
      rewritingTerminal : 0
    });
  });

  /* - */

  test.case = '/dir exists, no rewritingTerminal, no force';
  filePath = test.context.pathFor( 'written/dirMake/make_dir/' );

  /**/

  // provider.filesDelete( filePath );
  provider.dirMake( filePath );
  test.shouldThrowErrorSync( function()
  {
    provider.dirMake
    ({
      filePath,
      sync : 1,
      recursive : 0,
      rewritingTerminal : 0
    });
  });

  /* - */

  test.case = 'try to rewrite folder with files';
  filePath = test.context.pathFor( 'written/dirMake/make_dir/file' );
  provider.filesDelete( routinePath );

  /**/

  provider.fileWrite( filePath, ' ' );
  test.shouldThrowErrorSync( function()
  {
    provider.dirMake
    ({
      filePath : context.provider.path.dir( filePath ),
      sync : 1,
      recursive : 0,
      rewritingTerminal : 1
    });
  });

  /**/

  provider.fileWrite( filePath, ' ' );
  test.shouldThrowErrorSync( function()
  {
    provider.dirMake
    ({
      filePath : context.provider.path.dir( filePath ),
      sync : 1,
      recursive : 0,
      rewritingTerminal : 0
    });
  });

  /**/

  provider.fileWrite( filePath, ' ' );
  provider.dirMake
  ({
    filePath : context.provider.path.dir( filePath ),
    sync : 1,
    recursive : 1,
    rewritingTerminal : 1
  });

  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'make_dir' ] );


  /* - */

  test.case = 'folders structure not exist';
  provider.filesDelete( routinePath );
  filePath = test.context.pathFor( 'written/dirMake/routinePath' );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.dirMake
    ({
      filePath,
      sync : 1,
      recursive : 0,
      rewritingTerminal : 0
    });
  });

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.dirMake
    ({
      filePath,
      sync : 1,
      recursive : 0,
      rewritingTerminal : 1
    });
  });

  /**/

  provider.dirMake
  ({
    filePath,
    sync : 1,
    recursive : 1,
    rewritingTerminal : 0
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'routinePath' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.dirMake
  ({
    filePath,
    sync : 1,
    recursive : 1,
    rewritingTerminal : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'routinePath' ] );
}

//

function dirMakeLinksSync( test )
{
  let context = this;
  let provider = context.provider;

  let routinePath = context.pathFor( 'written/dirMakeLinksSync' );
  let dirPath = context.pathFor( 'written/dirMakeLinksSync/dir' );
  let filePath = context.pathFor( 'written/dirMakeLinksSync/file' );
  let fileInDir = context.pathFor( 'written/dirMakeLinksSync/dir/file' );
  let linkToDir = context.pathFor( 'written/dirMakeLinksSync/link' );

  test.case = 'link to missing';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath, allowingMissed : 1, makingDirectory : 1 });
  provider.dirMake({ filePath : linkToDir, recursive : 1 });
  test.is( provider.isDir( dirPath ) );

  test.case = 'link to missing';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath, allowingMissed : 1, makingDirectory : 1 });
  provider.dirMake({ filePath : linkToDir, recursive : 0 });
  test.is( provider.isDir( dirPath ) );

  test.case = 'link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkToDir, srcPath : filePath });
  provider.dirMake({ filePath : linkToDir, recursive : 1, rewritingTerminal : 1 });
  test.is( provider.isDir( filePath ) );

  test.case = 'link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkToDir, srcPath : filePath });
  test.shouldThrowErrorSync( () =>
  {
    provider.dirMake
    ({
      filePath : linkToDir,
      recursive : 1,
      rewritingTerminal : 0
    });
  })
  test.is( provider.isTerminal( filePath ) );

  test.case = 'link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkToDir, srcPath : filePath });
  provider.dirMake({ filePath : linkToDir, recursive : 0, rewritingTerminal : 1 });
  test.is( provider.isDir( filePath ) );

  test.case = 'link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkToDir, srcPath : filePath });
  test.shouldThrowErrorSync( () =>
  {
    provider.dirMake
    ({
      filePath : linkToDir,
      recursive : 0,
      rewritingTerminal : 0
    });
  })
  test.is( provider.isTerminal( filePath ) );

  test.case = 'link to empty dir';
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath });
  provider.dirMake({ filePath : linkToDir, recursive : 1 });
  test.is( provider.isDir( dirPath ) );
  test.is( provider.isSoftLink( linkToDir ) );
  test.identical( provider.dirRead( dirPath ), [] )

  test.case = 'link to empty dir';
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath });
  test.shouldThrowErrorSync( () =>
  {
    provider.dirMake
    ({
      filePath : linkToDir,
      recursive : 0,
    });
  })
  test.is( provider.isDir( dirPath ) );
  test.is( provider.isSoftLink( linkToDir ) );
  test.identical( provider.dirRead( dirPath ), [] )

  test.case = 'link to dir';
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDir, fileInDir );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath });
  provider.dirMake({ filePath : linkToDir, recursive : 1 });
  test.is( provider.isDir( dirPath ) );
  test.is( provider.isSoftLink( linkToDir ) );
  test.identical( provider.dirRead( dirPath ), [ 'file' ] )

  test.case = 'link to dir';
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDir, fileInDir );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath });
  test.shouldThrowErrorSync( () =>
  {
    provider.dirMake
    ({
      filePath : linkToDir,
      recursive : 0,
    });
  })
  test.is( provider.isDir( dirPath ) );
  test.is( provider.isSoftLink( linkToDir ) );
  test.identical( provider.dirRead( dirPath ), [ 'file' ] )

  test.case = 'intermediate link, one dir to create';
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath });
  var path = provider.path.join( linkToDir, 'directory' );
  provider.dirMake({ filePath : path, recursive : 1 })
  test.is( provider.isDir( path ) );
  test.is( provider.isSoftLink( linkToDir ) );

  test.case = 'intermediate link, one dir to create';
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath });
  var path = provider.path.join( linkToDir, 'directory' );
  provider.dirMake({ filePath : path, recursive : 0 })
  test.is( provider.isDir( path ) );
  test.is( provider.isSoftLink( linkToDir ) );

  test.case = 'intermediate link, severals dirs to create';
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath });
  var path = provider.path.join( linkToDir, 'directory/directory2/directory3' );
  provider.dirMake({ filePath : path, recursive : 1 })
  test.is( provider.isDir( path ) );
  test.is( provider.isSoftLink( linkToDir ) );

  test.case = 'intermediate link, severals dirs to create';
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath });
  var path = provider.path.join( linkToDir, 'directory/directory2/directory3' );
  test.shouldThrowErrorSync( () =>
  {
    provider.dirMake
    ({
      filePath : path,
      recursive : 0,
    });
  })
  test.is( !provider.fileExists( path ) );
  test.is( provider.isSoftLink( linkToDir ) );

}

//

function dirMakeAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.dirMakeAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  if( Config.interpreter === 'browser' )
  if( provider.filesTree )
  provider.filesTree = {};

  var routinePath = test.context.pathFor( 'written/dirMakeAsync' );
  var filePath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var consequence = new _.Consequence().take( null );

  /* - */

  consequence
  .ifNoErrorThen( function( arg )
  {
    test.case = 'synchronous mkdir';
    filePath = test.context.pathFor( 'written/dirMakeAsync/make_dir' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 1,
      rewritingTerminal : 1
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'make_dir' ] );
      return null;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'synchronous mkdir force';
    provider.filesDelete( filePath );
    filePath = test.context.pathFor( 'written/dirMakeAsync/make_dir/dir1/' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 1,
      rewritingTerminal : 1
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( context.provider.path.dir( filePath ) );
      test.identical( files, [ 'dir1' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( context.provider.path.dir( filePath ) );
    var con = provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 0,
      rewritingTerminal : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /* - */

  .finally( function()
  {
    test.case = 'try to rewrite terminal file';
    filePath = test.context.pathFor( 'written/dirMakeAsync/terminal.txt' );
    provider.fileWrite( filePath, ' ' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 1,
      rewritingTerminal : 1
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( context.provider.path.dir( filePath ) );
      test.identical( files, [ 'terminal.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( filePath, ' ' );
    var con = provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 1,
      rewritingTerminal : 0
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /* - */

  .finally( function()
  {
    test.case = 'try to rewrite empty dir';
    filePath = test.context.pathFor( 'written/dirMakeAsync/empty' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath )
    provider.dirMake( filePath );
    return provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 1,
      rewritingTerminal : 1
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( context.provider.path.dir( filePath ) );
      test.identical( files, [ 'empty' ] );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath )
    provider.dirMake( filePath );
    return provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 1,
      rewritingTerminal : 0
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'empty' ] );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath )
    provider.dirMake( filePath );
    var con = provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 0,
      rewritingTerminal : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    provider.filesDelete( routinePath )
    provider.dirMake( filePath );
    var con = provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 0,
      rewritingTerminal : 0
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /* - */

  .finally( function()
  {
    test.case = '/dir exists, no rewritingTerminal, no force';
    filePath = test.context.pathFor( 'written/dirMakeAsync/make_dir/' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( filePath );
    provider.dirMake( filePath );
    var con = provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 0,
      rewritingTerminal : 0
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /* - */

  .finally( function()
  {
    test.case = 'try to rewrite folder with files';
    filePath = test.context.pathFor( 'written/dirMakeAsync/make_dir/file' );
    provider.filesDelete( routinePath );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath, ' ' );
    var con = provider.dirMake
    ({
      filePath : context.provider.path.dir( filePath ),
      sync : 0,
      recursive : 0,
      rewritingTerminal : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    provider.fileWrite( filePath, ' ' );
    var con = provider.dirMake
    ({
      filePath : context.provider.path.dir( filePath ),
      sync : 0,
      recursive : 0,
      rewritingTerminal : 0
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    provider.fileWrite( filePath, ' ' );
    return provider.dirMake
    ({
      filePath : context.provider.path.dir( filePath ),
      sync : 0,
      recursive : 1,
      rewritingTerminal : 1
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'make_dir' ] );
      return null;
    })
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'folders structure not exist';
    provider.filesDelete( routinePath );
    filePath = test.context.pathFor( 'written/dirMakeAsync/routinePath' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 0,
      rewritingTerminal : 0
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    var con = provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 0,
      rewritingTerminal : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    return provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 1,
      rewritingTerminal : 0
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'routinePath' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    return provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 1,
      rewritingTerminal : 1
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'routinePath' ] );
      return null;
    });
  })

  return consequence;
}

//

function hashReadSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if
  (
    !_.routineIs( provider.fileReadAct )
    ||  !_.routineIs( provider.statReadAct )
    || context.providerIsInstanceOf( _.FileProvider.Extract )
  )
  {
    test.identical( 1, 1 );
    return;
  }

  if( Config.interpreter === 'browser' )
  return;

  var routinePath = test.context.pathFor( 'read/hashRead' );
  var got, filePath, data;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  /* - */

  test.case = 'synchronous filehash';
  data = 'Excepteur sint occaecat cupidatat non proident';
  filePath = test.context.pathFor( 'read/hashRead/src.txt' );

  /**/

  provider.fileWrite( filePath, data );
  got = provider.hashRead( filePath );
  var md5sum = crypto.createHash( 'md5' );
  md5sum.update( data );
  var expected = md5sum.digest( 'hex' );
  test.identical( got, expected );

  /* - */

  test.case = 'invalid path';
  filePath = test.context.pathFor( 'invalid.txt' );

  /**/

  got = provider.hashRead
  ({
    filePath,
    throwing : 0
  });
  var expected = NaN;
  test.identical( got, expected );

  /*invalid path throwing enabled*/

  test.shouldThrowErrorSync( function( )
  {
    provider.hashRead
    ({
      filePath,
      sync : 1,
      throwing : 1
    });
  });

  /*invalid path throwing disabled*/

  test.mustNotThrowError( function( )
  {
    got = provider.hashRead
    ({
      filePath,
      sync : 1,
      throwing : 0
    });
    var expected = NaN;
    test.identical( got, expected );
  });

  /*is not terminal file*/

  test.shouldThrowErrorSync( function( )
  {
    provider.hashRead
    ({
      filePath : test.context.pathFor( '/' ),
      sync : 1,
      throwing : 1
    });
  });

  /*is not terminal file, throwing disabled*/

  test.mustNotThrowError( function( )
  {
    got = provider.hashRead
    ({
      filePath : test.context.pathFor( '/' ),
      sync : 1,
      throwing : 0
    });
    var expected = NaN;
    test.identical( got, expected );
  });

}

//

function hashReadAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if
  (
    !_.routineIs( provider.fileReadAct )
    || !_.routineIs( provider.statReadAct )
    || context.providerIsInstanceOf( _.FileProvider.Extract )
  )
  {
    test.identical( 1, 1 );
    return;
  }

  var routinePath = test.context.pathFor( 'read/hashReadAsync' );
  var got, filePath, data;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  if( Config.interpreter === 'browser' )
  return;

  var consequence = new _.Consequence().take( null );

  consequence

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'async filehash';
    data = 'Excepteur sint occaecat cupidatat non proident';
    filePath = test.context.pathFor( 'read/hashReadAsync/src.txt' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath, data );
    return provider.hashRead
    ({
      filePath,
      sync : 0,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      var md5sum = crypto.createHash( 'md5' );
      md5sum.update( data );
      var expected = md5sum.digest( 'hex' );
      test.identical( got, expected );
      return null;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'invalid path';
    filePath = test.context.pathFor( 'invalid.txt' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hashRead
    ({
      filePath,
      sync : 0,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      var expected = NaN;
      test.identical( got, expected );
      return null;
    });
  })

  /*invalid path throwing enabled*/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.hashRead
    ({
      filePath,
      sync : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /*invalid path throwing disabled*/

  .finally( function()
  {
    debugger;
    var con = provider.hashRead
    ({
      filePath,
      sync : 0,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      var expected = NaN;
      test.identical( got, expected );
      return null;
    });
  })

  /*is not terminal file*/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.hashRead
    ({
      filePath : test.context.pathFor( '/' ),
      sync : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /*is not terminal file, throwing disabled*/
  .finally( function()
  {
    var con = provider.hashRead
    ({
      filePath : test.context.pathFor( '/' ),
      sync : 0,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      var expected = NaN;
      test.identical( got, expected );
      return null;
    })

  })

  return consequence;
}

//

function dirReadSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.dirReadAct ) || !_.routineIs( provider.statReadAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var routinePath = test.context.pathFor( 'read/dirReadAct' );
  var got, filePath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  /* - */

  test.case = 'synchronous read';
  filePath = test.context.pathFor( 'read/dirRead/1.txt' );

  /* */

  provider.fileWrite( filePath, ' ' );
  var got = provider.dirRead( context.provider.path.dir( filePath ) );
  var expected = [ '1.txt' ];
  test.identical( got.sort(), expected.sort() );

  /* */

  provider.fileWrite( filePath, ' ' );
  var got = provider.dirRead
  ({
    filePath : context.provider.path.dir( filePath ),
    sync : 1,
    throwing : 1
  })
  var expected = [ '1.txt' ];
  test.identical( got.sort(), expected.sort() );

  /* - */

  test.case = 'synchronous, filePath points to file';
  filePath = test.context.pathFor( 'read/dirRead/1.txt' );

  /* */

  provider.fileWrite( filePath, ' ' )
  var got = provider.dirRead( filePath );
  var expected = [ '1.txt' ];
  test.identical( got, expected );

  /* */

  provider.fileWrite( filePath, ' ' )
  var got = provider.dirRead
  ({
    filePath,
    sync : 1,
    throwing : 1
  })
  var expected = [ '1.txt' ];
  test.identical( got, expected );

  /* - */

  test.case = 'path not exist';
  filePath = test.context.pathFor( 'non_existing_folder' );

  /* */

  var got = provider.dirRead( filePath );
  var expected = null;
  test.identical( got, expected );

  /* */

  var got = provider.dirRead( '/file/does/not/exist' );
  var expected = null;
  test.identical( got, expected );

  /* */

  test.shouldThrowErrorSync( function( )
  {
    provider.dirRead
    ({
      filePath,
      sync : 1,
      throwing : 1
    });
  })
}

//

function dirReadSyncOutputFormats( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.dirReadAct ) || !_.routineIs( provider.statReadAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var routinePath = test.context.pathFor( 'read/dirReadSyncOutputFormats' );
  var filePath = path.join( routinePath, 'file' );

  /* absolute */

  test.case = 'missing path';
  var got = provider.dirRead
  ({
    filePath,
    outputFormat : 'absolute'
  })
  test.identical( got, null );

  test.case = 'terminal';
  provider.fileWrite( filePath, filePath );
  var got = provider.dirRead
  ({
    filePath,
    outputFormat : 'absolute'
  })
  test.identical( got, [ filePath ] );

  test.case = 'directory';
  provider.fileWrite( filePath, filePath );
  var got = provider.dirRead
  ({
    filePath : routinePath,
    outputFormat : 'absolute'
  })
  test.identical( got, [ filePath ] );

  /* record */

  test.case = 'missing path';
  provider.filesDelete( routinePath );
  var got = provider.dirRead
  ({
    filePath,
    outputFormat : 'record'
  })
  test.identical( got, null);

  test.case = 'terminal';
  provider.fileWrite( filePath, filePath );
  var got = provider.dirRead
  ({
    filePath,
    outputFormat : 'record'
  })
  test.identical( got.length, 1 );
  test.is( got[ 0 ] instanceof _.FileRecord );
  test.identical( got[ 0 ].absolute, filePath );

  test.case = 'directory';
  provider.fileWrite( filePath, filePath );
  var got = provider.dirRead
  ({
    filePath : routinePath,
    outputFormat : 'record'
  })
  test.identical( got.length, 1 );
  test.is( got[ 0 ] instanceof _.FileRecord );
  test.identical( got[ 0 ].absolute, filePath );

  /* relative */

  test.case = 'missing path';
  provider.filesDelete( routinePath );
  var got = provider.dirRead
  ({
    filePath,
    outputFormat : 'relative'
  })
  test.identical( got, null );

  test.case = 'terminal';
  provider.fileWrite( filePath, filePath );
  var got = provider.dirRead
  ({
    filePath,
    outputFormat : 'relative'
  })
  test.identical( got, [ 'file' ] );

  test.case = 'directory';
  provider.fileWrite( filePath, filePath );
  var got = provider.dirRead
  ({
    filePath : routinePath,
    outputFormat : 'relative'
  })
  test.identical( got, [ 'file' ] );

  /* relative, diff basePath */

  var basePath = path.join( routinePath, 'baseDir' );

  test.case = 'missing path';
  provider.filesDelete( routinePath );
  var got = provider.dirRead
  ({
    filePath,
    outputFormat : 'relative',
    basePath
  })
  test.identical( got, null );

  test.case = 'terminal';
  provider.fileWrite( filePath, filePath );
  var got = provider.dirRead
  ({
    filePath,
    outputFormat : 'relative',
    basePath
  })
  test.identical( got, [ test.context.globalFromPreferred( '../file' ) ] );

  test.case = 'directory';
  provider.fileWrite( filePath, filePath );
  var got = provider.dirRead
  ({
    filePath : routinePath,
    outputFormat : 'relative',
    basePath
  })
  test.identical( got, [ test.context.globalFromPreferred( '../file' ) ] );

}

//

function dirReadAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.dirReadAct ) || !_.routineIs( provider.statReadAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var routinePath = test.context.pathFor( 'read/dirReadAsync' );
  var got, filePath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var consequence = new _.Consequence().take( null );

  consequence

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'synchronous read';
    filePath = test.context.pathFor( 'read/dirReadAsync/1.txt' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath, ' ' );
    return provider.dirRead
    ({
      filePath : context.provider.path.dir( filePath ),
      sync : 0,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      var expected = [ '1.txt' ];
      test.identical( got.sort(), expected.sort() );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath, ' ' );
    return provider.dirRead
    ({
      filePath : context.provider.path.dir( filePath ),
      sync : 0,
      throwing : 1
    })
    .ifNoErrorThen( function( got )
    {
      var expected = [ '1.txt' ];
      test.identical( got.sort(), expected.sort() );
      return null;
    })
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'synchronous, filePath points to file';
    filePath = test.context.pathFor( 'read/dirReadAsync/1.txt' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath, ' ' );
    return provider.dirRead
    ({
      filePath,
      sync : 0,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      var got = provider.dirRead( filePath );
      var expected = [ '1.txt' ];
      test.identical( got, expected );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath, ' ' );
    return provider.dirRead
    ({
      filePath,
      sync : 0,
      throwing : 1
    })
    .ifNoErrorThen( function( got )
    {
      var got = provider.dirRead( filePath );
      var expected = [ '1.txt' ];
      test.identical( got, expected );
      return null;
    })
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'path not exist';
    filePath = test.context.pathFor( 'non_existing_folder' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.dirRead
    ({
      filePath,
      sync : 0,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      var expected = null;
      test.identical( got, expected );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.dirRead
    ({
      filePath,
      sync : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con )
  })

  return consequence;
}

//

function fileWriteSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWrite ) )
  return;

  var isHd = test.context.providerIsInstanceOf( _.FileProvider.HardDrive );

  /*writeMode rewrite*/
  try
  {
    provider.dirMake
    ({
      filePath : test.context.pathFor( 'write_test' ),
      sync : 1
    })
  }
  finally
  {
  }
  // catch ( err ) { }

  /*writeMode rewrite*/
  var data = 'LOREM'
  test.case ='rewrite, file not exist ';
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    sync : 1
  });
  var expected = data;
  test.identical( got, expected )

  test.case ='rewrite existing file ';
  data = 'LOREM LOREM';
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    sync : 1
  });
  var expected = data;
  test.identical( got, expected );

  test.case = 'encoding : original.type, data: string';
  data = 'LOREM LOREM';
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    data,
    sync : 1,
    encoding : 'original.type'
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    encoding : 'original.type',
    sync : 1
  });
  var expected = data;
  if( isHd )
  expected = _.bufferBytesFrom( data );
  test.identical( got, expected );

  test.case = 'encoding : original.type, data: bytes buffer';
  data = new U8x( [ 97, 98, 99 ] );
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    data,
    sync : 1,
    encoding : 'original.type'
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    encoding : 'original.type',
    sync : 1
  });
  var expected = data;
  if( isHd )
  expected = _.bufferBytesFrom( data );
  test.identical( got, expected );

  test.case = 'encoding : original.type, data: array buffer';
  data = new U8x( [ 97, 98, 99 ] ).buffer;
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    data,
    sync : 1,
    encoding : 'original.type'
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    encoding : 'original.type',
    sync : 1
  });
  var expected = data;
  if( isHd )
  expected = _.bufferBytesFrom( data );
  test.identical( got, expected );

  if( isHd )
  {
    test.case = 'encoding : original.type, data: node buffer';
    data = BufferNode.from( [ 97, 98, 99 ] );
    provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test/dst.txt' ),
      data,
      sync : 1,
      encoding : 'original.type'
    });
    var got1 = provider.fileRead
    ({
      filePath : test.context.pathFor( 'write_test/dst.txt' ),
      encoding : 'original.type',
      sync : 1
    });
    expected = _.bufferBytesFrom( data );
    test.identical( got1, expected );
  }

  /* - */

  if( Config.debug )
  {
    test.case ='try write to non existing folder';
    test.shouldThrowErrorSync( function()
    {
      provider.fileWrite
      ({
        filePath : test.context.pathFor( 'unknown/dst.txt' ),
        data,
        sync : 1,
        makingDirectory : 0,
      });
    });

    test.case ='try to rewrite folder';
    test.shouldThrowErrorSync( function()
    {
      provider.fileWrite
      ({
        filePath : test.context.pathFor( 'write_test' ),
        data,
        sync : 1
      });
    });
  }

  /*writeMode append*/

  provider.filesDelete( test.context.pathFor( 'write_test/append.txt' ) );
  var data = 'APPEND';
  test.case ='append, file not exist ';
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/append.txt' ),
    data,
    writeMode : 'append',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/append.txt' ),
    sync : 1
  });
  var expected = data;
  test.identical( got, expected );

  test.case ='append, to file ';
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/append.txt' ),
    data,
    writeMode : 'append',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/append.txt' ),
    sync : 1
  });
  var expected = 'APPENDAPPEND';
  test.identical( got, expected );

  /* - */

  if( Config.debug )
  {
    test.case ='try append to non existing folder';
    test.shouldThrowErrorSync( function()
    {
      provider.fileWrite
      ({
        filePath : test.context.pathFor( 'unknown/dst.txt' ),
        data,
        writeMode : 'append',
        sync : 1,
        makingDirectory : 0
      });
    });

    test.case ='try to append to folder';
    test.shouldThrowErrorSync( function()
    {
      provider.fileWrite
      ({
        filePath : test.context.pathFor( 'write_test' ),
        data,
        writeMode : 'append',
        sync : 1
      });
    });
  }
  /*writeMode prepend*/

  provider.filesDelete( test.context.pathFor( 'write_test/prepend.txt' ) )
  var data = 'Lorem';
  test.case ='prepend, file not exist ';
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/prepend.txt' ),
    data,
    writeMode : 'prepend',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/prepend.txt' ),
    sync : 1
  });
  var expected = data;
  test.identical( got, expected );

  data = 'new text';
  test.case ='prepend to file ';
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/prepend.txt' ),
    data,
    writeMode : 'prepend',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/prepend.txt' ),
    sync : 1
  });
  var expected = 'new textLorem';
  test.identical( got, expected );

  /* - */

  if( Config.debug )
  {
    test.case ='try prepend to non existing folder';
    test.shouldThrowErrorSync( function()
    {
      provider.fileWrite
      ({
        filePath : test.context.pathFor( 'unknown/dst.txt' ),
        data,
        writeMode : 'prepend',
        sync : 1,
        makingDirectory : 0
      });
    });

    test.case ='try to prepend to folder';
    test.shouldThrowErrorSync( function()
    {
      provider.fileWrite
      ({
        filePath : test.context.pathFor( 'write_test' ),
        data,
        writeMode : 'prepend',
        sync : 1
      });
    });
  }

  /* - */

  test.case = 'native path, call fileWrite'
  var filePath = test.context.pathFor( 'write_test/file' );
  var o =
  {
    filePath : provider.path.nativize( filePath ),
    data,
    sync : 1
  }
  provider.fileWrite( o );
  test.identical( o.filePath, provider.path.preferredFromGlobal( filePath ) );
  test.identical( provider.fileRead( filePath ), data );

  /* - */

  if( Config.debug )
  if( process.platform === 'win32' )
  if( isHd )
  {
    test.case = 'native path, call fileWrite_body'
    var filePath2 = test.context.pathFor( 'write_test/file' );
    provider.filesDelete( filePath2 )
    var o2 =
    {
      data,
      sync : 1
    }
    var o2 =_.mapExtend( null, provider.fileWrite.body.defaults )
    o2.filePath2 = provider.path.nativize( filePath2 )
    o2.data = data;
    o2.sync = 1;
    test.shouldThrowErrorSync( () =>
    {
      provider.fileWrite.body.call( provider, o2 );
    })
    test.is( !provider.path.isNormalized( o2.filePath2 ) );
    test.is( !provider.fileExists( filePath2 ) );
  }


}

//

function fileWriteLinksSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWrite ) )
  return;

  var mp = _.routineJoin( test.context, test.context.pathFor );

  var dirPath = mp( 'write_test' );
  var srcPath = mp( 'write_test/src.txt' );
  var dstPath = mp( 'write_test/dst.txt' );
  var data;

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  /*writeMode rewrite*/

  /* - */

  provider.filesDelete( dirPath )

  test.case ='rewrite link file ';
  data = 'LOREM';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.hardLink( dstPath, srcPath )
  provider.fileWrite
  ({
    filePath : dstPath,
    data : data + data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( provider.isHardLink( dstPath ) );
  data = 'rewrite';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, data );
  test.is( provider.isHardLink( dstPath ) );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );

  /* - */

  provider.filesDelete( dirPath )

  test.case ='append link file ';
  data = 'LOREM';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.hardLink( dstPath, srcPath );
  provider.fileWrite
  ({
    filePath : dstPath,
    data,
    writeMode : 'append',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( provider.isHardLink( dstPath ) );
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    writeMode : 'append',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, data + data + data );
  test.is( provider.isHardLink( dstPath ) );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );

  /* - */

  provider.filesDelete( dirPath )

  test.case ='prepend link file ';
  data = 'LOREM';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.hardLink( dstPath, srcPath )
  provider.fileWrite
  ({
    filePath : dstPath,
    data,
    writeMode : 'prepend',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( provider.isHardLink( dstPath ) );
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    writeMode : 'prepend',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, data + data + data );
  test.is( provider.isHardLink( dstPath ) );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );

  if( !test.context.softLinkIsSupported() )
  return;

  /* soft link */

  provider.filesDelete( dirPath )

  test.case ='rewrite link file ';
  data = 'LOREM';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.softLink( dstPath, srcPath )
  provider.fileWrite
  ({
    filePath : dstPath,
    data : data + data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( provider.isSoftLink( dstPath ) );
  data = 'rewrite';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, data );
  test.is( provider.isSoftLink( dstPath ) );

  /* - */

  provider.filesDelete( dirPath )

  test.case ='rewrite link file ';
  data = 'LOREM';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.softLink( dstPath, srcPath )
  provider.fieldPush( 'resolvingSoftLink', 0 );
  provider.fileWrite
  ({
    filePath : dstPath,
    data : data + data,
    sync : 1
  });
  provider.fieldPop( 'resolvingSoftLink', 0 );
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( !provider.isSoftLink( dstPath ) );
  data = 'rewrite';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, expected );
  test.is( !provider.isSoftLink( dstPath ) );

  /* - */

  provider.filesDelete( dirPath )

  test.case ='append link file ';
  data = 'LOREM';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.softLink( dstPath, srcPath )
  provider.fieldPush( 'resolvingSoftLink', 0 );
  provider.fileWrite
  ({
    filePath : dstPath,
    data,
    writeMode : 'append',
    sync : 1
  });
  provider.fieldPop( 'resolvingSoftLink', 0 );
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( !provider.isSoftLink( dstPath ) );
  data = 'append';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, expected );
  test.is( !provider.isSoftLink( dstPath ) );

  /* - */

  provider.filesDelete( dirPath )

  test.case ='append link file ';
  data = 'LOREM';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.softLink( dstPath, srcPath )
  provider.fieldPush( 'resolvingSoftLink', 0 );
  provider.fileWrite
  ({
    filePath : dstPath,
    data,
    writeMode : 'prepend',
    sync : 1
  });
  provider.fieldPop( 'resolvingSoftLink', 0 );
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( !provider.isSoftLink( dstPath ) );
  data = 'prepend';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, expected );
  test.is( !provider.isSoftLink( dstPath ) );

  /* - */

  provider.filesDelete( dirPath )

  test.case ='append link file ';
  data = 'LOREM';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.softLink( dstPath, srcPath )
  provider.fileWrite
  ({
    filePath : dstPath,
    data,
    writeMode : 'append',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( provider.isSoftLink( dstPath ) );
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    writeMode : 'append',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, data + data + data );
  test.is( provider.isSoftLink( dstPath ) );

  /* - */

  provider.filesDelete( dirPath )

  test.case ='prepend link file ';
  data = 'LOREM';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.softLink( dstPath, srcPath )
  provider.fileWrite
  ({
    filePath : dstPath,
    data,
    writeMode : 'prepend',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( provider.isSoftLink( dstPath ) );
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    writeMode : 'prepend',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, data + data + data );
  test.is( provider.isSoftLink( dstPath ) );

}

//

function fileWriteAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWrite ) )
  return;

  let isHd = context.providerIsInstanceOf( _.FileProvider.HardDrive );
  var consequence = new _.Consequence().take( null )
  /*writeMode rewrite*/

  .finally( () =>
  {
    provider.filesDelete( test.context.pathFor( 'write_test' ) )
    provider.dirMake( test.context.pathFor( 'write_test' ) )
    return null;
  })

  /*writeMode rewrite*/
  var data = 'LOREM'
  consequence
  .ifNoErrorThen( function( arg )
  {
    test.case ='rewrite, file not exist ';
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test/dst.txt' ),
      data,
      sync : 0
    });

    return test.returnsSingleResource( con );
  })
  .then( ( got ) =>
  {
    var got = provider.fileRead
    ({
      filePath : test.context.pathFor( 'write_test/dst.txt' ),
      sync : 1
    });
    var expected = data;
    test.identical( got, expected )
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    test.case ='rewrite existing file ';
    data = 'LOREM LOREM';
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test/dst.txt' ),
      data,
      sync : 0
    });

    return test.returnsSingleResource( con );
  })
  .then( ( got ) =>
  {
    var got = provider.fileRead
    ({
      filePath : test.context.pathFor( 'write_test/dst.txt' ),
      sync : 1
    });
    var expected = data;
    test.identical( got, expected );
    return null;
  })
  .finally( function()
  {
    test.case ='try to rewrite folder';
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test' ),
      data,
      sync : 0,
      makingDirectory : 0
    });

    return test.shouldThrowErrorOfAnyKind( con );
  })
  /*writeMode append*/
  .finally( function()
  {
    return provider.filesDelete( test.context.pathFor( 'write_test/append.txt' ) );
  })
  .finally( function()
  {
    data = 'APPEND';
    test.case ='append, file not exist ';
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test/append.txt' ),
      data,
      writeMode : 'append',
      sync : 0
    });

    return test.returnsSingleResource( con );
  })
  .then( ( got ) =>
  {
    var got = provider.fileRead
    ({
      filePath : test.context.pathFor( 'write_test/append.txt' ),
      sync : 1
    });
    var expected = data;
    test.identical( got, expected );
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    test.case ='append, to file ';
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test/append.txt' ),
      data,
      writeMode : 'append',
      sync : 0
    });

    return test.returnsSingleResource( con );
  })
  .then( ( got ) =>
  {
    var got = provider.fileRead
    ({
      filePath : test.context.pathFor( 'write_test/append.txt' ),
      sync : 1
    });
    var expected = 'APPENDAPPEND';
    test.identical( got, expected );
    return null;
  })
  .finally( function()
  {
    test.case ='try to append to folder';
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test' ),
      data,
      writeMode : 'append',
      sync : 0
    });

    return test.shouldThrowErrorOfAnyKind( con );
  })

  /*writeMode prepend*/
  .finally( function()
  {
    return provider.filesDelete( test.context.pathFor( 'write_test/prepend.txt' ) );
  })
  .finally( function()
  {
    data = 'Lorem';
    test.case ='prepend, file not exist ';
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test/prepend.txt' ),
      data,
      writeMode : 'prepend',
      sync : 0
    });

    return test.returnsSingleResource( con );
  })
  .then( ( got ) =>
  {
    var got = provider.fileRead
    ({
      filePath : test.context.pathFor( 'write_test/prepend.txt' ),
      sync : 1
    });
    var expected = data;
    test.identical( got, expected );
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    data = 'new text';
    test.case ='prepend to file ';
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test/prepend.txt' ),
      data,
      writeMode : 'prepend',
      sync : 0
    });

    return test.returnsSingleResource( con );
  })
  .then( ( got ) =>
  {
    var got = provider.fileRead
    ({
      filePath : test.context.pathFor( 'write_test/prepend.txt' ),
      sync : 1
    });
    var expected = 'new textLorem';
    test.identical( got, expected );
    return null;
  })
  .finally( function()
  {
    test.case ='try prepend to folder';
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test' ),
      data,
      writeMode : 'prepend',
      sync : 0
    });

    return test.shouldThrowErrorOfAnyKind( con );
  })

  /* - */

  .finally( () =>
  {
    test.case = 'native path, call fileWrite'
    var filePath = test.context.pathFor( 'write_test/file' );
    var o =
    {
      filePath : provider.path.nativize( filePath ),
      data,
      sync : 0
    }
    return provider.fileWrite( o )
    .then( () =>
    {
      test.identical( o.filePath, provider.path.preferredFromGlobal( filePath ) );
      test.identical( provider.fileRead( filePath ), data );
      return null;
    })
  })

  /* - */

  if( Config.debug )
  if( process.platform === 'win32' )
  if( isHd )
  consequence.finally( () =>
  {
    test.case = 'native path, call fileWrite_body'
    var filePath = test.context.pathFor( 'write_test/file' );
    provider.filesDelete( filePath )
    var o =_.mapExtend( null, provider.fileWrite.body.defaults )
    o.filePath = provider.path.nativize( filePath )
    o.data = data;
    o.sync = 0;
    test.shouldThrowErrorOfAnyKind( () =>
    {
      return provider.fileWrite.body.call( provider, o );
    })
    test.is( !provider.path.isNormalized( o.filePath ) );
    test.is( !provider.fileExists( filePath ) );
    return null;
  })

  return consequence;
}

//

function fileWriteLinksAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWrite ) )
  return;

  var mp = _.routineJoin( test.context, test.context.pathFor );

  var dirPath = mp( 'write_test' );
  var srcPath = mp( 'write_test/src.txt' );
  var dstPath = mp( 'write_test/dst.txt' );
  var data;

  var softLinkIsSupported = test.context.softLinkIsSupported();

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  var con = new _.Consequence().take( null )

  /* - */

  .finally( function()
  {
    if( !softLinkIsSupported )
    return null;

    provider.filesDelete( dirPath )

    test.case ='rewrite link file ';
    data = 'LOREM';
    return provider.fileWrite
    ({
      filePath : srcPath,
      data,
      sync : 0
    })
    .finally( () =>
    {
      provider.softLink( dstPath, srcPath )
      return provider.fileWrite
      ({
        filePath : dstPath,
        data : data + data,
        sync : 0
      })
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      test.is( provider.isSoftLink( dstPath ) );
      return null;
    })
    .finally( () =>
    {
      data = 'rewrite';
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, data );
      test.is( provider.isSoftLink( dstPath ) );
      return null;
    })
  })

  /* - */

  .finally( function()
  {
    if( !softLinkIsSupported )
    return null;

    provider.filesDelete( dirPath )
    var expected;

    test.case ='rewrite link file ';
    data = 'LOREM';
    return provider.fileWrite
    ({
      filePath : srcPath,
      data,
      sync : 0
    })
    .finally( () =>
    {
      provider.softLink( dstPath, srcPath )
      provider.fieldPush( 'resolvingSoftLink', 0 );
      return provider.fileWrite
      ({
        filePath : dstPath,
        data : data + data,
        sync : 0
      })
    })
    .finally( () =>
    {
      provider.fieldPop( 'resolvingSoftLink', 0 );
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      expected = data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      expected = data + data;
      test.identical( got, expected );
      test.is( !provider.isSoftLink( dstPath ) );
      return null;
    })
    .finally( () =>
    {
      data = 'rewrite';
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, expected );
      test.is( !provider.isSoftLink( dstPath ) );
      return null;
    })
  })

  /* - */

  .finally( function()
  {
    if( !softLinkIsSupported )
    return null;

    provider.filesDelete( dirPath )
    var expected;

    test.case ='rewrite link file ';
    data = 'LOREM';
    return provider.fileWrite
    ({
      filePath : srcPath,
      data,
      sync : 0
    })
    .finally( () =>
    {
      provider.softLink( dstPath, srcPath )
      provider.fieldPush( 'resolvingSoftLink', 0 );
      return provider.fileWrite
      ({
        filePath : dstPath,
        data,
        writeMode : 'append',
        sync : 0
      })
    })
    .finally( () =>
    {
      provider.fieldPop( 'resolvingSoftLink', 0 );
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      expected = data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      expected = data + data;
      test.identical( got, expected );
      test.is( !provider.isSoftLink( dstPath ) );
      return null;
    })
    .finally( () =>
    {
      data = 'append';
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, expected );
      test.is( !provider.isSoftLink( dstPath ) );
      return null;
    })
  })

  /* - */

  .finally( function()
  {
    if( !softLinkIsSupported )
    return null;

    provider.filesDelete( dirPath )
    var expected;

    test.case ='rewrite link file ';
    data = 'LOREM';
    return provider.fileWrite
    ({
      filePath : srcPath,
      data,
      sync : 0
    })
    .finally( () =>
    {
      provider.softLink( dstPath, srcPath )
      provider.fieldPush( 'resolvingSoftLink', 0 );
      return provider.fileWrite
      ({
        filePath : dstPath,
        data,
        writeMode : 'prepend',
        sync : 0
      })
    })
    .finally( () =>
    {
      provider.fieldPop( 'resolvingSoftLink', 0 );
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      expected = data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      expected = data + data;
      test.identical( got, expected );
      test.is( !provider.isSoftLink( dstPath ) );
      return null;
    })
    .finally( () =>
    {
      data = 'prepend';
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, expected );
      test.is( !provider.isSoftLink( dstPath ) );
      return null;
    })
  })

  /* - */

  .finally( function()
  {
    provider.filesDelete( dirPath )

    test.case ='rewrite link file ';
    data = 'LOREM';
    return provider.fileWrite
    ({
      filePath : srcPath,
      data,
      sync : 0
    })
    .finally( () =>
    {
      provider.hardLink( dstPath, srcPath )
      return provider.fileWrite
      ({
        filePath : dstPath,
        data : data + data,
        sync : 0
      })
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      test.is( provider.isHardLink( dstPath ) );
      return null;
    })
    .finally( () =>
    {
      data = 'rewrite';
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, data );
      test.is( provider.isHardLink( dstPath ) );
      if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
      test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
      else
      test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
      return null;
    })
  })

  //append

  .finally( function()
  {
    if( !softLinkIsSupported )
    return null;

    provider.filesDelete( dirPath );

    var data;

    return _.time.out( 2000 )
    .finally( () =>
    {
      test.case ='append link file ';
      data = 'LOREM';
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      })
    })
    .finally( () =>
    {
      provider.softLink( dstPath, srcPath )
      return provider.fileWrite
      ({
        filePath : dstPath,
        data,
        writeMode : 'append',
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      test.is( provider.isSoftLink( dstPath ) );
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        writeMode : 'append',
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, data + data + data );
      test.is( provider.isSoftLink( dstPath ) );
      return null;
    })

  })
  .finally( function()
  {
    provider.filesDelete( dirPath );

    var data;

    return _.time.out( 2000 )
    .finally( () =>
    {
      test.case ='append link file ';
      data = 'LOREM';
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      })
    })
    .finally( () =>
    {
      provider.hardLink( dstPath, srcPath )
      return provider.fileWrite
      ({
        filePath : dstPath,
        data,
        writeMode : 'append',
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      test.is( provider.isHardLink( dstPath ) );
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        writeMode : 'append',
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, data + data + data );
      test.is( provider.isHardLink( dstPath ) );
      if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
      test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
      else
      test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
      return null;

    })

  })

  //prepend

  .finally( function()
  {
    if( !softLinkIsSupported )
    return null;

    provider.filesDelete( dirPath );

    var data;

    return _.time.out( 2000 )
    .finally( () =>
    {
      test.case ='append link file ';
      data = 'LOREM';
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      })
    })
    .finally( () =>
    {
      provider.softLink( dstPath, srcPath )
      return provider.fileWrite
      ({
        filePath : dstPath,
        data,
        writeMode : 'prepend',
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      test.is( provider.isSoftLink( dstPath ) );
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        writeMode : 'prepend',
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, data + data + data );
      test.is( provider.isSoftLink( dstPath ) );
      return null;
    })

  })
  .finally( function()
  {
    provider.filesDelete( dirPath );

    var data;

    return _.time.out( 2000 )
    .finally( () =>
    {
      test.case ='prepend link file ';
      data = 'LOREM';
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      })
    })
    .finally( () =>
    {
      provider.hardLink( dstPath, srcPath )
      return provider.fileWrite
      ({
        filePath : dstPath,
        data,
        writeMode : 'prepend',
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      test.is( provider.isHardLink( dstPath ) );
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        writeMode : 'prepend',
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, data + data + data );
      test.is( provider.isHardLink( dstPath ) );
      if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
      test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
      else
      test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
      return null;

    })

  })


  return con;
}

//

function softLinkSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLinkAct ) )
  {
    test.case = 'softLinkAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  if( !test.context.softLinkIsSupported() )
  {
    test.case = 'System does not allow to create soft links.';
    test.identical( 1, 1 )
    return;
  }

  var routinePath = test.context.pathFor( 'written/softLink' );
  var srcPath, dstPath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  /* - */

  test.case = 'make link sync';
  srcPath  = test.context.pathFor( 'written/softLink/link_test.txt' );
  dstPath = test.context.pathFor( 'written/softLink/link.txt' );
  provider.fileWrite( srcPath, '000' );

  /**/

  provider.softLink
  ({
    srcPath,
    dstPath,
    sync : 1,
  });
  provider.fileWrite
  ({
    filePath : srcPath,
    writeMode : 'append',
    data : 'new text',
    sync : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link.txt', 'link_test.txt' ] )
  provider.fieldPush( 'resolvingSoftLink', 1 );
  var got = provider.fileRead( dstPath );
  provider.fieldPop( 'resolvingSoftLink', 1 );
  var expected = '000new text';
  test.identical( got, expected );

  /* - */

  test.case = 'make for file that not exist';
  provider.filesDelete( routinePath );
  srcPath  = test.context.pathFor( 'written/softLink/no_file.txt' );
  dstPath = test.context.pathFor( 'written/softLink/link2.txt' );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.softLink
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1,
      throwing : 1
    });
  })

  /**/

  test.mustNotThrowError( function()
  {
    provider.softLink
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1,
      throwing : 0
    });
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, null );

  /* - */

  test.case = 'link already exists';
  srcPath = test.context.pathFor( 'written/softLink/link_test.txt' );
  dstPath = test.context.pathFor( 'written/softLink/link.txt' );
  provider.fileWrite( srcPath, 'abc' );
  provider.softLink
  ({
    srcPath,
    dstPath,
    rewriting : 1,
    throwing : 1,
    sync : 1,
  });

  /**/

  test.mustNotThrowError( function( )
  {
    provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 1,
    });
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link.txt', 'link_test.txt' ] )

  /**/

  test.mustNotThrowError( function( )
  {
    provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 0,
      sync : 1,
    });
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link.txt', 'link_test.txt' ] )

  /**/

  test.shouldThrowErrorSync( function( )
  {
    provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 1,
      sync : 1,
    });
  });

  /**/

  test.mustNotThrowError( function( )
  {
    provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 1,
    });
  });

  /* - */

  test.case = 'src is equal to dst';
  provider.filesDelete( routinePath );
  srcPath = test.context.pathFor( 'written/softLink/link_test.txt' );
  provider.fileWrite( srcPath, ' ' );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 1,
      throwing : 1,
      allowingMissed : 1
    });
  });
  test.identical( got, true );
  test.is( provider.isSoftLink( srcPath ) );

  /**/

  provider.fileDelete( srcPath );
  test.mustNotThrowError( function()
  {
    got = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      allowingMissed : 1,
      throwing : 1
    });
  });
  test.identical( got, true );
  test.is( provider.isSoftLink( srcPath ) );

  /**/

  provider.fileDelete( srcPath );
  test.mustNotThrowError( function()
  {
    got = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 1,
      allowingMissed : 1,
      throwing : 0
    });
  });
  test.identical( got, true );
  test.is( provider.isSoftLink( srcPath ) );

  /**/

  provider.fileDelete( srcPath );
  test.mustNotThrowError( function()
  {
    got = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      allowingMissed : 1,
      throwing : 0
    });
  });
  test.identical( got, true );
  test.is( provider.isSoftLink( srcPath ) );

  /**/

  provider.filesDelete( srcPath );
  test.shouldThrowErrorOfAnyKind( function()
  {
    got = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      allowingMissed : 0,
      throwing : 1
    });
  });
  test.is( !provider.isSoftLink( srcPath ) );

  /**/

  provider.filesDelete( srcPath );
  test.mustNotThrowError( function()
  {
    got = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      allowingMissed : 0,
      throwing : 0
    });
  });
  test.is( !provider.isSoftLink( srcPath ) );

  /* - */

  test.case = 'try make softLink to folder';
  provider.filesDelete( routinePath );
  srcPath = test.context.pathFor( 'written/softLink/link_test' );
  dstPath = test.context.pathFor( 'written/softLink/link' );
  provider.dirMake( srcPath );

  /**/

  provider.softLink
  ({
    srcPath,
    dstPath,
    rewriting : 1,
    throwing : 1,
    sync : 1,
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link', 'link_test' ]  );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 1,
      sync : 1,
    });
  })

  /**/

  debugger
  provider.softLink
  ({
    srcPath,
    dstPath,
    rewriting : 1,
    throwing : 0,
    sync : 1,
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link', 'link_test' ]  );

  /* - */

  test.open( 'allowingMissed' );

  provider.softLink
  ({
    srcPath : '../link_test',
    dstPath : srcPath,
    rewriting : 1,
    rewritingDirs : 1,
    throwing : 1,
    sync : 1,
    allowingMissed : 1
  });

  // if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
  //   test.shouldThrowErrorOfAnyKind(() =>
  //   {
  //     provider.pathResolveLinkFull({ filePath : srcPath, resolvingSoftLink : 1 });
  //   })
  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : srcPath, resolvingSoftLink : 1 });
  //   test.identical( got, srcPath )
  // }
  test.mustNotThrowError(() =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : srcPath,
      resolvingSoftLink : 1,
      allowingCycled : 1,
      throwing : 1
    });
  })

  test.mustNotThrowError(() =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : srcPath,
      resolvingSoftLink : 1,
      allowingCycled : 1,
      throwing : 0
    });
  })

  test.mustNotThrowError(() =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : srcPath,
      resolvingSoftLink : 1,
      allowingCycled : 0,
      throwing : 0
    });
  })

  test.shouldThrowErrorOfAnyKind(() =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : srcPath,
      resolvingSoftLink : 1,
      allowingCycled : 0,
      throwing : 1
    });
  })

  /* - */

  var notExistingPath = test.context.pathFor( 'written/softLink/notExisting' );
  provider.filesDelete( notExistingPath );
  provider.filesDelete( dstPath );
  provider.softLink
  ({
    srcPath : notExistingPath,
    dstPath,
    rewriting : 1,
    throwing : 0,
    sync : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
  // if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : dstPath,
      resolvingSoftLink : 1,
      allowingMissed : 0,
      throwing : 1
    });
  })

  provider.fileWrite( notExistingPath, notExistingPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 }).absolutePath;
  test.identical( got, notExistingPath );
  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  //   test.identical( got, notExistingPath );
  // }


  /* - */

  var notExistingPath = test.context.pathFor( 'written/softLink/notExisting' );
  provider.filesDelete( notExistingPath );
  provider.filesDelete( dstPath );
  provider.softLink
  ({
    srcPath : notExistingPath,
    dstPath,
    rewriting : 0,
    throwing : 1,
    sync : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
  // if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : dstPath,
      resolvingSoftLink : 1,
      allowingMissed : 0,
      throwing : 1
    });
  })
  provider.fileWrite( notExistingPath, notExistingPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 }).absolutePath;
  test.identical( got, notExistingPath );
  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  //   test.identical( got, notExistingPath );
  // }

  /* - */

  var notExistingPath = test.context.pathFor( 'written/softLink/notExisting' );
  provider.filesDelete( notExistingPath );
  provider.filesDelete( dstPath );
  provider.softLink
  ({
    srcPath : notExistingPath,
    dstPath,
    rewriting : 0,
    throwing : 0,
    sync : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
  // if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : dstPath,
      resolvingSoftLink : 1,
      allowingMissed : 0,
      throwing : 1
    });
  })
  provider.fileWrite( notExistingPath, notExistingPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 }).absolutePath;
  test.identical( got, notExistingPath );
  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  //   test.identical( got, notExistingPath );
  // }

  /* - */

  var notExistingPath = test.context.pathFor( 'written/softLink/notExisting' );
  provider.filesDelete( notExistingPath );
  provider.filesDelete( dstPath );
  provider.softLink
  ({
    srcPath : notExistingPath,
    dstPath,
    rewriting : 1,
    throwing : 1,
    sync : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
  // if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : dstPath,
      resolvingSoftLink : 1,
      allowingMissed : 0,
      throwing : 1
    });
  })
  provider.fileWrite( notExistingPath, notExistingPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 }).absolutePath;
  test.identical( got, notExistingPath );
  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  //   test.identical( got, notExistingPath );
  // }

  /* - */

  var notExistingPath = test.context.pathFor( 'written/softLink/notExisting' );
  provider.filesDelete( notExistingPath );
  provider.filesDelete( dstPath );
  test.mustNotThrowError( () =>
  {
    provider.softLink
    ({
      srcPath : notExistingPath,
      dstPath,
      rewriting : 1,
      throwing : 0,
      sync : 1,
      allowingMissed : 0
    });
  })

  test.is( !provider.isSoftLink( dstPath ) );

  /* - */

  var notExistingPath = test.context.pathFor( 'written/softLink/notExisting' );
  provider.filesDelete( notExistingPath );
  provider.filesDelete( dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      srcPath : notExistingPath,
      dstPath,
      rewriting : 0,
      throwing : 1,
      sync : 1,
      allowingMissed : 0
    });
  })

  test.is( !provider.isSoftLink( dstPath ) );

  /* - */

  var notExistingPath = test.context.pathFor( 'written/softLink/notExisting' );
  provider.filesDelete( notExistingPath );
  provider.filesDelete( dstPath );
  test.mustNotThrowError( () =>
  {
    provider.softLink
    ({
      srcPath : notExistingPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 1,
      allowingMissed : 0
    });
  })

  test.is( !provider.isSoftLink( dstPath ) );

  /* - */

  var notExistingPath = test.context.pathFor( 'written/softLink/notExisting' );
  provider.filesDelete( notExistingPath );
  provider.filesDelete( dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      srcPath : notExistingPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 1,
      allowingMissed : 0
    });
  })

  test.is( !provider.isSoftLink( dstPath ) );

  /* - */

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 0,
      throwing : 1,
      sync : 1,
      allowingMissed : 1
    });
  })

  /* - */

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 1,
      throwing : 1,
      sync : 1,
      allowingMissed : 0
    });
  })

  /* - */

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 0,
      throwing : 1,
      sync : 1,
      allowingMissed : 0
    });
  })

  /* - */

  test.mustNotThrowError( () =>
  {
    provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 0,
      throwing : 0,
      sync : 1,
      allowingMissed : 0
    });
  })

  test.close( 'allowingMissed' );

  /**/

  test.mustNotThrowError( function()
  {
    provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 1,
    });
  })
}

//

function softLinkAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLinkAct ) )
  {
    test.case = 'softLinkAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  if( !test.context.softLinkIsSupported() )
  {
    test.case = 'System does not allow to create soft links.';
    test.identical( 1, 1 )
    return;
  }

  var routinePath = test.context.pathFor( 'written/softLinkAsync' );
  var srcPath, dstPath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var consequence = new _.Consequence().take( null );
  consequence

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'make link async';
    srcPath  = test.context.pathFor( 'written/softLinkAsync/link_test.txt' );
    dstPath = test.context.pathFor( 'written/softLinkAsync/link.txt' );
    provider.fileWrite( srcPath, '000' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.softLink
    ({
      srcPath,
      dstPath,
      sync : 0,
    })
    .ifNoErrorThen( function( arg )
    {
      provider.fileWrite
      ({
        filePath : srcPath,
        writeMode : 'append',
        data : 'new text',
        sync : 1
      });
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link.txt', 'link_test.txt' ] )
      provider.fieldPush( 'resolvingSoftLink', 1 );
      var got = provider.fileRead( dstPath );
      provider.fieldPop( 'resolvingSoftLink', 1 );
      var expected = '000new text';
      test.identical( got, expected );
      return null;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'make for file that not exist';
    provider.filesDelete( routinePath );
    srcPath  = test.context.pathFor( 'written/softLinkAsync/no_file.txt' );
    dstPath = test.context.pathFor( 'written/softLinkAsync/link2.txt' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.softLink
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function( )
  {
    var con = provider.softLink
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, null );
      return null;
    })
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'link already exists';
    srcPath = test.context.pathFor( 'written/softLinkAsync/link_test.txt' );
    dstPath = test.context.pathFor( 'written/softLinkAsync/link.txt' );
    provider.fileWrite( srcPath, 'abc' );
    return provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 0,
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 0,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link.txt', 'link_test.txt' ] )
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 0,
      sync : 0,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link.txt', 'link_test.txt' ] )
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 1,
      sync : 0,
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    var con = provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 0,
    });
    return test.mustNotThrowError( con );
  })

  /* - */
  .ifNoErrorThen( function( arg )
  {
    test.case = 'src is equal to dst';
    provider.filesDelete( routinePath );
    srcPath = test.context.pathFor( 'written/softLinkAsync/link_test.txt' );
    provider.fileWrite( srcPath, ' ' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 1,
      allowingMissed : 1,
      throwing : 1
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      test.is( provider.isSoftLink( srcPath ) );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( srcPath );
    return provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 0,
      allowingMissed : 1,
      throwing : 1
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      test.is( provider.isSoftLink( srcPath ) );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( srcPath );
    return provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 1,
      allowingMissed : 1,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      test.is( provider.isSoftLink( srcPath ) );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( srcPath );
    return provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      allowingMissed : 1,
      rewriting : 0,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      test.is( provider.isSoftLink( srcPath ) );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( srcPath );
    return provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      allowingMissed : 0,
      rewriting : 0,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      test.is( !provider.isSoftLink( srcPath ) );
      return null;
    })
  })

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( srcPath );
    var con = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      allowingMissed : 0,
      rewriting : 0,
      throwing : 1
    })
    return test.shouldThrowErrorAsync( con )
    .ifNoErrorThen( function( got )
    {
      test.is( !provider.isSoftLink( srcPath ) );
      return null;
    })
  })

  /* - */

  .finally( function()
  {
    test.case = 'try make hardLink for folder';
    provider.filesDelete( routinePath );
    srcPath = test.context.pathFor( 'written/softLinkAsync/link_test' );
    dstPath = test.context.pathFor( 'written/softLinkAsync/link' );
    provider.dirMake( srcPath );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 0,
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link', 'link_test' ]  );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 1,
      sync : 0,
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    return provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 0,
      sync : 0,
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link', 'link_test' ]  );
      return null;
    })
  })

  /* - */

  .finally( () =>
  {
    test.open( 'allowingMissed' );
    provider.filesDelete( routinePath );
    provider.dirMakeForFile( srcPath );
    return null;
  })

  /* - */

  .finally( () =>
  {

    return provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 1,
      throwing : 1,
      sync : 0,
      allowingMissed : 1
    })
    .finally( () =>
    {
      var got = provider.pathResolveLinkFull({ filePath : srcPath, resolvingSoftLink : 1 });
      test.identical( got.absolutePath, srcPath )
      return null;
    })

  })

  .finally( () =>
  {
    let con = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 0,
      throwing : 1,
      sync : 0,
      allowingMissed : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );

  })

  .finally( () =>
  {
    let con = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 1,
      throwing : 1,
      sync : 0,
      allowingMissed : 0
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  .finally( () =>
  {
    let con = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 0,
      throwing : 1,
      sync : 0,
      allowingMissed : 0
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  .finally( () =>
  {
    let con = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 0,
      throwing : 0,
      sync : 0,
      allowingMissed : 0
    });
    return test.mustNotThrowError( con );
  })

  .finally( () =>
  {
    let con = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 1,
      throwing : 0,
      sync : 0,
      allowingMissed : 0
    });
    return test.mustNotThrowError( con );
  })

  .finally( () => test.close( 'allowingMissed' ) )

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 0,
    });
    return test.mustNotThrowError( con );
  })

  return consequence;
}

//

function softLinkRelativePath( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLinkAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/softLinkRelativePath' );
  let pathToDir = test.context.pathFor( 'written/softLinkRelativePath/dir' );
  let pathToFile = test.context.pathFor( 'written/softLinkRelativePath/file' );

  test.open( 'src - relative path to a file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( './../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '../../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( './../../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( './../../../file' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a/file' );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/a/b/c/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '../../../file' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a/file' );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/a/b/c/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( './.././a/b/c' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a/b/c' );
  provider.filesDelete( pathToFile2 );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '.././z/b/c' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/z/b/c' );
  provider.filesDelete( pathToFile2 );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '.\\..\\.\\z\\b\\c' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/z/b/c' );
  provider.filesDelete( pathToFile2 );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '..\\.\\z\\b\\c' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/z/b/c' );
  provider.filesDelete( pathToFile2 );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( './../a/b/c/../..' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( pathToFile2 );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '../a/b/c/../..' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( pathToFile2 );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '.\\..\\a\\b\\c\\..\\..' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( pathToFile2 );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '..\\a\\b\\c\\..\\..' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( pathToFile2 );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '..\\a\\b\\c\\..\\..' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  test.shouldThrowErrorOfAnyKind( () => provider.softLink( dstPath, srcPath ) );
  test.is( !provider.isSoftLink( dstPath ) );

  test.close( 'src - relative path to a file' );

  /* - */

  test.open( 'src - relative path to a dir' );

  provider.filesDelete( routinePath );
  provider.fileWrite( path.join( pathToDir, 'fileInDir' ), 'fileInDir' );
  provider.dirMake( pathToDir );

  var srcPath = test.context.globalFromPreferred( '../dir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got, [ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( './../dir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got, [ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '../../dir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath/dstDirLink' );
  provider.filesDelete( context.provider.path.dir( dstPath ) );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got, [ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( './../../dir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath/dstDirLink' );
  provider.filesDelete( context.provider.path.dir( dstPath ) );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got, [ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '../../../dir' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a/dir' );
  provider.filesDelete( context.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ), 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/a/b/c/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got, [ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( './../../../dir' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a/dir' );
  provider.filesDelete( context.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ), 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/a/b/c/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got, [ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  /* - */

  var srcPath = test.context.globalFromPreferred( './.././a/b/c' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a/b/c' );
  provider.filesDelete( context.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ), 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got, [ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '.././a/b/c' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a/b/c' );
  provider.filesDelete( context.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ), 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got, [ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '.\\..\\.\\a\\b\\c' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a/b/c' );
  provider.filesDelete( context.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ), 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got, [ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '..\\.\\a\\b\\c' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a/b/c' );
  provider.filesDelete( context.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ), 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got, [ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );


  var srcPath = test.context.globalFromPreferred( './../a/b/c/../..' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( context.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ), 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got, [ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '../a/b/c/../..' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( context.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ), 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got, [ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );


  var srcPath = test.context.globalFromPreferred( '.\\..\\a\\b\\c\\..\\..' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( context.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ), 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got, [ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );


  var srcPath = test.context.globalFromPreferred( '..\\a\\b\\c\\..\\..' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( context.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ), 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got, [ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '..\\a\\b\\c\\..\\..' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath );
  test.shouldThrowErrorOfAnyKind( () => provider.softLink( dstPath, srcPath ) );
  test.is( !provider.isSoftLink( dstPath ) );

  test.close( 'src - relative path to a dir' );

  test.open( 'dst - relative path to a file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );

  var srcPath = pathToFile;
  var dstPath = test.context.globalFromPreferred( '../dstFile' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = test.context.globalFromPreferred( './../dstFile' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = test.context.globalFromPreferred( './../../dstFile' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = test.context.globalFromPreferred( './../../dstFile' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = test.context.globalFromPreferred( '../a/b/dstFile' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.dirMakeForFile( dstPathResolved );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = test.context.globalFromPreferred( './../a/b/dstFile' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.dirMakeForFile( dstPathResolved );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );

  test.close( 'dst - relative path to a file' );

  /* - */

  test.open( 'dst - relative path to a dir' );

  provider.filesDelete( routinePath );
  provider.fileWrite( path.join( pathToDir, 'fileInDir' ), 'fileInDir' );
  provider.dirMake( pathToDir );

  var srcPath = pathToDir;
  var dstPath = test.context.globalFromPreferred( '../dstPath' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.dirRead({ filePath : dstPathResolved });
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = test.context.globalFromPreferred( './../dstPath' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.dirRead({ filePath : dstPathResolved });
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = test.context.globalFromPreferred( '../../dstPath' )
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.dirRead({ filePath : dstPathResolved });
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = test.context.globalFromPreferred( './../../dstPath' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.dirRead({ filePath : dstPathResolved });
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = test.context.globalFromPreferred( '../a/b/dstPath' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.dirMakeForFile( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.dirRead({ filePath : dstPathResolved });
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = test.context.globalFromPreferred( './../a/b/dstPath' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.dirMakeForFile( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.dirRead({ filePath : dstPathResolved });
  test.identical( got, [ 'fileInDir' ] );

  test.close( 'dst - relative path to a dir' );

  /* - */

  test.open( 'allowingMissed on, relative path to src' );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( dstPath );
  provider.softLink
  ({
    dstPath,
    srcPath,
    rewriting : 1,
    throwing : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
  // if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : dstPath,
      resolvingSoftLink : 1,
      allowingMissed : 0,
      throwing : 1
    })
  });
  provider.fileWrite( pathToFile, pathToFile );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );

  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  //   test.identical( got.absolutePath, pathToFile );
  // }
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( dstPath );
  provider.softLink
  ({
    dstPath,
    srcPath,
    rewriting : 0,
    throwing : 0,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
  // if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : dstPath,
      resolvingSoftLink : 1,
      allowingMissed : 0,
      throwing : 1
    })
  });
  provider.fileWrite( pathToFile, pathToFile );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );

  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  //   test.identical( got.absolutePath, pathToFile );
  // }
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( dstPath );
  provider.softLink
  ({
    dstPath,
    srcPath,
    rewriting : 1,
    throwing : 0,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
  // if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : dstPath,
      resolvingSoftLink : 1,
      allowingMissed : 0,
      throwing : 1
    })
  });
  provider.fileWrite( pathToFile, pathToFile );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );

  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  //   test.identical( got.absolutePath, pathToFile );
  // }
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( dstPath );
  provider.softLink
  ({
    dstPath,
    srcPath,
    rewriting : 0,
    throwing : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
  // if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : dstPath,
      resolvingSoftLink : 1,
      allowingMissed : 0,
      throwing : 1
    })
  });
  provider.fileWrite( pathToFile, pathToFile );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );

  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  //   test.identical( got.absolutePath, pathToFile );
  // }
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );

  test.close( 'allowingMissed on, relative path to src' );

  /* - */

  test.open( 'allowingMissed on, same path' );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = pathToFile;
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.softLink
  ({
    dstPath,
    srcPath,
    rewriting : 1,
    throwing : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : dstPath,
      resolvingSoftLink : 1,
      allowingCycled : 0,
      throwing : 1
    })
  });
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );

  /* - */

  var srcPath = pathToFile;
  var dstPath = test.context.globalFromPreferred( '../file' );
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.softLink
  ({
    dstPath,
    srcPath,
    rewriting : 1,
    throwing : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPathResolved ) );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : dstPath,
      resolvingSoftLink : 1,
      allowingCycled : 0,
      throwing : 1
    })
  });
  var got = provider.pathResolveSoftLink({ filePath : dstPathResolved/*, readLink : 1*/ });
  test.identical( got, srcPath );

  test.close( 'allowingMissed on, same path' );

  /* - */

  test.open( 'allowingMissed off, relative path to src' );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      dstPath,
      srcPath,
      rewriting : 1,
      throwing : 1,
      allowingMissed : 0
    });
  })
  test.is( !provider.isSoftLink( dstPath ) );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  test.mustNotThrowError( () =>
  {
    provider.softLink
    ({
      dstPath,
      srcPath,
      rewriting : 0,
      throwing : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.isSoftLink( dstPath ) );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  test.mustNotThrowError( () =>
  {
    provider.softLink
    ({
      dstPath,
      srcPath,
      rewriting : 1,
      throwing : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.isSoftLink( dstPath ) );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      dstPath,
      srcPath,
      rewriting : 0,
      throwing : 1,
      allowingMissed : 0
    });
  })
  test.is( !provider.isSoftLink( dstPath ) );

  test.close( 'allowingMissed off, relative path to src' );

  test.open( 'allowingMissed off, same path' );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = pathToFile;
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      dstPath,
      srcPath,
      rewriting : 1,
      throwing : 1,
      allowingMissed : 0
    });
  })
  test.is( !provider.isSoftLink( dstPath ) );

  var srcPath = pathToFile;
  var dstPath = test.context.globalFromPreferred( '../file' );
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      dstPath,
      srcPath,
      rewriting : 1,
      throwing : 1,
      allowingMissed : 0
    });
  })
  test.is( !provider.isSoftLink( dstPathResolved ) );

  test.close( 'allowingMissed off, same path' );
}

//

function fileReadAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRead ) )
  {
    test.identical( 1, 1 );
    return;
  }

  if( !test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var consequence = new _.Consequence().take( null );

  if( Config.interpreter === 'browser' )
  {
    test.identical( 1, 1 );
    return;
  }

  function encode( src, encoding )
  {
    return BufferNode.from( src ).toString( encoding );
  }

  function decode( src, encoding )
  {
    return BufferNode.from( src, encoding ).toString( 'utf8' );
  }

  var src = 'Excepteur sint occaecat cupidatat non proident';

  let testFile = test.context.pathFor( 'written/fileReadAsync/file' );
  provider.fileWrite( testFile, src );

  consequence
  .ifNoErrorThen( function( arg )
  {
    test.case ='read from file';
    var con = provider.fileRead
    ({
      filePath : testFile,
      sync : 0,
    });
    return test.returnsSingleResource( con );
  })
  .ifNoErrorThen( function( data )
  {
    var expected = src;
    // why slice ???
    // var got = data.slice( 0, expected.length );
    var got = data;
    test.identical( got, expected );
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    test.case ='read from file, encoding : ascii';
    var con = provider.fileRead
    ({
      filePath : testFile,
      sync : 0,
      encoding : 'ascii'
    });

    return test.returnsSingleResource( con );
  })
  .ifNoErrorThen( function( data )
  {
    var expected = encode( src, 'ascii' )
    var got = data.slice( 0, expected.length );
    test.identical( got, expected );
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    test.case ='read from file, encoding : utf16le';
    var con = provider.fileRead
    ({
      filePath : testFile,
      sync : 0,
      encoding : 'utf16le'
    });

    return test.returnsSingleResource( con );
  })
  .ifNoErrorThen( function( data )
  {
    var expected = encode( src, 'utf16le' )
    var got = data.slice( 0, expected.length );
    test.identical( got, expected );
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    test.case ='read from file, encoding : ucs2';
    var con = provider.fileRead
    ({
      filePath : testFile,
      sync : 0,
      encoding : 'ucs2'
    });

    return test.returnsSingleResource( con );
  })
  .ifNoErrorThen( function( data )
  {
    var expected = encode( src, 'ucs2' )
    var got = data.slice( 0, expected.length );
    test.identical( got, expected );
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    test.case ='read from file, encoding : base64';
    var con = provider.fileRead
    ({
      filePath : testFile,
      sync : 0,
      encoding : 'base64'
    });

    return test.returnsSingleResource( con );
  })
  .ifNoErrorThen( function( data )
  {
    var expected = src;
    data = decode( data, 'base64' );
    var got = data.slice( 0, expected.length );
    test.identical( got, expected );
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    test.case ='read from file, encoding : arraybuffer';
    var con = provider.fileRead
    ({
      filePath : testFile,
      sync : 0,
      encoding : 'buffer.raw'
    });

    return test.returnsSingleResource( con );
  })
  .ifNoErrorThen( function( data )
  {
    var expected = [ true, src ];
    var result  =
    BufferNode.from( data )
    .toString()
    .slice( 0, src.length );
    var got = [ _.bufferRawIs( data ), result ];
    test.identical( got, expected );
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    test.case ='read from file, encoding : buffer';
    var con = provider.fileRead
    ({
      filePath : testFile,
      sync : 0,
      encoding : 'buffer.node'
    });

    return test.returnsSingleResource( con );
  })
  .ifNoErrorThen( function( data )
  {
    var expected = [ true, src ];
    var result  =
    BufferNode.from( data )
    .toString()
    .slice( 0, src.length );
    var got = [ _.bufferNodeIs( data ), result ];
    test.identical( got, expected );
    return null;
  })

  return consequence;
}

//

function softLinkChain( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( 1, 1 );
    return
  }

  // var routinePath = path.tempOpen();
  var routinePath = test.context.pathFor( 'written/softLinkChain' );

  debugger;

  provider.dirMake( path.join( routinePath, 'a' ) );
  provider.fileWrite( path.join( routinePath, 'x' ), 'x' );
  provider.softLink( path.join( routinePath, 'a/b' ), '..' );
  provider.softLink( path.join( routinePath, 'a/c' ), '../../x' );

  test.description = 'resolve path';

  var expected = path.join( routinePath, 'a' );
  var got = provider.pathResolveLinkFull( path.join( routinePath, 'a/b' ) ).absolutePath;
  var stat = provider.statResolvedRead( got );
  test.is( !!stat );
  test.identical( got, expected );

  var expected = path.join( routinePath, 'x' );
  var got = provider.pathResolveLinkFull( path.join( routinePath, 'a/c' ) ).absolutePath;
  var stat = provider.statResolvedRead( got );
  test.is( !!stat );
  test.identical( got, expected );

  var expected = path.join( routinePath, 'x' );
  var got = provider.pathResolveLinkFull({ filePath : path.join( routinePath, 'a/b/c' ) }).absolutePath;
  var stat = provider.statResolvedRead( got );
  test.is( !!stat );
  test.identical( got, expected );

  // test.description = 'get stat';

  // var abStat = provider.statResolvedRead({ filePath : path.join( routinePath, 'a/b' ), resolvingSoftLink : 1 });
  // var acStat = provider.statResolvedRead({ filePath : path.join( routinePath, 'a/c' ), resolvingSoftLink : 1 });
  // var abcStat = provider.statResolvedRead({ filePath : path.join( routinePath, 'a/b/c' ), resolvingSoftLink : 1 });

  // test.is( !!abStat );
  // test.is( !!acStat );
  // test.is( !!abcStat );

  debugger;
}

//

function softLinkActSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLinkAct ) )
  {
    test.case = 'softLinkAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  var mp = _.routineJoin( test.context, test.context.pathFor );
  var routinePath = mp( 'hardLinkActSync' );

  var softLinkIsSupported = test.context.softLinkIsSupported();

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  if( !softLinkIsSupported )
  {
    test.case = 'symlinks are not allowed'
    test.identical( 1, 1 )
    return;
  }

  /* - */

  test.case = 'basic usage';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1,
    context : provider,
  }
  var expected = _.mapOwnKeys( o );
  provider.softLinkAct( o );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'no src';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.dirMakeForFile( dstPath );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1,
    context : provider,
  }
  var expected = _.mapOwnKeys( o );
  provider.softLinkAct( o );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'src is a directory';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath, 'src' );
  provider.dirMake( srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1,
    context : provider,
  }
  var expected = _.mapOwnKeys( o );
  provider.softLinkAct( o );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'src is a terminal, check link';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1,
    context : provider,
  }
  provider.softLinkAct( o );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );
  provider.fileWrite( dstPath, dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( srcFile, dstPath );
  provider.filesDelete( routinePath );

  test.case = 'src is a hard link, check link';
  provider.filesDelete( routinePath );
  var filePath = path.join( routinePath, 'file' );
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( filePath, filePath );
  provider.hardLink({ srcPath : filePath, dstPath : srcPath, sync : 1 });
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1,
    context : provider,
  }
  provider.softLinkAct( o );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );
  provider.fileWrite( dstPath, dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( srcFile, dstPath );
  var file = provider.fileRead( filePath );
  test.identical( srcFile, file );

  /* - */

  test.case = 'dst is a terminal';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1,
    context : provider,
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLinkAct( o )
  });
  test.is( !provider.isSoftLink( dstPath ) );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'dst is a hard link';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.fileWrite( srcPath, srcPath );
  provider.hardLink( dstPath, srcPath );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1,
    context : provider,
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLinkAct( o )
  });
  test.is( !provider.isSoftLink( dstPath ) );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
  var dstFile = provider.fileRead( dstPath );
  test.identical( dstFile, srcPath );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'dst is dir';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  var filePath = path.join( dstPath, 'terminal' )
  var filePath2 = path.join( dstPath, 'file2' )
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( filePath2, filePath2 );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1,
    context : provider,
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLinkAct( o )
  });
  var files = provider.dirRead( dstPath );
  var expected = [ 'file2', 'terminal' ];
  test.identical( files, expected );
  var file1 = provider.fileRead( filePath );
  var file2 = provider.fileRead( filePath2 );
  test.identical( file1, filePath );
  test.identical( file2, filePath2 );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'should not create folders structure for path';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'parent/dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1,
    context : provider,
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLinkAct( o );
  })
  test.is( !provider.fileExists( dstPath ) );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'should path nativize all paths in options map if needed by its own means';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1,
    context : provider,
  }

  var expected = _.mapExtend( null, o );

  if( !( provider instanceof _.FileProvider.System ) )
  if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  if( process.platform === 'win32' )
  expected.type = 'file'

  provider.softLinkAct( o );
  test.identical( o, expected );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1,
    context : provider,
  }
  var expected = _.mapOwnKeys( o );
  if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  expected.type = 'file'
  provider.softLinkAct( o );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'create link in not existing directory';
  provider.filesDelete( routinePath );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1,
    context : provider,
  }
  test.shouldThrowErrorSync( () => provider.softLinkAct( o ) );
  test.will = 'parent directory of dstPath must not be created';
  test.is( !provider.fileExists( path.dir( dstPath ) ) );

  /* - */

  test.case = 'use terminal as parent directory';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath2 = path.join( srcPath, 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    srcPath,
    dstPath : dstPath2,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath2,
    type : null,
    sync : 1,
    context : provider,
  }
  test.shouldThrowErrorSync( () => provider.softLinkAct( o ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath2 ) );

  /* - */

  if( !Config.debug )
  return;

  test.case = 'should assert that path is absolute';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.dirMakeForFile( dstPath );
  dstPath = path.relative( routinePath, dstPath );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLinkAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      type : null,
      sync : 1,
      context : provider,
    });
  })

  /* - */

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath, 'src' );;
  var dstPath = path.join( routinePath, 'dst' );

  /* sync option is missed */

  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    context : provider,
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLinkAct( o );
  });

  /* redundant option */

  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1,
    context : provider,
    redundant : 'redundant'
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLinkAct( o );
  });

  /* - */

  test.case = 'should expect normalized path, but not nativized';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1,
    context : provider,
  }
  var originalPath = provider.path.preferredFromGlobal( o.srcPath );
  o.srcPath = provider.path.nativize( o.srcPath );
  o.dstPath = provider.path.nativize( o.dstPath );
  if( !( provider instanceof _.FileProvider.System ) )
  {
    if( o.srcPath !== originalPath )
    {
      test.shouldThrowErrorOfAnyKind( () =>
      {
        provider.softLinkAct( o );
      })
    }
  }
  else
  {
    test.mustNotThrowError( () =>
    {
      provider.softLinkAct( o );
    })
  }

  provider.filesDelete( routinePath );

  /* - */

  test.case = 'should expect ready options map, no complex arguments preprocessing';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath : [ srcPath ],
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1,
    context : provider,
  }
  var expected = _.mapExtend( null, o );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLinkAct( o );
  })
  test.identical( o.srcPath, expected.srcPath );
}

//

function softLinkSoftLinkResolving( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLink ) )
  {
    test.identical( 1, 1 );
    return;
  }

  /*

  resolvingSrcSoftLink : [ 0, 1 ]
  resolvingDstSoftLink : [ 0, 1 ]
  link : [ normal, double, broken, context cycled, cycled, dst and src resolving to the same file ]

  */

  function softLink( o )
  {
    let o2 =
    {
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1
    }
    _.mapSupplement( o, o2 )
    return provider.softLink( o );
  }

  let routinePath = test.context.pathFor( 'written/fileRenameSoftLinkResolving' );
  let srcPath = provider.path.join( routinePath, 'src' );
  let srcPath2 = provider.path.join( routinePath, 'src2' );
  let dstPath = provider.path.join( routinePath, 'dst' );
  let dstPath2 = provider.path.join( routinePath, 'dst2' );
  let srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  let dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );

  /**/

  test.open( 'normal' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  test.close( 'normal' );

  /**/

  test.open( 'double' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath2 ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath2 ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  /* - */

  test.close( 'double' );

  /**/

  test.open( 'broken' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'broken' );

  /**/

  test.open( 'context cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'context cycled' );

  /* */

  test.open( 'cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, srcPath )

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'cycled' );

  /**/

  test.open( 'links to same file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, srcPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPathTerminal ), srcPath );
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( srcPath ) )
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( dstPath ) )

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1, allowingMissed : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, srcPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal )
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal )
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( srcPath ) )
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( dstPath ) )

  test.close( 'links to same file' );
}

//

function softLinkRelativeLinkResolving( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLink ) )
  {
    test.identical( 1, 1 );
    return;
  }

  /*

  resolvingSrcSoftLink : [ 0, 1 ]
  resolvingDstSoftLink : [ 0, 1 ]
  link : [ normal, double, broken, context cycled, cycled, dst and src resolving to the same file ]

  */

  function softLink( o )
  {
    let o2 =
    {
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1
    }
    _.mapSupplement( o, o2 )
    return provider.softLink( o );
  }

  let routinePath = test.context.pathFor( 'written/softLinkRelativeLinkResolving' );
  let srcPath = provider.path.join( routinePath, 'src' );
  let srcPath2 = provider.path.join( routinePath, 'src2' );
  let srcPathRelative2 = provider.path.relative( srcPath, srcPath2 );
  let dstPath = provider.path.join( routinePath, 'dst' );
  let dstPath2 = provider.path.join( routinePath, 'dst2' );
  let dstPathRelative2 = provider.path.relative( dstPath, dstPath2 );
  let srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  let srcPathRelativeTerminal = provider.path.relative( srcPath, srcPathTerminal );
  let dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );
  let dstPathRelativeTerminal = provider.path.relative( dstPath, dstPathTerminal );

  /**/

  test.open( 'normal' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathRelativeTerminal );
  provider.softLink( dstPath, dstPathRelativeTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathRelativeTerminal );
  provider.softLink( dstPath, dstPathRelativeTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathRelativeTerminal );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathRelativeTerminal );
  provider.softLink( dstPath, dstPathRelativeTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathRelativeTerminal );
  provider.softLink( dstPath, dstPathRelativeTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathRelativeTerminal );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  test.close( 'normal' );

  /**/

  test.open( 'double' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathRelativeTerminal );
  provider.softLink( srcPath, srcPathRelative2 );
  provider.softLink( dstPath2, dstPathRelativeTerminal );
  provider.softLink( dstPath, dstPathRelative2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelative2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathRelativeTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath2 ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathRelativeTerminal );
  provider.softLink( srcPath, srcPathRelative2 );
  provider.softLink( dstPath2, dstPathRelativeTerminal );
  provider.softLink( dstPath, dstPathRelative2 );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelative2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathRelativeTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath2 ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathRelativeTerminal );
  provider.softLink( srcPath, srcPathRelative2 );
  provider.softLink( dstPath2, dstPathRelativeTerminal );
  provider.softLink( dstPath, dstPathRelative2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelative2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelative2 );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathRelativeTerminal );
  provider.softLink( srcPath, srcPathRelative2 );
  provider.softLink( dstPath2, dstPathRelativeTerminal );
  provider.softLink( dstPath, dstPathRelative2 );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelative2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelative2 );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathRelativeTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  /* - */

  test.close( 'double' );

  /**/

  test.open( 'broken' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathRelativeTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathRelativeTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathRelativeTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathRelativeTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelativeTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathRelativeTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathRelativeTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathRelativeTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathRelativeTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelativeTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'broken' );

  /**/

  test.open( 'context cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'context cycled' );

  /* */

  test.open( 'cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathRelative2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathRelative2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), test.context.globalFromPreferred( '../dst' ) );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, srcPath );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathRelative2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathRelative2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelative2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelative2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathRelative2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathRelative2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelative2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathRelative2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathRelative2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelative2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelative2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'cycled' );

  /**/

  test.open( 'links to same file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathRelativeTerminal );
  provider.softLink( dstPath, srcPathRelativeTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathRelativeTerminal );
  provider.softLink( dstPath, srcPathRelativeTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathRelativeTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathRelativeTerminal );
  provider.softLink( dstPath, srcPathRelativeTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, srcPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPathTerminal ), srcPath );
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( srcPath ) )
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( dstPath ) )

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathRelativeTerminal );
  provider.softLink( dstPath, srcPathRelativeTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1, allowingMissed : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, srcPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( srcPath ) )
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( dstPath ) )

  test.close( 'links to same file' );
}

//

function softLinkMakeAndResolve( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = context.pathFor( 'written/softLinkMakeAndResolve' );
  let filePath = context.pathFor( 'written/softLinkMakeAndResolve/file' );
  let linkPath = context.pathFor( 'written/softLinkMakeAndResolve/link' );
  let linkPath2 = context.pathFor( 'written/softLinkMakeAndResolve/link' );

  test.case = 'absolute to missing'
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1 });
  var resolved = provider.pathResolveSoftLink( linkPath );
  test.identical( resolved, filePath );

  test.case = 'absolute to terminal'
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1 });
  var resolved = provider.pathResolveSoftLink( linkPath );
  test.identical( resolved, filePath );

  test.case = 'absolute to absolute to terminal'
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1 });
  var resolved = provider.pathResolveSoftLink( linkPath );
  test.identical( resolved, linkPath2 );

  test.case = 'absolute to dir'
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  var dirPath = context.pathFor( 'written/softLinkMakeAndResolve/dir' );
  provider.dirMake( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : dirPath, allowingMissed : 1 });
  var resolved = provider.pathResolveSoftLink( linkPath );
  test.identical( resolved, dirPath );

  test.case = 'relative to missing'
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1 });
  var resolved = provider.pathResolveSoftLink( linkPath );
  test.identical( resolved, test.context.globalFromPreferred( '../file' ) );

  test.case = 'context link'
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1 });
  var resolved = provider.pathResolveSoftLink( linkPath );
  test.identical( resolved, test.context.globalFromPreferred( '../link' ) );

  test.case = 'two relative links in chain'
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath2, srcPath : '../file', allowingMissed : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : '../link2', allowingMissed : 1 });
  var resolved = provider.pathResolveSoftLink( linkPath );
  test.identical( resolved, test.context.globalFromPreferred( '../link2' ) );

  test.case = 'relative to dir'
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  var dirPath = context.pathFor( 'written/softLinkMakeAndResolve/dir' );
  provider.dirMake( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../dir', allowingMissed : 1 });
  var resolved = provider.pathResolveSoftLink( linkPath );
  test.identical( resolved, test.context.globalFromPreferred( '../dir' ) );

  test.case = 'path contains link to empty dir'
  provider.filesDelete( routinePath );
  var dirPath = context.pathFor( 'written/softLinkMakeAndResolve/dir' );
  provider.dirMake( dirPath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : dirPath, allowingMissed : 1 });
  var pathToResolve = provider.path.join( routinePath, 'link/file' );
  var resolved = provider.pathResolveSoftLink( pathToResolve );
  var expected = provider.path.join( dirPath, 'file' );
  test.identical( resolved, pathToResolve );

  test.case = 'path contains link to dir with terminal'
  provider.filesDelete( routinePath );
  var dirPath = context.pathFor( 'written/softLinkMakeAndResolve/dir' );
  var fileInDir = context.pathFor( 'written/softLinkMakeAndResolve/dir/file' );
  provider.fileWrite( fileInDir, fileInDir );
  provider.softLink({ dstPath : linkPath, srcPath : dirPath, allowingMissed : 1 });
  var pathToResolve = provider.path.join( routinePath, 'link/file' );

  test.is( provider.fileExists( pathToResolve ) );

  var stat = provider.statRead( pathToResolve );
  test.is( stat.isFile() )

  var resolved = provider.pathResolveSoftLink( pathToResolve );
  var expected = pathToResolve;
  test.identical( resolved, expected );
}

//

function softLinkResolvingBasic( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLink ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/softLinkResolvingBasic' );
  let src1Path = test.context.pathFor( 'written/softLinkResolvingBasic/src1' );
  let src2Path = test.context.pathFor( 'written/softLinkResolvingBasic/src2' );
  let src3Path = test.context.pathFor( 'written/softLinkResolvingBasic/src3' );
  let dstPath = test.context.pathFor( 'written/softLinkResolvingBasic/dst' );

  /*
      src1 -> src2 -> src3
      resolvingSrcSoftLink : 0
      softLink
        - soft link dst -> src1

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 1
      softLink
        - soft link dst -> src3

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 2
      softLink
        - soft link dst -> src3
  */

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src3Path );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src3Path );

  /* textLink */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, src3Path );
  provider.textLink( src1Path, src2Path );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, src3Path );
  provider.textLink( src1Path, src2Path );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src3Path );

  test.case = 'resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, src3Path );
  provider.textLink( src1Path, src2Path );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 2 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src3Path );

  provider.fieldPop( 'usingTextLink', 1 );
}

//

function softLinkGlobal( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( provider instanceof _.FileProvider.System )
  {
    test.identical( 1, 1 )
    return;
  }

  let routinePath = test.context.pathFor( 'written/softLinkGlobal' );
  let srcPath = test.context.pathFor( 'written/softLinkGlobal/src' );
  let dstPath = test.context.pathFor( 'written/softLinkGlobal/dst' );

  var srcPathDefault = path.globalFromPreferred( srcPath );
  var dstPathDefault = path.globalFromPreferred( dstPath );

  var srcPathSecond = 'second://' + srcPath;
  var dstPathSecond = 'second://' + dstPath;

  var dstPathUnknown = 'unknown://' + dstPath;

  /*  */

  test.open( 'with system' );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPathDefault, srcPathDefault );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPathSecond, srcPathSecond );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.softLink( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.close( 'with system' );

  /*  */

  test.open( 'without system' );

  context.system.providerUnregister( provider );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPathDefault, srcPathDefault );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPathSecond, srcPathSecond );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.softLink( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  context.system.providerRegister( provider );

  test.close( 'without system' );

}

//

function softLinkRelativeSoftLinking( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLink ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/softLinkRelativeSoftLinking' );
  let src1Path = test.context.pathFor( 'written/softLinkRelativeSoftLinking/src1' );
  let src2Path = test.context.pathFor( 'written/softLinkRelativeSoftLinking/src2' );
  let src3Path = test.context.pathFor( 'written/softLinkRelativeSoftLinking/src3' );
  let dstPath = test.context.pathFor( 'written/softLinkRelativeSoftLinking/dst' );

  /*
    src1 -> ../src2
    softLink dst src1
    resolvingSrcSoftLink : 0
    - link dst -> src1

    src1 -> ../src2
    softLink dst src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 -> ../src2
    softLink dst ../src1
    resolvingSrcSoftLink : 0
    - link dst -> ../src1

    src1 -> ../src2
    softLink dst ../src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 as :
    - missing file
    - link

    src2 as :
    - terminal
    - intermediate link
    - missing

  */

  /* src1 missing */

  test.case = '../src1 is missing, allowingMissed:0';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.softLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = '../src1 is missing, allowingMissed:1';
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    srcPath : '../src1',
    dstPath,
    resolvingSrcSoftLink : 0,
    resolvingSrcTextLink : 0,
    makingDirectory : 1,
    allowingMissed : 1
  });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  /* */

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  /* missing absolute src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.softLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.softLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  /* missing relative src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.softLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.softLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  /* chain */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  /*  */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );
}

//

function softLinkRelativeTextLinking( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLink ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/softLinkRelativeTextLinking' );
  let src1Path = test.context.pathFor( 'written/softLinkRelativeTextLinking/src1' );
  let src2Path = test.context.pathFor( 'written/softLinkRelativeTextLinking/src2' );
  let src3Path = test.context.pathFor( 'written/softLinkRelativeTextLinking/src3' );
  let dstPath = test.context.pathFor( 'written/softLinkRelativeTextLinking/dst' );

  /*
    src1 -> ../src2
    softLink dst src1
    resolvingSrcTextLink : 0
    - link dst -> src1

    src1 -> ../src2
    softLink dst src1
    resolvingSrcTextLink : 1
    - link dst -> ../src2

    src1 -> ../src2
    softLink dst ../src1
    resolvingSrcTextLink : 0
    - link dst -> ../src1

    src1 -> ../src2
    softLink dst ../src1
    resolvingSrcTextLink : 1
    - link dst -> ../src2

    src1 as :
    - missing file
    - link

    src2 as :
    - terminal
    - intermediate link
    - missing

  */

  provider.fieldPush( 'usingTextLink', 1 )

  /* src1 missing */

  test.case = '../src1 is missing, allowingMissed:0';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.softLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcTextLink : 0,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = '../src1 is missing, allowingMissed:1';
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    srcPath : '../src1',
    dstPath,
    resolvingSrcTextLink : 0,
    resolvingSrcSoftLink : 0,
    makingDirectory : 1,
    allowingMissed : 1
  });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  /* */

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  /* missing absolute src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0, allowingMissed : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.softLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcTextLink : 1,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.softLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcTextLink : 2,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  /* missing relative src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0, allowingMissed : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.softLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcTextLink : 1,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.softLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcTextLink : 2,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  /* chain */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  /*  */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  /*  */

  provider.fieldPop( 'usingTextLink', 1 )

}

//

function softLinkToParentDirectorySync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLinkAct ) )
  {
    test.case = 'softLinkAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  if( !test.context.softLinkIsSupported() )
  {
    test.case = 'System does not allow to create soft links.';
    test.identical( 1, 1 )
    return;
  }

  var routinePath = test.context.pathFor( 'written/softLinkToParentDirectorySync' );
  var srcPath, dstPath, dst2Path;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath )

  test.case = 'absolute paths';
  srcPath  = test.context.pathFor( 'written/softLinkToParentDirectorySync/dir' );
  dstPath  = test.context.pathFor( 'written/softLinkToParentDirectorySync/dir/link' );
  provider.dirMake( srcPath );
  provider.softLink
  ({
    srcPath,
    dstPath,
    sync : 1,
  });
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  srcPath );

  test.case = 'dst relative';
  srcPath  = test.context.pathFor( 'written/softLinkToParentDirectorySync/dir' );
  dstPath  = test.context.pathFor( 'written/softLinkToParentDirectorySync/dir/link' );
  provider.dirMake( srcPath );
  provider.softLink
  ({
    srcPath,
    dstPath : './link',
    sync : 1,
  });
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  srcPath );

  test.case = 'src relative';
  srcPath  = test.context.pathFor( 'written/softLinkToParentDirectorySync/dir' );
  dstPath  = test.context.pathFor( 'written/softLinkToParentDirectorySync/dir/link' );
  provider.dirMake( srcPath );
  provider.softLink
  ({
    srcPath : '..',
    dstPath,
    sync : 1,
  });
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '..' ) );

  test.case = 'dir -> link -> link';
  srcPath  = test.context.pathFor( 'written/softLinkToParentDirectorySync/dir' );
  dstPath  = test.context.pathFor( 'written/softLinkToParentDirectorySync/dir/link' );
  dst2Path  = test.context.pathFor( 'written/softLinkToParentDirectorySync/dir/link/link2' );
  provider.dirMake( srcPath );
  provider.softLink
  ({
    srcPath,
    dstPath,
    sync : 1,
  });
  provider.softLink
  ({
    srcPath : dstPath,
    dstPath : dst2Path,
    sync : 1,
  });
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dst2Path ) );
  test.is( provider.isDir( srcPath ) );
  test.identical( provider.pathResolveSoftLink( dst2Path ), dstPath  );
  test.identical( provider.pathResolveLinkFull( dst2Path ).filePath, srcPath );

  test.case = 'dir -> link -> link, relative paths';
  srcPath  = test.context.pathFor( 'written/softLinkToParentDirectorySync/dir' );
  dstPath  = test.context.pathFor( 'written/softLinkToParentDirectorySync/dir/link' );
  dst2Path  = test.context.pathFor( 'written/softLinkToParentDirectorySync/dir/link/link2' );
  provider.dirMake( srcPath );
  provider.softLink
  ({
    srcPath : '..',
    dstPath,
    sync : 1,
  });
  provider.softLink
  ({
    srcPath : '..',
    dstPath : dst2Path,
    sync : 1,
  });
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dst2Path ) );
  test.is( provider.isDir( srcPath ) );
  test.identical( provider.pathResolveSoftLink( dst2Path ), test.context.globalFromPreferred( '..' )  );
  test.identical( provider.pathResolveLinkFull( dst2Path ).filePath, srcPath  );

  test.case = 'dir -> link -> link';
  srcPath  = test.context.pathFor( 'written/softLinkToParentDirectorySync/dir' );
  dstPath  = test.context.pathFor( 'written/softLinkToParentDirectorySync/dir/link' );
  dst2Path  = test.context.pathFor( 'written/softLinkToParentDirectorySync/dir/link/link2' );
  provider.dirMake( srcPath );
  provider.softLink
  ({
    srcPath,
    dstPath,
    sync : 1,
  });
  provider.softLink
  ({
    srcPath : dstPath,
    dstPath : dst2Path,
    resolvingSrcSoftLink : 1,
    sync : 1,
  });
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dst2Path ) );
  test.is( provider.isDir( srcPath ) );
  test.identical( provider.pathResolveSoftLink( dst2Path ), srcPath  );
  test.identical( provider.pathResolveLinkFull( dst2Path ).filePath, srcPath );
}

//

function softLinkToParentDirectoryAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLinkAct ) )
  {
    test.case = 'softLinkAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  if( !test.context.softLinkIsSupported() )
  {
    test.case = 'System does not allow to create soft links.';
    test.identical( 1, 1 )
    return;
  }

  var routinePath = test.context.pathFor( 'written/softLinkToParentDirectoryAsync' );
  var srcPath, dstPath, dst2Path;
  var con = new _.Consequence().take( null )

  .then( () =>
  {
    if( !provider.statResolvedRead( routinePath ) )
    provider.dirMake( routinePath )
    return null;
  })

  .then( () =>
  {
    test.case = 'absolute paths';
    srcPath  = test.context.pathFor( 'written/softLinkToParentDirectoryAsync/dir' );
    dstPath  = test.context.pathFor( 'written/softLinkToParentDirectoryAsync/dir/link' );
    provider.dirMake( srcPath );
    return provider.softLink
    ({
      srcPath,
      dstPath,
      sync : 0,
    })
    .then( () =>
    {
      test.is( provider.isSoftLink( dstPath ) );
      test.is( provider.isDir( srcPath ) );
      test.identical( provider.pathResolveSoftLink( dstPath ),  srcPath );
      return null;
    })
  })

  .then( () =>
  {
    test.case = 'absolute paths';
    srcPath  = test.context.pathFor( 'written/softLinkToParentDirectoryAsync/dir' );
    dstPath  = test.context.pathFor( 'written/softLinkToParentDirectoryAsync/dir/link' );
    provider.dirMake( srcPath );
    return provider.softLink
    ({
      srcPath,
      dstPath,
      sync : 0,
    })
    .then( () =>
    {
      test.is( provider.isSoftLink( dstPath ) );
      test.is( provider.isDir( srcPath ) );
      test.identical( provider.pathResolveSoftLink( dstPath ),  srcPath );
      return null;
    })
  })

  .then( () =>
  {
    test.case = 'dst relative';
    srcPath  = test.context.pathFor( 'written/softLinkToParentDirectoryAsync/dir' );
    dstPath  = test.context.pathFor( 'written/softLinkToParentDirectoryAsync/dir/link' );
    provider.dirMake( srcPath );
    return provider.softLink
    ({
      srcPath,
      dstPath : './link',
      sync : 0,
    })
    .then( () =>
    {
      test.is( provider.isSoftLink( dstPath ) );
      test.is( provider.isDir( srcPath ) );
      test.identical( provider.pathResolveSoftLink( dstPath ),  srcPath );
      return null;
    })
  })

  .then( () =>
  {
    test.case = 'src relative';
    srcPath  = test.context.pathFor( 'written/softLinkToParentDirectoryAsync/dir' );
    dstPath  = test.context.pathFor( 'written/softLinkToParentDirectoryAsync/dir/link' );
    provider.dirMake( srcPath );
    return provider.softLink
    ({
      srcPath : '..',
      dstPath,
      sync : 0,
    })
    .then( () =>
    {
      test.is( provider.isSoftLink( dstPath ) );
      test.is( provider.isDir( srcPath ) );
      test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '..' ) );
      return null;
    })
  })

  .then( () =>
  {
    test.case = 'dir -> link -> link';
    srcPath  = test.context.pathFor( 'written/softLinkToParentDirectoryAsync/dir' );
    dstPath  = test.context.pathFor( 'written/softLinkToParentDirectoryAsync/dir/link' );
    dst2Path  = test.context.pathFor( 'written/softLinkToParentDirectoryAsync/dir/link/link2' );
    provider.dirMake( srcPath );
    return provider.softLink
    ({
      srcPath,
      dstPath,
      sync : 0,
    })
    .then( () =>
    {
      return provider.softLink
      ({
        srcPath : dstPath,
        dstPath : dst2Path,
        sync : 0,
      });
    })
    .then( () =>
    {
      test.is( provider.isSoftLink( dstPath ) );
      test.is( provider.isSoftLink( dst2Path ) );
      test.is( provider.isDir( srcPath ) );
      test.identical( provider.pathResolveSoftLink( dst2Path ), dstPath  );
      test.identical( provider.pathResolveLinkFull( dst2Path ).filePath, srcPath );
      return null;
    })
  })

  .then( () =>
  {
    test.case = 'dir -> link -> link, relative paths';
    srcPath  = test.context.pathFor( 'written/softLinkToParentDirectoryAsync/dir' );
    dstPath  = test.context.pathFor( 'written/softLinkToParentDirectoryAsync/dir/link' );
    dst2Path  = test.context.pathFor( 'written/softLinkToParentDirectoryAsync/dir/link/link2' );
    provider.dirMake( srcPath );
    return provider.softLink
    ({
      srcPath : '..',
      dstPath,
      sync : 0,
    })
    .then( () =>
    {
      return provider.softLink
      ({
        srcPath : '..',
        dstPath : dst2Path,
        sync : 0,
      });
    })
    .then( () =>
    {
      test.is( provider.isSoftLink( dstPath ) );
      test.is( provider.isSoftLink( dst2Path ) );
      test.is( provider.isDir( srcPath ) );
      test.identical( provider.pathResolveSoftLink( dst2Path ), test.context.globalFromPreferred( '..' )  );
      test.identical( provider.pathResolveLinkFull( dst2Path ).filePath, srcPath );
      return null;
    })
  })

  .then( () =>
  {
    test.case = 'dir -> link -> link, relative paths';
    srcPath  = test.context.pathFor( 'written/softLinkToParentDirectoryAsync/dir' );
    dstPath  = test.context.pathFor( 'written/softLinkToParentDirectoryAsync/dir/link' );
    dst2Path  = test.context.pathFor( 'written/softLinkToParentDirectoryAsync/dir/link/link2' );
    provider.dirMake( srcPath );
    return provider.softLink
    ({
      srcPath,
      dstPath,
      sync : 0,
    })
    .then( () =>
    {
      return provider.softLink
      ({
        srcPath,
        dstPath : dst2Path,
        resolvingSrcSoftLink : 1,
        sync : 0,
      });
    })
    .then( () =>
    {
      test.is( provider.isSoftLink( dstPath ) );
      test.is( provider.isSoftLink( dst2Path ) );
      test.is( provider.isDir( srcPath ) );
      test.identical( provider.pathResolveSoftLink( dst2Path ), srcPath  );
      test.identical( provider.pathResolveLinkFull( dst2Path ).filePath, srcPath );
      return null;
    })
  })

  return con;
}

//

function softLinkHardLinkedSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRenameAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  let routinePath = test.context.pathFor( 'written/softLinkHardLinkedSync' );
  let srcPath = test.context.pathFor( 'written/softLinkHardLinkedSync/src' );
  let dstPath = test.context.pathFor( 'written/softLinkHardLinkedSync/dst' );

  /* - */

  test.case = 'soft link two hard linked files'
  provider.filesDelete( routinePath )
  provider.fileWrite( srcPath, 'data' );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
  provider.softLink({ dstPath, srcPath });
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), false );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
}

//

function softLinkHardLinkedAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLinkAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  let routinePath = test.context.pathFor( 'written/softLinkHardLinkedAsync' );
  let srcPath = test.context.pathFor( 'written/softLinkHardLinkedAsync/src' );
  let dstPath = test.context.pathFor( 'written/softLinkHardLinkedAsync/dst' );

  let ready = new _.Consequence().take( null )

  /* - */

  .then( () =>
  {
    test.case = 'soft link two hard linked files'
    provider.filesDelete( routinePath )
    provider.fileWrite( srcPath, 'data' );
    provider.hardLink( dstPath, srcPath );
    if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
    else
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
    return provider.softLink
    ({
      dstPath,
      srcPath,
      sync : 0
    });
  })
  .then( () =>
  {
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), false );
    test.is( provider.isTerminal( srcPath ) );
    test.is( provider.isSoftLink( dstPath ) );
    test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
    return null;
  })

  /* - */

  return ready;
}

//

function textLinkSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = context.pathFor( 'written/textLinkSync' )
  let filePath1 = context.pathFor( 'written/textLinkSync/file1' );
  let filePath2 = context.pathFor( 'written/textLinkSync/file2' );
  let linkPath1 = context.pathFor( 'written/textLinkSync/link1' );
  let linkPath2 = context.pathFor( 'written/textLinkSync/link2' );

  var got;

  context.provider.fieldPush( 'usingTextLink', 1 );

  /* - */

  test.case = 'textlink to missing';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : filePath1,
      allowingMissed : 0
    });
  });
  test.is( !provider.fileExists( filePath1 ) );
  test.is( !provider.fileExists( linkPath1 ) );

  test.case = 'textlink to missing';
  provider.filesDelete( routinePath );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : filePath1,
    allowingMissed : 1,
    makingDirectory : 1
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( !provider.fileExists( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath1 );
  test.identical( got, filePath1 );

  test.case = 'textlink to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : filePath1,
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( provider.isTerminal( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath1 );
  test.identical( got, filePath1 );

  test.case = 'textlink to directory';
  provider.filesDelete( routinePath );
  provider.dirMake( filePath1 );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : filePath1,
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( provider.isTerminal( linkPath1 ) );
  test.is( provider.isDir( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath1 );
  test.identical( got, filePath1 );

  test.case = 'textlink to textlink';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : filePath1,
  });
  provider.textLink
  ({
    dstPath : linkPath2,
    srcPath : linkPath1,
  });
  test.is( provider.isTextLink( linkPath2 ) );
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath2 );
  test.identical( got, linkPath1 );

  /**/

  test.case = 'try to rewrite existing terminal'
  provider.filesDelete( routinePath );
  provider.fileWrite( linkPath1, linkPath1 );
  provider.fileWrite( filePath1, filePath1 );
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : filePath1,
      rewriting : 0
    });
  })
  test.is( provider.isTerminal( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );
  test.is( !provider.isTextLink( linkPath1 ) );

  test.case = 'try to rewrite existing terminal'
  provider.filesDelete( routinePath );
  provider.fileWrite( linkPath1, linkPath1 );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : filePath1,
    rewriting : 1
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath1 );
  test.identical( got, filePath1 );

  test.case = 'try to rewrite existing dir'
  provider.filesDelete( routinePath );
  provider.dirMake( linkPath1 );
  provider.fileWrite( filePath1, filePath1 );
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : filePath1,
      rewriting : 1,
      rewritingDirs : 0
    });
  })
  test.is( provider.isDir( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );

  test.case = 'try to rewrite existing dir'
  provider.filesDelete( routinePath );
  provider.dirMake( linkPath1 );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : filePath1,
    rewriting : 1,
    rewritingDirs : 1
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath1 );
  test.identical( got, filePath1 );

  /**/

  test.case = 'equal path';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      dstPath : filePath1,
      srcPath : filePath1,
      allowingMissed : 0
    });
  })
  test.is(!provider.isTextLink( filePath1 ) );
  test.is( provider.isTerminal( filePath1 ) );

  test.case = 'equal path';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink
  ({
    dstPath : filePath1,
    srcPath : filePath1,
    allowingMissed : 1
  });
  test.is( provider.isTextLink( filePath1 ) );
  var got = provider.pathResolveTextLink( filePath1 );
  test.identical( got, filePath1 );

  test.case = 'textlinked';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( linkPath1, filePath1 );
  var statBefore = provider.statRead( linkPath1 );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : filePath1,
  });
  var statAfter = provider.statRead( linkPath1 );
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath1 );
  test.identical( got, filePath1 );
  test.identical( statAfter.mtime.getTime(), statBefore.mtime.getTime() );

  /*  */

  test.case = 'relative text link to missing';
  provider.filesDelete( routinePath );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : '../file1',
    allowingMissed : 1,
    makingDirectory : 1
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( !provider.fileExists( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath1 );
  test.identical( got, test.context.globalFromPreferred( '../file1' ) );

  test.case = 'relative text link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : '../file1',
    allowingMissed : 1
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath1 );
  test.identical( got, test.context.globalFromPreferred( '../file1' ) );

  /* */

  test.case = 'relative text link to missing, allowingMissed off throwing off';
  provider.filesDelete( routinePath );
  test.mustNotThrowError( () =>
  {
    got = provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : '../file1',
      allowingMissed : 0,
      throwing : 0
    });
  })
  test.identical( got, null );
  test.is( !provider.isTextLink( linkPath1 ) );
  test.is( !provider.fileExists( filePath1 ) );

  test.case = 'rewrite existing, rewriting off throwing off';
  provider.filesDelete( routinePath );
  provider.fileWrite( linkPath1, linkPath1 );
  provider.fileWrite( filePath1, filePath1 );
  test.mustNotThrowError( () =>
  {
    got = provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : filePath1,
      rewriting : 0,
      throwing : 0
    });
  })
  test.identical( got, null );
  test.is( !provider.isTextLink( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );
  test.is( provider.isTerminal( linkPath1 ) );

  /*  */

  test.open( 'link already exists' );

  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : filePath1,
    rewriting : 0,
    throwing : 1
  });

  test.mustNotThrowError( function( )
  {
    provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : filePath1,
      rewriting : 1,
      throwing : 1,
      sync : 1,
    });
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.identical( provider.pathResolveTextLink( linkPath1 ), filePath1 );

  test.mustNotThrowError( function( )
  {
    provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : filePath1,
      rewriting : 1,
      throwing : 0,
      sync : 1,
    });
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.identical( provider.pathResolveTextLink( linkPath1 ), filePath1 );

  //alredy linked returns true
  test.mustNotThrowError( function( )
  {
    provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : filePath1,
      rewriting : 0,
      throwing : 1,
      sync : 1,
    });
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.identical( provider.pathResolveTextLink( linkPath1 ), filePath1 );

  test.mustNotThrowError( function( )
  {
    provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : filePath1,
      rewriting : 0,
      throwing : 1,
      sync : 1,
    });
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.identical( provider.pathResolveTextLink( linkPath1 ), filePath1 );

  test.close( 'link already exists' );

  test.case = 'src equal to dst, src exists'
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  test.mustNotThrowError( function()
  {
    got = provider.textLink
    ({
      srcPath : filePath1,
      dstPath : filePath1,
      sync : 1,
      rewriting : 1,
      throwing : 1,
      allowingMissed : 1
    });
  });
  test.identical( got, true );
  test.is( provider.isTextLink( filePath1 ) );
  test.identical( provider.pathResolveTextLink( filePath1 ), filePath1 );

  test.case = 'src equal to dst, src does not exist'
  provider.filesDelete( filePath1 );
  test.mustNotThrowError( function()
  {
    got = provider.textLink
    ({
      srcPath : filePath1,
      dstPath : filePath1,
      sync : 1,
      rewriting : 0,
      allowingMissed : 1,
      throwing : 1
    });
  });
  test.identical( got, true );
  test.is( provider.isTextLink( filePath1 ) );

  test.case = 'src equal to dst, src does not exist'
  provider.filesDelete( filePath1 );
  test.mustNotThrowError( function()
  {
    got = provider.textLink
    ({
      srcPath : filePath1,
      dstPath : filePath1,
      sync : 1,
      rewriting : 1,
      allowingMissed : 1,
      throwing : 0
    });
  });
  test.identical( got, true );
  test.is( provider.isTextLink( filePath1 ) );

  test.case = 'src equal to dst, src does not exist'
  provider.filesDelete( filePath1 );
  test.shouldThrowErrorOfAnyKind( function()
  {
    got = provider.textLink
    ({
      srcPath : filePath1,
      dstPath : filePath1,
      sync : 1,
      rewriting : 0,
      allowingMissed : 0,
      throwing : 1
    });
  });
  test.is( !provider.isTextLink( filePath1 ) );

  test.case = 'src equal to dst, src does not exist'
  provider.filesDelete( filePath1 );
  test.mustNotThrowError( function()
  {
    got = provider.textLink
    ({
      srcPath : filePath1,
      dstPath : filePath1,
      sync : 1,
      rewriting : 0,
      allowingMissed : 0,
      throwing : 0
    });
  });
  test.identical( got, null );
  test.is( !provider.isTextLink( filePath1 ) );

  test.case = 'makingDirectory off, throwing on'
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : linkPath1,
      dstPath : filePath1,
      sync : 1,
      rewriting : 1,
      allowingMissed : 1,
      throwing : 1
    });
  })
  test.is( !provider.isTextLink(  linkPath1 ) );

  test.case = 'makingDirectory off, throwing off'
  provider.filesDelete( routinePath );
  test.mustNotThrowError( () =>
  {
    got = provider.textLink
    ({
      srcPath : linkPath1,
      dstPath : filePath1,
      sync : 1,
      rewriting : 1,
      allowingMissed : 1,
      throwing : 0
    });
  })
  test.identical( got, null );
  test.is( !provider.isTextLink(  linkPath1 ) );

  test.case = 'rewrite dir, rewritingDirs off throwing on'
  provider.filesDelete( routinePath );
  provider.dirMake( linkPath1 );
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : filePath1,
      dstPath : linkPath1,
      sync : 1,
      rewriting : 1,
      rewritingDirs : 0,
      allowingMissed : 1,
      throwing : 1
    });
  })
  test.is( !provider.isTextLink( linkPath1 ) );
  test.is( provider.isDir( linkPath1 ) );

  test.case = 'rewrite dir, rewritingDirs off throwing off'
  provider.filesDelete( routinePath );
  provider.dirMake( linkPath1 );
  test.mustNotThrowError( () =>
  {
    got = provider.textLink
    ({
      srcPath : filePath1,
      dstPath : linkPath1,
      sync : 1,
      rewriting : 1,
      rewritingDirs : 0,
      allowingMissed : 1,
      throwing : 0
    });
  })
  test.identical( got, null );
  test.is( !provider.isTextLink( linkPath1 ) );
  test.is( provider.isDir( linkPath1 ) );

  test.case = 'rewrite dir, rewritingDirs on throwing on'
  provider.filesDelete( routinePath );
  provider.dirMake( linkPath1 );
  provider.textLink
  ({
    srcPath : filePath1,
    dstPath : linkPath1,
    sync : 1,
    rewriting : 1,
    rewritingDirs : 1,
    allowingMissed : 1,
    throwing : 1
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.identical( provider.pathResolveTextLink( linkPath1 ), filePath1 );

  test.case = 'rewrite dir, rewritingDirs on rewriting off throwing on'
  provider.filesDelete( routinePath );
  provider.dirMake( linkPath1 );
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : filePath1,
      dstPath : linkPath1,
      sync : 1,
      rewriting : 0,
      rewritingDirs : 1,
      allowingMissed : 1,
      throwing : 1
    });
  })
  test.is( !provider.isTextLink( linkPath1 ) );
  test.is( provider.isDir( linkPath1 ) );

  test.case = 'rewrite dir, rewritingDirs on rewriting off throwing off'
  provider.filesDelete( routinePath );
  provider.dirMake( linkPath1 );
  test.mustNotThrowError( () =>
  {
    got = provider.textLink
    ({
      srcPath : filePath1,
      dstPath : linkPath1,
      sync : 1,
      rewriting : 0,
      rewritingDirs : 1,
      allowingMissed : 1,
      throwing : 0
    });
  })
  test.identical( got, null )
  test.is( !provider.isTextLink( linkPath1 ) );
  test.is( provider.isDir( linkPath1 ) );

  context.provider.fieldPop( 'usingTextLink', 1 );
}

function textLinkResolvingBasic( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.textLink ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/textLinkResolvingBasic' );
  let src1Path = test.context.pathFor( 'written/textLinkResolvingBasic/src1' );
  let src2Path = test.context.pathFor( 'written/textLinkResolvingBasic/src2' );
  let src3Path = test.context.pathFor( 'written/textLinkResolvingBasic/src3' );
  let dstPath = test.context.pathFor( 'written/textLinkResolvingBasic/dst' );

  /*
      src1 -> src2 -> src3
      resolvingSrcSoftLink : 0
      textLink
        - soft link dst -> src1

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 1
      textLink
        - soft link dst -> src3

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 2
      textLink
        - soft link dst -> src3
  */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src3Path );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src3Path );

  /* */

  test.case = 'resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, src3Path );
  provider.textLink( src1Path, src2Path );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, src3Path );
  provider.textLink( src1Path, src2Path );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src3Path );

  test.case = 'resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, src3Path );
  provider.textLink( src1Path, src2Path );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 2 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src3Path );

  provider.fieldPop( 'usingTextLink', 1 );
}

//

function textLinkRelativeSoftLinking( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.textLink ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/textLinkRelativeSoftLinking' );
  let src1Path = test.context.pathFor( 'written/textLinkRelativeSoftLinking/src1' );
  let src2Path = test.context.pathFor( 'written/textLinkRelativeSoftLinking/src2' );
  let src3Path = test.context.pathFor( 'written/textLinkRelativeSoftLinking/src3' );
  let dstPath = test.context.pathFor( 'written/textLinkRelativeSoftLinking/dst' );

  /*
    src1 -> ../src2
    textLink dst src1
    resolvingSrcSoftLink : 0
    - link dst -> src1

    src1 -> ../src2
    textLink dst src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 -> ../src2
    textLink dst ../src1
    resolvingSrcSoftLink : 0
    - link dst -> ../src1

    src1 -> ../src2
    textLink dst ../src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 as :
    - missing file
    - link

    src2 as :
    - terminal
    - intermediate link
    - missing

  */

  provider.fieldPush( 'usingTextLink', 1 );

  /* src1 missing */

  test.case = '../src1 is missing, allowingMissed:0';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcTextLink : 0,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = '../src1 is missing, allowingMissed:1';
  provider.filesDelete( routinePath );
  provider.textLink
  ({
    srcPath : '../src1',
    dstPath,
    resolvingSrcTextLink : 0,
    resolvingSrcSoftLink : 0,
    makingDirectory : 1,
    allowingMissed : 1
  });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, textLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, textLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, textLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  /* */

  test.case = 'src1 -> ../src2, textLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, textLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, textLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  /* missing absolute src */

  test.case = 'src1 -> ../src2, textLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, textLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, textLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, textLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, textLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, textLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  /* missing relative src */

  test.case = 'src1 -> ../src2, textLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, textLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, textLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, textLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, textLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, textLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  /* chain */

  test.case = 'src1 -> ../src2 -> ../src3, textLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2 -> ../src3, textLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, textLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src3' ) );

  /*  */

  test.case = 'src1 -> ../src2 -> ../src3, textLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2 -> ../src3, textLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, textLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src3' ) );

  /*  */

  provider.fieldPop( 'usingTextLink', 1 );

}

//

function textLinkGlobal( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( provider instanceof _.FileProvider.System )
  {
    test.identical( 1, 1 )
    return;
  }

  let routinePath = test.context.pathFor( 'written/textLinkGlobal' );
  let srcPath = test.context.pathFor( 'written/textLinkGlobal/src' );
  let dstPath = test.context.pathFor( 'written/textLinkGlobal/dst' );

  var srcPathDefault = path.globalFromPreferred( srcPath );
  var dstPathDefault = path.globalFromPreferred( dstPath );

  var srcPathSecond = 'second://' + srcPath;
  var dstPathSecond = 'second://' + dstPath;

  var dstPathUnknown = 'unknown://' + dstPath;

  provider.fieldPush( 'usingTextLink', 1 )

  /*  */

  test.open( 'with system' );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( dstPathDefault, srcPathDefault );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), srcPath );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( dstPathSecond, srcPathSecond );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), srcPath );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.textLink( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.close( 'with system' );

  /*  */

  test.open( 'without system' );

  context.system.providerUnregister( provider );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( dstPathDefault, srcPathDefault );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), srcPath );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( dstPathSecond, srcPathSecond );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), srcPath );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.textLink( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  provider.fieldPop( 'usingTextLink', 1 )

  context.system.providerRegister( provider );

  test.close( 'without system' );
}

//

function textLinkRelativeTextLinking( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.textLink ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/textLinkRelativeTextLinking' );
  let src1Path = test.context.pathFor( 'written/textLinkRelativeTextLinking/src1' );
  let src2Path = test.context.pathFor( 'written/textLinkRelativeTextLinking/src2' );
  let src3Path = test.context.pathFor( 'written/textLinkRelativeTextLinking/src3' );
  let dstPath = test.context.pathFor( 'written/textLinkRelativeTextLinking/dst' );

  /*
    src1 -> ../src2
    textLink dst src1
    resolvingSrcTextLink : 0
    - link dst -> src1

    src1 -> ../src2
    textLink dst src1
    resolvingSrcTextLink : 1
    - link dst -> ../src2

    src1 -> ../src2
    textLink dst ../src1
    resolvingSrcTextLink : 0
    - link dst -> ../src1

    src1 -> ../src2
    textLink dst ../src1
    resolvingSrcTextLink : 1
    - link dst -> ../src2

    src1 as :
    - missing file
    - link

    src2 as :
    - terminal
    - intermediate link
    - missing

  */

  provider.fieldPush( 'usingTextLink', 1 );

  /* src1 missing */

  test.case = '../src1 is missing, allowingMissed:0';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = '../src1 is missing, allowingMissed:1';
  provider.filesDelete( routinePath );
  provider.textLink
  ({
    srcPath : '../src1',
    dstPath,
    resolvingSrcSoftLink : 0,
    resolvingSrcTextLink : 0,
    makingDirectory : 1,
    allowingMissed : 1
  });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  /* */

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  /* missing absolute src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0, allowingMissed : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcTextLink : 1,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcTextLink : 2,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  /* missing relative src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0, allowingMissed : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcTextLink : 1,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcTextLink : 2,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  /* chain */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src3' ) );

  /*  */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src3' ) );

  /*  */

  provider.fieldPop( 'usingTextLink', 1 );

}

//

function textLinkHardLinkedSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRenameAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  let routinePath = test.context.pathFor( 'written/textLinkHardLinkedSync' );
  let srcPath = test.context.pathFor( 'written/textLinkHardLinkedSync/src' );
  let dstPath = test.context.pathFor( 'written/textLinkHardLinkedSync/dst' );

  /* - */

  provider.fieldPush( 'resolvingTextLink', 1 );
  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'text link two hard linked files'
  provider.filesDelete( routinePath )
  provider.fileWrite( srcPath, 'data' );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
  provider.textLink({ dstPath, srcPath });
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), false );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), srcPath );

  provider.fieldPop( 'resolvingTextLink', 1 );
  provider.fieldPop( 'usingTextLink', 1 );
}

//

function textLinkHardLinkedAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLinkAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  let routinePath = test.context.pathFor( 'written/textLinkHardLinkedAsync' );
  let srcPath = test.context.pathFor( 'written/textLinkHardLinkedAsync/src' );
  let dstPath = test.context.pathFor( 'written/textLinkHardLinkedAsync/dst' );

  let ready = new _.Consequence().take( null )

  /* - */

  .then( () =>
  {
    test.case = 'text link two hard linked files'

    provider.fieldPush( 'resolvingTextLink', 1 );
    provider.fieldPush( 'usingTextLink', 1 );

    provider.filesDelete( routinePath )
    provider.fileWrite( srcPath, 'data' );
    provider.hardLink( dstPath, srcPath );
    if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
    else
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
    return provider.textLink
    ({
      dstPath,
      srcPath,
      sync : 0
    });
  })
  .then( () =>
  {
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), false );
    test.is( provider.isTerminal( srcPath ) );
    test.is( provider.isTextLink( dstPath ) );
    test.identical( provider.pathResolveTextLink( dstPath ), srcPath );

    provider.fieldPop( 'resolvingTextLink', 1 );
    provider.fieldPop( 'usingTextLink', 1 );

    return null;
  })

  /* - */

  return ready;
}

//

function hardLinkSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLinkAct ) )
  {
    test.case = 'hardLinkAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  var routinePath = test.context.pathFor( 'written/hardLink' );
  provider.filesDelete( routinePath )
  var srcPath, dstPath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  /* - */

  test.case = 'make link async';
  srcPath  = test.context.pathFor( 'written/hardLink/link_test.txt' );
  dstPath = test.context.pathFor( 'written/hardLink/link.txt' );
  provider.fileWrite( srcPath, '000' );

  /**/

  provider.hardLink
  ({
    srcPath,
    dstPath,
    sync : 1,
  });
  provider.fileWrite
  ({
    filePath : srcPath,
    sync : 1,
    data : 'new text',
    writeMode : 'append'
  });

  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link.txt', 'link_test.txt' ] )
  var got = provider.fileRead( dstPath );
  var expected = '000new text';
  test.identical( got, expected );

  /* - */

  test.case = 'make for file that not exist';
  provider.filesDelete( routinePath );
  srcPath  = test.context.pathFor( 'written/hardLink/no_file.txt' );
  dstPath = test.context.pathFor( 'written/hardLink/link2.txt' );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.hardLink
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1,
      throwing : 1
    });
  })

  /**/

  test.mustNotThrowError( function()
  {
    provider.hardLink
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1,
      throwing : 0
    });
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, null );

  /* - */

  test.case = 'link already exists';
  srcPath = test.context.pathFor( 'written/hardLink/link_test.txt' );
  dstPath = test.context.pathFor( 'written/hardLink/link.txt' );
  provider.fileWrite( srcPath, 'abc' );
  var got = provider.hardLink
  ({
    srcPath,
    dstPath,
    rewriting : 1,
    throwing : 1,
    sync : 1,
  });
  test.identical( got, true );

  /**/

  test.mustNotThrowError( function( )
  {
    var got = provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 1,
    });
    test.identical( got, false );
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link.txt', 'link_test.txt' ] )

  /**/

  test.mustNotThrowError( function( )
  {
    var got = provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 0,
      sync : 1,
    });
    test.identical( got, false );
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link.txt', 'link_test.txt' ] )

  /**/

  var got = provider.hardLink
  ({
    srcPath,
    dstPath,
    rewriting : 0,
    throwing : 1,
    sync : 1,
  });
  test.identical( got, false );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), hardLinked )
  else
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), true )

  /**/

  test.mustNotThrowError( function( )
  {
    provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 1,
    });
  });

  /* - */

  test.case = 'src is equal to dst';
  provider.filesDelete( routinePath );
  srcPath = test.context.pathFor( 'written/hardLink/link_test.txt' );
  provider.fileWrite( srcPath, ' ' );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.hardLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 1,
      throwing : 1
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link_test.txt' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.hardLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      throwing : 1
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link_test.txt' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.hardLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 1,
      throwing : 0
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link_test.txt' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.hardLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      throwing : 0
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link_test.txt' ] );

  /* - */

  test.case = 'try make hardLink for folder';
  provider.filesDelete( routinePath );
  srcPath = test.context.pathFor( 'written/hardLink/link_test' );
  dstPath = test.context.pathFor( 'written/hardLink/link' );
  provider.dirMake( srcPath );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 1,
    });
  })

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 1,
      sync : 1,
    });
  })

  /**/

  test.mustNotThrowError( function()
  {
    debugger
    provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 0,
      sync : 1,
    });
  })

  /**/

  test.mustNotThrowError( function()
  {
    provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 1,
    });
  })

  /**/

  test.case = 'try to link same file, srcPath has intermediate soft link to same dir';
  context.provider.filesDelete( routinePath );
  var dirPath = path.join( routinePath, 'dir' );
  var terminalPath = path.join( dirPath, 'terminal' );
  var linkToDirPath = path.join( routinePath, 'linkToDir' );
  context.provider.fileWrite( terminalPath, terminalPath );
  context.provider.softLink( linkToDirPath, dirPath );
  var srcPath2 = path.join( linkToDirPath, 'terminal' );
  var terminalStatBefore = context.provider.statRead( terminalPath );
  var got = context.provider.hardLink /* Vova : Extract.areHardLinkedAct doesn't resolve intermediate directories */
  ({
    dstPath : terminalPath,
    srcPath : srcPath2,
    throwing : 1,
    resolvingSrcSoftLink : 0,
    resolvingDstSoftLink : 0,
  });
  test.identical( got, false );
  var terminalStatAfter = context.provider.statRead( terminalPath );
  test.identical( terminalStatBefore.mtime.getTime(), terminalStatAfter.mtime.getTime() );

  test.case = 'try to link same file, srcPath has intermediate soft link to same dir';
  context.provider.filesDelete( routinePath );
  var dirPath = path.join( routinePath, 'dir' );
  var terminalPath = path.join( dirPath, 'terminal' );
  var linkToDirPath = path.join( routinePath, 'linkToDir' );
  context.provider.fileWrite( terminalPath, terminalPath );
  context.provider.softLink( linkToDirPath, dirPath );
  var srcPath2 = path.join( linkToDirPath, 'terminal' );
  var terminalStatBefore = context.provider.statRead( terminalPath );
  var got = context.provider.hardLink
  ({
    dstPath : terminalPath,
    srcPath : srcPath2,
    throwing : 1,
    resolvingSrcSoftLink : 1,
    resolvingDstSoftLink : 0,
  });
  test.identical( got, true );
  var terminalStatAfter = context.provider.statRead( terminalPath );
  test.identical( terminalStatBefore.mtime.getTime(), terminalStatAfter.mtime.getTime() );

  test.case = 'try to link same file, dstPath has intermediate soft link to same dir';
  context.provider.filesDelete( routinePath );
  var dirPath = path.join( routinePath, 'dir' );
  var terminalPath = path.join( dirPath, 'terminal' );
  var linkToDirPath = path.join( routinePath, 'linkToDir' );
  context.provider.fileWrite( terminalPath, terminalPath );
  context.provider.softLink( linkToDirPath, dirPath );
  var srcPath2 = path.join( linkToDirPath, 'terminal' );
  var terminalStatBefore = context.provider.statRead( terminalPath );
  var got = context.provider.hardLink
  ({
    dstPath : srcPath2,
    srcPath : terminalPath,
    throwing : 1,
    resolvingSrcSoftLink : 0,
    resolvingDstSoftLink : 1,
  });
  test.identical( got, true );
  var terminalStatAfter = context.provider.statRead( terminalPath );
  test.identical( terminalStatBefore.mtime.getTime(), terminalStatAfter.mtime.getTime() );

  test.case = 'try to link same file, srcPath and dstPath have intermediate soft link to same dir';
  context.provider.filesDelete( routinePath );
  var dirPath = path.join( routinePath, 'dir' );
  var terminalPath = path.join( dirPath, 'terminal' );
  var linkToDirPath = path.join( routinePath, 'linkToDir' );
  context.provider.fileWrite( terminalPath, terminalPath );
  context.provider.softLink( linkToDirPath, dirPath );
  var srcPath2 = path.join( linkToDirPath, 'terminal' );
  var terminalStatBefore = context.provider.statRead( terminalPath );
  var got = context.provider.hardLink
  ({
    dstPath : srcPath2,
    srcPath : srcPath2,
    throwing : 1,
    resolvingSrcSoftLink : 1,
    resolvingDstSoftLink : 1,
  });
  test.identical( got, true );
  var terminalStatAfter = context.provider.statRead( terminalPath );
  test.identical( terminalStatBefore.mtime.getTime(), terminalStatAfter.mtime.getTime() );
}

//

function hardLinkMultipleSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLinkAct ) )
  {
    test.case = 'hardLinkAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  function linkGroups( paths, groups )
  {
    groups.forEach( ( g ) =>
    {
      var filePathes = g.map( ( i ) => paths[ i ] );
      provider.hardLink({ dstPath : filePathes });
    })
  }

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  var delay = 10;

  if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  delay = provider.systemBitrateTimeGet() / 1000;

  function makeFiles( names, dirPath, sameTime )
  {
    let ready = new _.Consequence().take( null );
    var paths = names.map( ( name, i ) =>
    {
      var filePath = context.pathFor( path.join( dirPath, name ) );

      ready.then( () =>
      {
        provider.fileWrite({ filePath, data : filePath, purging : 1 });

        if( sameTime )
        {
          provider.timeWrite( filePath, delay, delay );
        }
        else if( i > 0 )
        {
          return _.time.out( delay )
          .then( () =>
          {
            provider.fileWrite({ filePath, data : path.name( filePath ) });
            return true;
          })
        }

        return null;
      })

      return filePath;
    });

    ready.deasync();

    return paths;
  }

  function makeHardLinksToPath( filePath, amount )
  {
    let routinePath = path.join( context.provider.path.dir( filePath ), _.idWithDateAndTime() );
    provider.dirMake( routinePath )
    for( var i = 0; i < amount; i++ )
    provider.hardLink( path.join( routinePath, 'file' + i ), filePath );
  }

  function filesHaveSameTime( paths )
  {
    _.assert( paths.length > 1 );
    var srcStat = provider.statResolvedRead( paths[ 0 ] );

    for( var i = 1; i < paths.length; i++ )
    {
      var stat = provider.statResolvedRead( paths[ i ] );
      if( srcStat.atime.getTime() !== stat.atime.getTime() )
      {
        logger.log( srcStat.atime.getTime(), stat.atime.getTime() );
        return false;
      }

      if( srcStat.mtime.getTime() !== stat.mtime.getTime() )
      {
        logger.log( srcStat.mtime.getTime(), stat.mtime.getTime() )
        return false;
      }
    }

    return true;
  }

  var routinePath = test.context.pathFor( 'written/hardLink' );
  provider.filesDelete( routinePath )
  var srcPath, dstPath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  /* - */

  if( context.providerIsInstanceOf( _.FileProvider.Extract ) )
  {
    //Vova: next section needs time stats from Extract.statResolvedRead, not implemented yet
    test.identical( 1, 1 );
    return;
  }

  /* - */

  var fileNames = [ 'a1', 'a2', 'a3' ];
  var currentTestDir = 'written/hardLink/';
  var data = ' ';

  /**/

  test.case = 'dstPath option, files are not linked';
  var paths = makeFiles( fileNames, currentTestDir );
  paths = provider.path.s.normalize( paths )
  provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 1,
    throwing : 1
  })
  test.identical( provider.areHardLinked( paths ), hardLinked );

  /**/

  test.case = 'dstPath option, linking files from different dirs';
  paths = fileNames.map( ( n ) => path.join( 'dir_'+ n, n ) );
  paths = makeFiles( paths, currentTestDir );
  paths = provider.path.s.normalize( paths )

  provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 1,
    throwing : 1
  })
  test.identical( provider.areHardLinked( paths ), hardLinked );

  /**/

  test.case = 'dstPath option, try to link already linked files';
  var paths = makeFiles( fileNames, currentTestDir );
  paths = provider.path.s.normalize( paths );
  provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 1,
    throwing : 1
  })
  // try to link again
  provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 1,
    throwing : 1
  })
  test.identical( provider.areHardLinked( paths ), hardLinked );

  /**/

  test.case = 'dstPath, rewriting off, try to rewrite existing files';
  var paths = makeFiles( fileNames, currentTestDir );
  paths = provider.path.s.normalize( paths );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLink
    ({
      sync : 1,
      dstPath : paths,
      rewriting : 0,
      throwing : 1
    })
  });
  var got = provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 0,
    throwing : 0
  });
  test.identical( got, false );

  /* - */

  test.case = 'dstPath option, groups of linked files ';
  var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
  provider.filesDelete( test.context.pathFor( currentTestDir ) );

  /**/

  var groups = [ [ 0, 1 ], [ 2, 3, 4 ], [ 5 ] ];
  var paths = makeFiles( fileNames, currentTestDir );
  paths = provider.path.s.normalize( paths );
  linkGroups( paths, groups );
  provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 1,
    throwing : 1
  })
  test.identical( provider.areHardLinked( paths ), hardLinked );

  /**/

  var groups = [ [ 0, 1 ], [ 1, 2, 3 ], [ 3, 4, 5 ] ];
  var paths = makeFiles( fileNames, currentTestDir );
  paths = provider.path.s.normalize( paths );
  linkGroups( paths, groups );
  provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 1,
    throwing : 1
  })
  test.identical( provider.areHardLinked( paths ), hardLinked );

  /**/

  var groups = [ [ 0, 1, 2, 3 ], [ 4, 5 ] ];
  var paths = makeFiles( fileNames, currentTestDir );
  paths = provider.path.s.normalize( paths );
  linkGroups( paths, groups );
  provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 1,
    throwing : 1
  })
  test.identical( provider.areHardLinked( paths ), hardLinked );

  /**/

  var groups = [ [ 0, 1, 2, 3, 4 ], [ 0, 5 ] ];
  var paths = makeFiles( fileNames, currentTestDir );
  paths = provider.path.s.normalize( paths );
  linkGroups( paths, groups );
  provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 1,
    throwing : 1
  })
  test.identical( provider.areHardLinked( paths ), hardLinked );

  /**/

  test.case = 'dstPath option, only first path exists';
  var fileNames = [ 'a1', 'a2', 'a3' ];
  provider.filesDelete( test.context.pathFor( currentTestDir ) );
  makeFiles( fileNames.slice( 0, 1 ), currentTestDir );
  var paths = fileNames.map( ( n )  => context.pathFor( path.join( currentTestDir, n ) ) );
  paths = provider.path.s.normalize( paths );
  test.mustNotThrowError( () =>
  {
    provider.hardLink
    ({
      sync : 1,
      dstPath : paths,
      allowingMissed : 1,
      rewriting : 1,
      throwing : 1
    })
  })
  test.identical( provider.areHardLinked( paths ), hardLinked );
  provider.fileWrite( paths[ paths.length - 1 ], fileNames[ fileNames.length - 1 ] );
  test.identical( provider.fileRead( paths[ 0 ] ), provider.fileRead( paths[ paths.length - 1 ] ) );

  /**/

  test.case = 'dstPath option, only first path exists';
  var fileNames = [ 'a1', 'a2', 'a3' ];
  provider.filesDelete( test.context.pathFor( currentTestDir ) );
  makeFiles( fileNames.slice( 0, 1 ), currentTestDir );
  var paths = fileNames.map( ( n )  => context.pathFor( path.join( currentTestDir, n ) ) );
  paths = provider.path.s.normalize( paths );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLink
    ({
      sync : 1,
      dstPath : paths,
      allowingMissed : 0,
      rewriting : 1,
      throwing : 1
    })
  })
  test.identical( provider.areHardLinked( paths ), false );
  test.is( !provider.fileExists( paths[ 1 ] ) );
  test.is( !provider.fileExists( paths[ 2 ] ) );

  /**/

  test.case = 'dstPath option, all paths not exist';
  provider.filesDelete( test.context.pathFor( currentTestDir ) );
  var paths = fileNames.map( ( n )  => context.pathFor( path.join( currentTestDir, n ) ) );
  paths = provider.path.s.normalize( paths );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLink
    ({
      sync : 1,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
  });

  /* repair */

  /* test.case = 'dstPath option, same date but different content';
  var paths = makeFiles( fileNames, currentTestDir, true );
  paths = provider.path.s.normalize( paths );
  provider.hardLink({ dstPath : paths });
  var stat = provider.statResolvedRead( paths[ 0 ] );
  _.time.out( delay ).deasync();
  provider.fileTouch({ filePath : paths[ paths.length - 1 ], purging : 1 });
  provider.fileWrite( paths[ paths.length - 1 ], 'different content' );
  var files = provider.recordFactory().records( paths );
  files[ files.length - 1 ].stat.mtime = files[ 0 ].stat.mtime;
  files[ files.length - 1 ].stat.birthtime = files[ 0 ].stat.birthtime;
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLink({ dstPath : files, allowingDiscrepancy : 0 });
  });
  test.is( !provider.areHardLinked( paths ) ); */

  /* repair */

  /* test.case = 'dstPath option, same date but different content, allowingDiscrepancy';
  var paths = makeFiles( fileNames, currentTestDir, true );
  paths = provider.path.s.normalize( paths );
  provider.hardLink({ dstPath : paths });
  var stat = provider.statResolvedRead( paths[ 0 ] );
  _.time.out( delay ).deasync();
  provider.fileTouch({ filePath : paths[ paths.length - 1 ], purging : 1 });
  provider.fileWrite( paths[ paths.length - 1 ], 'different content' );
  var files = provider.recordFactory().records( paths );
  files[ files.length - 1 ].stat.mtime = files[ 0 ].stat.mtime;
  files[ files.length - 1 ].stat.birthtime = files[ 0 ].stat.birthtime;
  provider.hardLink({ dstPath : files, allowingDiscrepancy : 1 });
  test.identical( provider.areHardLinked( paths ), null ); */

  /**/

  test.case = 'using srcPath as source for files from dstPath';
  var paths = makeFiles( fileNames, currentTestDir );
  paths = provider.path.s.normalize( paths );
  var srcPath = paths.pop();
  provider.hardLink({ srcPath, dstPath : paths });
  test.identical( provider.areHardLinked( paths ), hardLinked );
  var src = provider.fileRead( srcPath );
  var dst = provider.fileRead( paths[ paths.length - 1 ] );
  test.identical( src, dst )

  /* sourceMode */

  test.case = 'sourceMode: src - newest file with minimal amount of links';
  var paths = makeFiles( fileNames, currentTestDir);
  test.is( paths.length >= 3 );
  makeHardLinksToPath( paths[ 0 ], 3 ); // #1 most linked file
  makeHardLinksToPath( paths[ 1 ], 2 ); // #2 most linked file
  paths = provider.path.s.normalize( paths );
  var records = provider.recordFactory().records( paths );
  // logger.log( _.select( records, '*.relative' ) )
  // logger.log( _.select( records, '*/stat/mtime' ).map( ( t ) => t.getTime() ) )
  var selectedFile = provider._recordsSort({ src : records, sorter : 'modified>hardlinks<' });
  provider.hardLink
  ({
    dstPath : paths,
    sourceMode : 'modified>hardlinks<'
  });
  test.identical( provider.areHardLinked( paths ), hardLinked );
  var srcPath = paths[ 2 ];
  test.identical( selectedFile.absolute, provider.path.preferredFromGlobal( srcPath ) );
  var src = provider.fileRead( srcPath );
  var dst = provider.fileRead( paths[ 1 ] );
  test.identical( src, dst );

  /* - */

  test.case = 'sourceMode: src - newest file with maximal amount of links';
  var paths = makeFiles( fileNames, currentTestDir );
  test.is( paths.length >= 3 );
  makeHardLinksToPath( paths[ 0 ], 3 ); // #1 most linked file
  makeHardLinksToPath( paths[ paths.length - 1 ], 4 ); // #2 most linked+newest file
  paths = provider.path.s.normalize( paths );
  var records = provider.recordFactory().records( paths );
  var selectedFile = provider._recordsSort({ src : records, sorter : 'modified>hardlinks>' });
  provider.hardLink
  ({
    dstPath : paths,
    sourceMode : 'modified>hardlinks>'
  });
  test.identical( provider.areHardLinked( paths ), hardLinked );
  var srcPath = paths[ paths.length - 1 ];
  test.identical( selectedFile.absolute, provider.path.preferredFromGlobal( srcPath ) );
  var src = provider.fileRead( srcPath );
  var dst = provider.fileRead( paths[ 0 ] );
  test.identical( src, dst );

  /* - */

  test.case = 'sourceMode: src - oldest file with maximal amount of links';
  var paths = makeFiles( fileNames, currentTestDir );
  test.is( paths.length >= 3 );
  makeHardLinksToPath( paths[ 0 ], 3 ); // #1 most linked+oldest file
  makeHardLinksToPath( paths[ paths.length - 1 ], 4 ); // #2 most linked+newest file
  paths = provider.path.s.normalize( paths );
  var records = provider.recordFactory().records( paths );
  var selectedFile = provider._recordsSort({ src : records, sorter : 'modified<hardlinks>' });
  provider.hardLink
  ({
    dstPath : paths,
    sourceMode : 'modified<hardlinks>'
  });
  test.identical( provider.areHardLinked( paths ), hardLinked );
  var srcPath = paths[ 0 ];
  test.identical( selectedFile.absolute, provider.path.preferredFromGlobal( srcPath ) );
  var src = provider.fileRead( srcPath );
  var dst = provider.fileRead( paths[ paths.length - 1 ] );
  test.identical( src, dst );

  /* - */

  test.case = 'sourceMode: src - oldest file with maximal amount of links';
  var paths = makeFiles( fileNames, currentTestDir );
  test.is( paths.length >= 3 );
  paths = provider.path.s.normalize( paths );
  var records = provider.recordFactory().records( paths );
  var selectedFile = provider._recordsSort({ src : records, sorter : 'modified<hardlinks<' });
  provider.hardLink
  ({
    dstPath : paths,
    sourceMode : 'modified<hardlinks<'
  });
  test.identical( provider.areHardLinked( paths ), hardLinked );
  var srcPath = paths[ 0 ];
  test.identical( selectedFile.absolute, provider.path.preferredFromGlobal( srcPath ) );
  var src = provider.fileRead( srcPath );
  var dst = provider.fileRead( paths[ paths.length - 1 ] );
  test.identical( src, dst );

  /* - */

  test.case = 'sourceMode: src - same time, max amount of links';
  var paths = makeFiles( fileNames, currentTestDir, true );
  test.is( filesHaveSameTime( paths ) );
  test.is( paths.length >= 3 );
  paths = provider.path.s.normalize( paths );
  makeHardLinksToPath( paths[ 0 ], 2 );
  makeHardLinksToPath( paths[ 1 ], 3 );
  makeHardLinksToPath( paths[ 2 ], 5 );
  test.is( filesHaveSameTime( paths ) );
  var records = provider.recordFactory().records( paths );
  var selectedFile = provider._recordsSort({ src : records, sorter : 'modified>hardlinks>' });
  provider.hardLink
  ({
    dstPath : paths,
    sourceMode : 'modified>hardlinks>'
  });
  test.identical( provider.areHardLinked( paths ), hardLinked );
  var srcPath = paths[ 2 ];
  test.identical( selectedFile.absolute, provider.path.preferredFromGlobal( srcPath ) );
  var src = provider.fileRead( srcPath );
  var dst = provider.fileRead( paths[ 0 ] );
  test.identical( src, dst );

  /* - */

  test.case = 'sourceMode: src - same time, min amount of links';
  var paths = makeFiles( fileNames, currentTestDir, true );
  test.is( filesHaveSameTime( paths ) );
  test.is( paths.length >= 3 );
  paths = provider.path.s.normalize( paths );
  makeHardLinksToPath( paths[ 0 ], 2 );
  makeHardLinksToPath( paths[ 1 ], 3 );
  makeHardLinksToPath( paths[ 2 ], 5 );
  test.is( filesHaveSameTime( paths ) );
  var records = provider.recordFactory().records( paths );
  var selectedFile = provider._recordsSort({ src : records, sorter : 'modified>hardlinks<' });
  provider.hardLink
  ({
    dstPath : paths,
    sourceMode : 'modified>hardlinks<'
  });
  test.identical( provider.areHardLinked( paths ), hardLinked );
  var srcPath = paths[ 0 ];
  test.identical( selectedFile.absolute, provider.path.preferredFromGlobal( srcPath ) );
  var src = provider.fileRead( srcPath );
  var dst = provider.fileRead( paths[ 2 ] );
  var ok = test.identical( src, dst );
}

hardLinkMultipleSync.timeOut = 120000;

//

function hardLinkRelativePath( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLinkAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/hardLinkRelativePath' );
  let pathToDir = test.context.pathFor( 'written/hardLinkRelativePath/dir' );
  let pathToFile = test.context.pathFor( 'written/hardLinkRelativePath/file' );

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  test.open( 'src - relative path to a file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );

  var srcPath = '../file';
  var dstPath = test.context.pathFor( 'written/hardLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ pathToFile, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ pathToFile, dstPath ] ), true );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );

  var srcPath = './../file';
  var dstPath = test.context.pathFor( 'written/hardLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ pathToFile, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ pathToFile, dstPath ] ), true );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );

  var srcPath = '../../file';
  var dstPath = test.context.pathFor( 'written/hardLinkRelativePath/dstPath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ pathToFile, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ pathToFile, dstPath ] ), true );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );

  var srcPath = './../../file';
  var dstPath = test.context.pathFor( 'written/hardLinkRelativePath/dstPath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ pathToFile, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ pathToFile, dstPath ] ), true );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );

  var srcPath = './../../../file';
  var pathToFile2 = test.context.pathFor( 'written/hardLinkRelativePath/a/file' );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/hardLinkRelativePath/a/b/c/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ pathToFile2, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ pathToFile2, dstPath ] ), true );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile2 );

  var srcPath = '../../../file';
  var pathToFile2 = test.context.pathFor( 'written/hardLinkRelativePath/a/file' );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/hardLinkRelativePath/a/b/c/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ pathToFile2, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ pathToFile2, dstPath ] ), true );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got, pathToFile2 );

  test.close( 'src - relative path to a file' );

  /* - */

  test.open( 'src - relative path to a dir' );

  provider.filesDelete( routinePath );
  provider.fileWrite( path.join( pathToDir, 'fileInDir' ), 'fileInDir' );
  provider.dirMake( pathToDir );

  var srcPath = '../dir';
  var dstPath = test.context.pathFor( 'written/hardLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  test.shouldThrowErrorOfAnyKind( () => provider.hardLink( dstPath, srcPath ) )
  test.is( !provider.areHardLinked( [ pathToDir, dstPath ] ) );

  test.close( 'src - relative path to a dir' );

  test.open( 'dst - relative path to a file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );

  var srcPath = pathToFile;
  var dstPath = '../dstFile';
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ pathToFile, dstPathResolved ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ pathToFile, dstPathResolved ] ), true );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = './../dstFile';
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ pathToFile, dstPathResolved ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ pathToFile, dstPathResolved ] ), true );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );


  var srcPath = pathToFile;
  var dstPath = './../../dstFile';
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ pathToFile, dstPathResolved ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ pathToFile, dstPathResolved ] ), true );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = './../../dstFile';
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ pathToFile, dstPathResolved ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ pathToFile, dstPathResolved ] ), true );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = '../a/b/dstFile';
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.dirMakeForFile( dstPathResolved );
  provider.filesDelete( dstPathResolved );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ pathToFile, dstPathResolved ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ pathToFile, dstPathResolved ] ), true );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = './../a/b/dstFile';
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.dirMakeForFile( dstPathResolved );
  provider.filesDelete( dstPathResolved );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ pathToFile, dstPathResolved ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ pathToFile, dstPathResolved ] ), true );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got, pathToFile );

  test.close( 'dst - relative path to a file' );

  /* - */

  test.open( 'dst - relative path to a dir' );

  provider.filesDelete( routinePath );
  provider.fileWrite( path.join( pathToDir, 'fileInDir' ), 'fileInDir' );
  provider.dirMake( pathToDir );

  var srcPath = pathToDir;
  var dstPath = '../dstPath';
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  test.shouldThrowErrorOfAnyKind( () => provider.hardLink( dstPath, srcPath ) )
  test.is( !provider.areHardLinked( [ pathToDir, dstPathResolved ] ) );

  test.close( 'dst - relative path to a dir' );

  test.open( 'same paths' );

  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );

  var srcPath = '../file';
  var dstPath = pathToFile;
  var statBefore = provider.statResolvedRead( pathToFile );
  var got = provider.hardLink( dstPath, srcPath );
  test.identical( got, true );
  var statNow = provider.statResolvedRead( pathToFile );
  test.identical( statBefore.nlink, statNow.nlink );

  var srcPath = pathToFile;
  var dstPath = '../file';
  var statBefore = provider.statResolvedRead( pathToFile );
  var got = provider.hardLink( dstPath, srcPath );
  test.identical( got, true );
  var statNow = provider.statResolvedRead( pathToFile );
  test.identical( statBefore.nlink, statNow.nlink );

  test.close( 'same paths' );

}

//

function hardLinkSoftlinked( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    /*
      qqq : statReadAct of Extract and HD handle links in head of path differently
      HD always resolve them
      add test routine statReadActLinkedHead
      aaa : done
    */
    // test.case = 'Not implemented for Extract';
    // test.identical( 1, 1 )
    // return;
  }

  if( !test.context.softLinkIsSupported() )
  {
    test.case = 'System does not allow to create soft links.';
    test.identical( 1, 1 )
    return;
  }

  var mp = _.routineJoin( test.context, test.context.pathFor );

  test.case = 'files are already linked, must not throw an error'
  var routinePath = mp( 'hardLinkActSync/dir' );
  var fileInDir = mp( 'hardLinkActSync/dir/src' );
  var linkToDir = mp( 'hardLinkActSync/linkToDir' );
  var fileInLinkedDir = mp( 'hardLinkActSync/linkToDir/src' );
  provider.fileWrite( fileInDir, fileInDir );
  var statResolvedReadBefore = provider.statResolvedRead( fileInDir );
  provider.softLink( linkToDir, routinePath );
  var got = provider.hardLink( fileInLinkedDir, fileInDir );
  test.identical( got, false );
  var statResolvedReadAfter = provider.statResolvedRead( fileInDir );
  test.is( !!statResolvedReadAfter );
  if( statResolvedReadAfter )
  {

    // if( !context.providerIsInstanceOf( _.FileProvider.HardDrive ) ) /* xxx : ! */
    // return;

    test.identical( statResolvedReadBefore.atime.getTime(), statResolvedReadAfter.atime.getTime() );
    test.identical( statResolvedReadBefore.ctime.getTime(), statResolvedReadAfter.ctime.getTime() );
    test.identical( statResolvedReadBefore.mtime.getTime(), statResolvedReadAfter.mtime.getTime() );
    test.identical( statResolvedReadBefore.birthtime.getTime(), statResolvedReadAfter.birthtime.getTime() );
  }

}

//

function hardLinkActSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLinkAct ) )
  {
    test.case = 'hardLinkAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  var mp = _.routineJoin( test.context, test.context.pathFor );
  var routinePath = mp( 'hardLinkActSync' );

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  var softLinkIsSupported = test.context.softLinkIsSupported();

  /* - */

  test.case = 'basic usage';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1,
    context : null
  }
  var expected = _.mapOwnKeys( o );
  provider.hardLinkAct( o );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'no src';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1,
    context : null
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o );
  })
  test.is( !provider.areHardLinked( [ srcPath, dstPath ] ) );

  /* - */

  test.case = 'src is not a terminal';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath, 'src' );
  provider.dirMake( srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1,
    context : null
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o );
  })
  test.is( !provider.areHardLinked( [ srcPath, dstPath ] ) );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'src is a terminal, check link';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1,
    context : null
  }
  provider.hardLinkAct( o );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
  provider.fileWrite( dstPath, dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( srcFile, dstPath );
  provider.filesDelete( routinePath );

  test.case = 'src is hardLink';
  var filePath = path.join( routinePath, 'file' );
  provider.fileWrite( filePath, filePath );
  var srcPath = path.join( routinePath, 'src' );
  provider.hardLink( srcPath, filePath );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1,
    context : null
  }
  var expected = _.mapOwnKeys( o );
  provider.hardLinkAct( o );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  /* - */

  if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.case = 'src is a hard link, check link';
    provider.filesDelete( routinePath );
    var filePath0 = path.join( routinePath, 'file' );
    var srcPath0 = path.join( routinePath, 'src' );
    provider.fileWrite( filePath0, filePath0 );
    provider.hardLink({ srcPath : filePath0, dstPath : srcPath0, sync : 1 });
    if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    test.identical( provider.areHardLinked( [ srcPath0, filePath0 ] ), hardLinked );
    else
    test.identical( provider.areHardLinked( [ srcPath0, filePath0 ] ), true );
    var dstPath0 = path.join( routinePath, 'dst' );
    var o0 =
    {
      srcPath : srcPath0,
      dstPath : dstPath0,
      relativeSrcPath : srcPath0,
      relativeDstPath : dstPath0,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 1,
      context : null
    }
    provider.hardLinkAct( o0 );
    if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    test.identical( provider.areHardLinked( [ srcPath0, dstPath0 ] ), hardLinked );
    else
    test.identical( provider.areHardLinked( [ srcPath0, dstPath0 ] ), true );
    provider.fileWrite( dstPath0, dstPath0 );
    var srcFile0 = provider.fileRead( srcPath0 );
    test.identical( srcFile0, dstPath0 );
    var file = provider.fileRead( filePath0 );
    test.identical( srcFile0, file );
    provider.filesDelete( routinePath );
  }

  /* - */

  if( softLinkIsSupported )
  {
    test.case = 'src is a soft link, check link';
    provider.filesDelete( routinePath );
    var filePath1 = path.join( routinePath, 'file' );
    var srcPath1 = path.join( routinePath, 'src' );
    provider.fileWrite( filePath1, filePath1 );
    provider.softLink({ srcPath : filePath1, dstPath : srcPath1, sync : 1 });
    var dstPath1 = path.join( routinePath, 'dst' );
    var o1 =
    {
      srcPath : srcPath1,
      dstPath : dstPath1,
      relativeSrcPath : srcPath1,
      relativeDstPath : dstPath1,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 1,
      context : null
    }
    test.shouldThrowErrorOfAnyKind( () => provider.hardLinkAct( o1 ) )
    test.is( !provider.areHardLinked( [ srcPath1, dstPath1 ] ) );
    var srcFile1 = provider.fileRead( srcPath1 );
    test.identical( srcFile1, filePath1 );
  }


  /* - */

  test.case = 'dst is a terminal';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1,
    context : null
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o )
  });
  test.is( !provider.areHardLinked( [ srcPath, dstPath ] ) );
  var dstFile = provider.fileRead( dstPath );
  test.identical( dstFile, dstPath );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'dst is a hard link';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.fileWrite( srcPath, srcPath );
  provider.hardLink( dstPath, srcPath );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1,
    context : null
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o )
  });
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
  var dstFile = provider.fileRead( dstPath );
  test.identical( dstFile, srcPath );
  provider.filesDelete( routinePath );

  /* - */

  if( softLinkIsSupported )
  {
    test.case = 'dst is a soft link';
    provider.filesDelete( routinePath );
    var srcPath2 = path.join( routinePath, 'src' );
    var dstPath2 = path.join( routinePath, 'dst' );
    provider.fileWrite( srcPath2, srcPath2 );
    provider.softLink( dstPath2, srcPath2 );
    var o2 =
    {
      srcPath : srcPath2,
      dstPath : dstPath2,
      relativeSrcPath : srcPath2,
      relativeDstPath : dstPath2,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 1,
      context : null
    }
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.hardLinkAct( o2 );
    });
    test.is( provider.isSoftLink( dstPath2 ) );
    var dstFile2 = provider.fileRead( dstPath2 );
    test.identical( dstFile2, srcPath2 );
    provider.filesDelete( routinePath );
  }

  /* - */

  test.case = 'dst is dir';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  var filePath = path.join( dstPath, 'terminal' )
  var filePath2 = path.join( dstPath, 'file2' )
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( filePath2, filePath2 );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1,
    context : null
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o )
  });
  var files = provider.dirRead( dstPath );
  var expected = [ 'file2', 'terminal' ];
  test.identical( files, expected );
  var file1 = provider.fileRead( filePath );
  var file2 = provider.fileRead( filePath2 );
  test.identical( file1, filePath );
  test.identical( file2, filePath2 );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'should not create folders structure for path';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'parent/dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1,
    context : null
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o );
  })
  test.is( !provider.areHardLinked( [ srcPath, dstPath ] ) );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'should path nativize all paths in options map if needed by its own means';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1,
    context : null
  }

  var expected = _.mapExtend( null, o );

  provider.hardLinkAct( o );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
  test.identical( o, expected );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath, 'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1,
    context : null
  }
  var expected = _.mapOwnKeys( o );
  provider.hardLinkAct( o );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'create link in not existing directory';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var dstMissingPath = path.join( routinePath, 'dir/dst' );
  var o =
  {
    srcPath,
    dstPath : dstMissingPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstMissingPath,
    breakingSrcHardLink : 0,
    // breakingDstHardLink : 0,
    sync : 1,
    context : null
  }
  test.shouldThrowErrorSync( () => provider.hardLinkAct( o ) );
  test.will = 'parent directory of dstPath must not be created';
  test.is( !provider.fileExists( path.dir( dstMissingPath ) ) );

  /* - */

  test.case = 'use terminal as parent directory';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath3 = path.join( srcPath, 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    srcPath,
    dstPath : dstPath3,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath3,
    breakingSrcHardLink : 0,
    // breakingDstHardLink : 0,
    sync : 1,
    context : null
  }
  test.shouldThrowErrorSync( () => provider.hardLinkAct( o ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath3 ) );

  /* - */

  if( !Config.debug )
  return;

  test.case = 'should assert that path is absolute';
  var srcPath = './src';
  var dstPath = path.join( routinePath, 'dst' );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 1,
      context : null
    });
  })

  /* - */

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath, 'src' );;
  var dstPath = path.join( routinePath, 'dst' );

  /* sync option is missed */

  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    // breakingDstHardLink : 1
    context : null
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o );
  });

  /* redundant option */

  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1,
    context : null,
    redundant : 'redundant'
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o );
  });

  /* - */

  test.case = 'should expect normalized path, but not nativized';
  var srcPath = routinePath + '\\src';
  provider.fileWrite( provider.path.normalize( srcPath ), srcPath );
  var dstPath = routinePath + '\\dst';
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1,
    context : null
  }
  if( !context.providerIsInstanceOf( _.FileProvider.System ) )
  test.shouldThrowErrorOfAnyKind( () => provider.hardLinkAct( o ) );
  else
  test.mustNotThrowError( () => provider.hardLinkAct( o ) );
  provider.filesDelete( routinePath );

  /* - */

  test.case = 'should expect ready options map, no complex arguments preprocessing';
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  var o =
  {
    srcPath : [ srcPath ],
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1,
    context : null
  }
  var expected = _.mapExtend( null, o );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o );
  })
  test.identical( o.srcPath, expected.srcPath );
}

//

function hardLinkAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLinkAct ) )
  {
    test.case = 'hardLinkAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  function linkGroups( paths, groups )
  {
    groups.forEach( ( g ) =>
    {
      var filePathes = g.map( ( i ) => paths[ i ] );
      provider.hardLink({ dstPath : filePathes });
    })
  }

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  var delay = 10;

  if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  delay = provider.systemBitrateTimeGet();

  function makeFiles( names, dirPath, sameTime )
  {
    let ready = new _.Consequence().take( null );
    var paths = names.map( ( name, i ) =>
    {
      var filePath = context.pathFor( path.join( dirPath, name ) );
      provider.fileWrite({ filePath, data : filePath, purging : 1 });

      if( sameTime )
      {
        var time = delay * 1000;
        provider.timeWrite( filePath, time, time );
      }
      else if( i > 0 )
      {
        ready.then( () =>
        {
          return _.time.out( delay ).then( () =>
          {
            provider.fileWrite({ filePath, data : path.name( filePath ) });
            return null;
          })
        })
      }

      return filePath;
    });

    ready.deasync();

    return paths;
  }

  function makeHardLinksToPath( filePath, amount )
  {
    let routinePath = path.join( context.provider.path.dir( filePath ), _.idWithDateAndTime() );
    provider.dirMake( routinePath )
    for( var i = 0; i < amount; i++ )
    provider.hardLink( path.join( routinePath, 'file' + i ), filePath );
  }

  var routinePath = test.context.pathFor( 'written/hardLinkAsync' );
  provider.filesDelete( routinePath );
  var srcPath, dstPath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var fileNames = [ 'a1', 'a2', 'a3' ];
  var currentTestDir = 'written/hardLink/';
  var data = ' ';
  var paths;

  var consequence = new _.Consequence().take( null );

  consequence

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'make link async';
    srcPath  = test.context.pathFor( 'written/hardLinkAsync/link_test.txt' );
    dstPath = test.context.pathFor( 'written/hardLinkAsync/link.txt' );
    provider.fileWrite( srcPath, '000' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath,
      sync : 0,
    })
    .ifNoErrorThen( function( arg )
    {
      provider.fileWrite
      ({
        filePath : srcPath,
        sync : 1,
        data : 'new text',
        writeMode : 'append'
      });
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link.txt', 'link_test.txt' ] )
      var got = provider.fileRead( dstPath );
      var expected = '000new text';
      test.identical( got, expected );
      return null;
    })
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'make for file that not exist';
    provider.filesDelete( routinePath );
    srcPath  = test.context.pathFor( 'written/hardLinkAsync/no_file.txt' );
    dstPath = test.context.pathFor( 'written/hardLinkAsync/link2.txt' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.hardLink
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, null );
      return null;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'link already exists';
    srcPath = test.context.pathFor( 'written/hardLinkAsync/link_test.txt' );
    dstPath = test.context.pathFor( 'written/hardLinkAsync/link.txt' );
    provider.fileWrite( srcPath, 'abc' );
    return provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 0,
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 0,
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link.txt', 'link_test.txt' ] )
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 0,
      sync : 0,
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link.txt', 'link_test.txt' ] )
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 1,
      sync : 0,
    })
    .then( ( got ) =>
    {
      test.identical( got, false );
      if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
      test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
      else
      test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 0,
    });
    return test.mustNotThrowError( con );
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'src is equal to dst';
    provider.filesDelete( routinePath );
    srcPath = test.context.pathFor( 'written/hardLinkAsync/link_test.txt' );
    provider.fileWrite( srcPath, ' ' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link_test.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link_test.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link_test.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link_test.txt' ] );
      return null;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'try make hardLink for folder';
    provider.filesDelete( routinePath );
    srcPath = test.context.pathFor( 'written/hardLinkAsync/link_test' );
    dstPath = test.context.pathFor( 'written/hardLinkAsync/link' );
    provider.dirMake( srcPath );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 0,
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 1,
      sync : 0,
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 0,
      sync : 0,
    });
    return test.mustNotThrowError( con );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 0,
    });
    return test.mustNotThrowError( con );
  });

  /* - */

  if( context.providerIsInstanceOf( _.FileProvider.Extract ) )
  {
    // next section needs time stats from Extract.statResolvedRead, not implemented yet
    return consequence;
  }

  /**/

  consequence.ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, files are not linked';
    var paths = makeFiles( fileNames, currentTestDir );
    return provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
    .finally( () => test.identical( provider.areHardLinked( paths ), hardLinked ) );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, linking files from different dirs';
    paths = fileNames.map( ( n ) => path.join( 'dir_'+ n, n ) );
    paths = makeFiles( paths, currentTestDir );
    return provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
    .finally( () => test.identical( provider.areHardLinked( paths ), hardLinked ) );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, try to link already linked files';
    var paths = makeFiles( fileNames, currentTestDir );
    provider.hardLink
    ({
      sync : 1,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
    // try to link again
    return provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
    .finally( () => test.identical( provider.areHardLinked( paths ), hardLinked ) );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath, rewriting off, try to rewrite existing files';
    var paths = makeFiles( fileNames, currentTestDir );
    var con = provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      rewriting : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( () =>
    {
      var got = provider.hardLink
      ({
        sync : 1,
        dstPath : paths,
        rewriting : 0,
        throwing : 0
      });
      test.identical( got, false );
      return null;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, groups of linked files ';
    fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    provider.filesDelete( test.context.pathFor( currentTestDir ) );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var groups = [ [ 0, 1 ], [ 2, 3, 4 ], [ 5 ] ];
    var paths = makeFiles( fileNames, currentTestDir );
    linkGroups( paths, groups );
    return provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
    .finally( () => test.identical( provider.areHardLinked( paths ), hardLinked ) );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var groups = [ [ 0, 1 ], [ 1, 2, 3 ], [ 3, 4, 5 ] ];
    var paths = makeFiles( fileNames, currentTestDir );
    linkGroups( paths, groups );
    return provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
    .finally( () => test.identical( provider.areHardLinked( paths ), hardLinked ) );
  })

  .ifNoErrorThen( function( arg )
  {
    var groups = [ [ 0, 1, 2, 3 ], [ 4, 5 ] ];
    var paths = makeFiles( fileNames, currentTestDir );
    linkGroups( paths, groups );
    return provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
    .finally( () => test.identical( provider.areHardLinked( paths ), hardLinked ) );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var groups = [ [ 0, 1, 2, 3, 4 ], [ 0, 5 ] ];
    var paths = makeFiles( fileNames, currentTestDir );
    linkGroups( paths, groups );
    return provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
    .finally( () => test.identical( provider.areHardLinked( paths ), hardLinked ) );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, only first path exists';
    var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    provider.filesDelete( test.context.pathFor( currentTestDir ) );
    makeFiles( fileNames.slice( 0, 1 ), currentTestDir );
    var paths = fileNames.map( ( n )  => context.pathFor( path.join( currentTestDir, n ) ) );
    return provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      allowingMissed : 1,
      rewriting : 1,
      throwing : 1
    })
    .finally( () =>
    {
      test.identical( provider.areHardLinked( paths ), hardLinked );
      provider.fileWrite( paths[ paths.length - 1 ], fileNames[ fileNames.length - 1 ] );
      test.identical( provider.fileRead( paths[ 0 ] ), provider.fileRead( paths[ paths.length - 1 ] ) );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, only first path exists';
    var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    provider.filesDelete( test.context.pathFor( currentTestDir ) );
    makeFiles( fileNames.slice( 0, 1 ), currentTestDir );
    var paths = fileNames.map( ( n )  => context.pathFor( path.join( currentTestDir, n ) ) );
    var con = provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      allowingMissed : 0,
      rewriting : 1,
      throwing : 1
    })
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( () =>
    {
      test.identical( provider.areHardLinked( paths ), false );
      test.is( provider.fileExists( paths[ 0 ] ) );
      test.is( !provider.fileExists( paths[ 1 ] ) );
      test.is( !provider.fileExists( paths[ 2 ] ) );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, all paths not exist';
    var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    provider.filesDelete( test.context.pathFor( currentTestDir ) );
    var paths = fileNames.map( ( n )  => context.pathFor( path.join( currentTestDir, n ) ) );
    var con = provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      allowingMissed : 1,
      rewriting : 1,
      throwing : 1
    })
    return test.shouldThrowErrorOfAnyKind( con );
  })

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, all paths not exist';
    var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    provider.filesDelete( test.context.pathFor( currentTestDir ) );
    var paths = fileNames.map( ( n )  => context.pathFor( path.join( currentTestDir, n ) ) );
    debugger
    var con = provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      allowingMissed : 0,
      rewriting : 1,
      throwing : 1
    })
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /* repair */

  /* .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, same date but different content';
    var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    var paths = makeFiles( fileNames, currentTestDir, true );
    provider.hardLink({ dstPath : paths });
    var stat = provider.statResolvedRead( paths[ 0 ] );
    _.time.out( delay ).deasync();
    provider.fileTouch({ filePath : paths[ paths.length - 1 ], purging : 1 });
    provider.fileWrite( paths[ paths.length - 1 ], 'different content' );
    var files = provider.recordFactory().records( paths );
    files[ files.length - 1 ].stat.mtime = files[ 0 ].stat.mtime;
    files[ files.length - 1 ].stat.birthtime = files[ 0 ].stat.birthtime;
    var con = provider.hardLink
    ({
      sync : 0,
      dstPath : files,
      rewriting : 1,
      throwing : 1,
      allowingDiscrepancy : 0
    })
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( () =>
    {
      test.is( !provider.areHardLinked( paths ) );
    });
  })
 */
  /* repair */

  /* .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, same date but different content, allow different files';
    var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    var paths = provider.path.s.normalize( makeFiles( fileNames, currentTestDir ) );
    provider.hardLink({ dstPath : paths });
    var stat = provider.statResolvedRead( paths[ 0 ] );
    _.time.out( delay ).deasync();
    provider.fileTouch({ filePath : paths[ paths.length - 1 ], purging : 1 });
    provider.fileWrite( paths[ paths.length - 1 ], 'different content' );
    var files = provider.recordFactory().records( paths );
    files[ files.length - 1 ].stat.mtime = files[ 0 ].stat.mtime;
    files[ files.length - 1 ].stat.birthtime = files[ 0 ].stat.birthtime;
    return provider.hardLink
    ({
      sync : 0,
      dstPath : files,
      rewriting : 1,
      throwing : 1,
      allowingDiscrepancy : 1
    })
    .finally( () =>
    {
      test.identical( provider.areHardLinked( paths ), null );
    });
  }) */

  /* sourceMode */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'sourceMode: source newest file with min hardlinks count ';
    var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    var paths = makeFiles( fileNames, currentTestDir );
    test.is( paths.length >= 3 );
    makeHardLinksToPath( paths[ 1 ], 3 );
    paths = provider.path.s.normalize( paths );
    var records = provider.recordFactory().records( paths );
    var selectedFile = provider._recordsSort({ src : records, sorter : 'modified>hardlinks<' });
    return provider.hardLink
    ({
      dstPath : paths,
      sourceMode : 'modified>hardlinks<',
      sync : 0
    })
    .ifNoErrorThen( ( arg ) =>
    {
      test.identical( provider.areHardLinked( paths ), hardLinked );
      var srcPath = paths[ paths.length - 1 ];
      test.identical( selectedFile.absolute, provider.path.preferredFromGlobal( srcPath ) );
      var src = provider.fileRead( srcPath );
      var dst = provider.fileRead( paths[ 1 ] );
      test.identical( src, dst )
      return null;
    })
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'sourceMode: source must be a file with max amount of links';
    var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    provider.filesDelete( test.context.pathFor( currentTestDir ) );
    var paths = makeFiles( fileNames, currentTestDir );
    _.time.out( delay ).deasync();
    provider.fileWrite( paths[ 0 ], 'max links file' );
    test.is( paths.length >= 3 );
    makeHardLinksToPath( paths[ 0 ], 3 ); //3 links to a file
    makeHardLinksToPath( paths[ 1 ], 2 ); //2 links to a file
    paths = provider.path.s.normalize( paths );
    var records = provider.recordFactory().records( paths );
    var selectedFile = provider._recordsSort({ src : records, sorter : 'hardlinks>' });
    return provider.hardLink
    ({
      dstPath : paths,
      sync : 0,
      sourceMode : 'hardlinks>'
    })
    .ifNoErrorThen( ( arg ) =>
    {
      test.identical( provider.areHardLinked( paths ), hardLinked );
      var srcPath = paths[ 0 ];
      test.identical( selectedFile.absolute, provider.path.preferredFromGlobal( srcPath ) );
      var dstPath = paths[ 1 ];
      var src = provider.fileRead( srcPath );
      var dst = provider.fileRead( dstPath );
      test.identical( src, 'max links file' );
      test.identical( dst, 'max links file' );
      var srcStat = provider.statResolvedRead( srcPath );
      var dstStat = provider.statResolvedRead( dstPath );
      test.identical( Number( srcStat.nlink ), 9 );
      test.identical( Number( dstStat.nlink ), 9 );
      return null;
    })

  })

  return consequence;
}
hardLinkAsync.timeOut = 60000;

//

function hardLinkActAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLinkAct ) )
  {
    test.case = 'hardLinkAct is not implemented';
    test.identical( 1, 1 );
    return;
  }

  let mp = _.routineJoin( test.context, test.context.pathFor );
  var routinePath = mp( 'hardLinkActSync' );

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  let softLinkIsSupported = test.context.softLinkIsSupported();
  let con = new _.Consequence().take( null )

  /* - */

  .finally( () =>
  {
    test.case = 'basic usage';
    var srcPath = path.join( routinePath, 'src' );
    provider.fileWrite( srcPath, srcPath );
    var dstPath = path.join( routinePath, 'dst' );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 0,
      context : null
    }
    var expected = _.mapOwnKeys( o );
    return test.mustNotThrowError( provider.hardLinkAct( o ) )
    .then( ( got ) =>
    {
      test.identical( got, true );
      if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
      test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
      else
      test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
      got = _.mapOwnKeys( o );
      test.identical( got, expected );
      provider.filesDelete( routinePath );
      return null;
    })
  })

  /* - */

  .finally( () =>
  {
    test.case = 'src does not exist';
    var srcPath = path.join( routinePath, 'src' );
    var dstPath = path.join( routinePath, 'dst' );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 0,
      context : null
    }
    var expected = _.mapOwnKeys( o );
    return test.shouldThrowErrorOfAnyKind( provider.hardLinkAct( o ) )
    .then( ( got ) =>
    {
      test.is( _.errIs( got ) );
      test.is( !provider.areHardLinked( [ srcPath, dstPath ] ) );
      got = _.mapOwnKeys( o );
      test.identical( got, expected );
      provider.filesDelete( routinePath );
      return null;
    })
  })

  /* - */

  .finally( () =>
  {
    test.case = 'src is not a terminal, but dir';
    var srcPath = path.join( routinePath, 'src' );
    provider.dirMake( srcPath );
    var dstPath = path.join( routinePath, 'dst' );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 0,
      context : null
    }
    var expected = _.mapOwnKeys( o );
    return test.shouldThrowErrorOfAnyKind( provider.hardLinkAct( o ) )
    .then( ( got ) =>
    {
      test.is( _.errIs( got ) );
      test.is( !provider.areHardLinked( [ srcPath, dstPath ] ) );
      got = _.mapOwnKeys( o );
      test.identical( got, expected );
      provider.filesDelete( routinePath );
      return null;
    })
  })

  /* - */

  .finally( () =>
  {
    test.case = 'src is not a terminal, but softLink';
    var filePath = path.join( routinePath, 'file' );
    provider.fileWrite( filePath, filePath )
    var srcPath = path.join( routinePath, 'src' );
    provider.softLink( srcPath, filePath );
    var dstPath = path.join( routinePath, 'dst' );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 0,
      context : null
    }
    var expected = _.mapOwnKeys( o );
    return test.shouldThrowErrorOfAnyKind( provider.hardLinkAct( o ) )
    .then( ( got ) =>
    {
      test.is( _.errIs( got ) );
      test.is( !provider.areHardLinked( [ srcPath, dstPath ] ) );
      got = _.mapOwnKeys( o );
      test.identical( got, expected );
      provider.filesDelete( routinePath );
      return null;
    })
  })

  /* - */

  .finally( () =>
  {
    test.case = 'dst already exists';
    var srcPath = path.join( routinePath, 'src' );
    var dstPath = path.join( routinePath, 'dst' );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( dstPath, dstPath );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 0,
      context : null
    }
    var expected = _.mapOwnKeys( o );
    return test.shouldThrowErrorOfAnyKind( provider.hardLinkAct( o ) )
    .then( ( got ) =>
    {
      test.is( _.errIs( got ) );
      test.is( !provider.areHardLinked( [ srcPath, dstPath ] ) );
      got = _.mapOwnKeys( o );
      test.identical( got, expected );
      provider.filesDelete( routinePath );
      return null;
    })
  })

  /* - */

  .finally( () =>
  {
    test.case = 'same path';
    var srcPath = path.join( routinePath, 'src' );
    var dstPath = path.join( routinePath, 'src' );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 0,
      context : null
    }
    var expected = _.mapOwnKeys( o );
    return test.mustNotThrowError( provider.hardLinkAct( o ) )
    .then( ( got ) =>
    {
      test.identical( got, true );
      test.is( !provider.isHardLink( dstPath ) );
      got = _.mapOwnKeys( o );
      test.identical( got, expected );
      return null;
    })
  })

  /* - */

  .finally( () =>
  {
    test.case = 'src is hardLink';
    var filePath = path.join( routinePath, 'file' );
    provider.fileWrite( filePath, filePath )
    var srcPath = path.join( routinePath, 'src' );
    provider.hardLink( srcPath, filePath );
    var dstPath = path.join( routinePath, 'dst' );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 0,
      context : null
    }
    var expected = _.mapOwnKeys( o );
    return test.mustNotThrowError( provider.hardLinkAct( o ) )
    .then( ( got ) =>
    {
      test.identical( got, true );
      if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
      test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
      else
      test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
      got = _.mapOwnKeys( o );
      test.identical( got, expected );
      provider.filesDelete( routinePath );
      return null;
    })
  })

  .finally( () =>
  {
    test.case = 'create link in not existing directory';
    var srcPath = path.join( routinePath, 'src' );
    var dstMissingPath = path.join( routinePath, 'dir/dst' );
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    var o =
    {
      srcPath,
      dstPath : dstMissingPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstMissingPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 0,
      sync : 0,
      context : null
    }
    return test.shouldThrowErrorAsync( provider.hardLinkAct( o ) )
    .then( () =>
    {
      test.will = 'parent directory of dstPath must not be created';
      test.is( !provider.fileExists( path.dir( dstMissingPath ) ) );
      return null;
    })
  })

  /* - */

  .finally( () =>
  {
    test.case = 'use terminal as parent directory';
    var srcPath = path.join( routinePath, 'src' );
    var dstPath2 = path.join( srcPath, 'dst' );
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    var o =
    {
      srcPath,
      dstPath : dstPath2,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath2,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 0,
      sync : 0,
      context : null
    }
    return test.shouldThrowErrorAsync( provider.hardLinkAct( o ) )
    .then( () =>
    {
      test.is( provider.isTerminal( srcPath ) );
      test.is( !provider.fileExists( dstPath2 ) );
      return null;
    })
  })

  return con;
}

//

function fileExchangeSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileExchange ) || !_.routineIs( provider.statReadAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var routinePath = test.context.pathFor( 'written/fileExchange' );
  var srcPath, dstPath, src, dst, got;
  var srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  var dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  /* - */

  test.case = 'swap two files content';
  srcPath = test.context.pathFor( 'written/fileExchange/src' );
  dstPath = test.context.pathFor( 'written/fileExchange/dst' );


  /*default setting*/

  provider.fileWrite( srcPath, 'src' );
  provider.fileWrite( dstPath, 'dst' );
  provider.fileExchange( dstPath, srcPath );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst', 'src' ] );
  src = provider.fileRead( srcPath );
  dst = provider.fileRead( dstPath );
  test.identical( [ src, dst ], [ 'dst', 'src' ] )

  /**/

  provider.fileWrite( srcPath, 'src' );
  provider.fileWrite( dstPath, 'dst' );
  provider.fileExchange
  ({
    srcPath,
    dstPath,
    sync : 1,
    throwing : 0
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst', 'src' ] );
  src = provider.fileRead( srcPath );
  dst = provider.fileRead( dstPath );
  test.identical( [ src, dst ], [ 'dst', 'src' ] )

  /* - */

  test.case = 'swap two dirs content';
  srcPath = test.context.pathFor( 'written/fileExchange/src/src.txt' );
  dstPath = test.context.pathFor( 'written/fileExchange/dst/dst.txt' );

  /*throwing on*/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, 'src' );
  provider.fileWrite( dstPath, 'dst' );
  provider.fileExchange
  ({
    srcPath : context.provider.path.dir( srcPath ),
    dstPath : context.provider.path.dir( dstPath ),
    sync : 1,
    throwing : 1
  });
  src = provider.dirRead( context.provider.path.dir( srcPath ) );
  dst = provider.dirRead( context.provider.path.dir( dstPath ) );
  test.identical( [ src, dst ], [ [ 'dst.txt' ], [ 'src.txt' ] ] );
  src = provider.fileRead( _.strReplaceAll( srcPath, 'src.txt', 'dst.txt' ) );
  dst = provider.fileRead( _.strReplaceAll( dstPath, 'dst.txt', 'src.txt' ) );
  test.identical( [ src, dst ], [ 'dst', 'src' ] );

  /*throwing off*/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, 'src' );
  provider.fileWrite( dstPath, 'dst' );
  provider.fileExchange
  ({
    srcPath : context.provider.path.dir( srcPath ),
    dstPath : context.provider.path.dir( dstPath ),
    sync : 1,
    throwing : 1
  });
  src = provider.dirRead( context.provider.path.dir( srcPath ) );
  dst = provider.dirRead( context.provider.path.dir( dstPath ) );
  test.identical( [ src, dst ], [ [ 'dst.txt' ], [ 'src.txt' ] ] );
  src = provider.fileRead( _.strReplaceAll( srcPath, 'src.txt', 'dst.txt' ) );
  dst = provider.fileRead( _.strReplaceAll( dstPath, 'dst.txt', 'src.txt' ) );
  test.identical( [ src, dst ], [ 'dst', 'src' ] );

  /* - */

  test.case = 'path not exist';
  srcPath = test.context.pathFor( 'written/fileExchange/src' );
  dstPath = test.context.pathFor( 'written/fileExchange/dst' );

  /*src not exist, throwing on*/

  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, 'dst' );
  test.shouldThrowErrorSync( function()
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 0,
      throwing : 1
    });
  });
  var files  = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /*src not exist, throwing on, allowingMissed on*/

  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, 'dst' );
  test.mustNotThrowError( function()
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 1,
      throwing : 1
    });
  });
  var files  = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /*src not exist, throwing off, allowingMissed on*/

  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, 'dst' );
  test.mustNotThrowError( function()
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 1,
      throwing : 0
    });
  });
  var files  = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /*dst not exist, throwing on, allowingMissed off*/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, 'src' );
  test.shouldThrowErrorSync( function()
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 0,
      throwing : 1
    });
  });
  var files  = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /*dst not exist, throwing off, allowingMissed on*/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, 'src' );
  test.mustNotThrowError( function()
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 1,
      throwing : 0
    });
  });
  var files  = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /*dst not exist, throwing on, allowingMissed on*/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, 'src' );
  test.mustNotThrowError( function()
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 1,
      throwing : 1
    });
  });
  var files  = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /*dst not exist, throwing off, allowingMissed off*/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, 'src' );
  test.mustNotThrowError( function()
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 0,
      throwing : 0
    });
  });
  var files  = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /*dst & src not exist, throwing on, allowingMissed on*/

  provider.filesDelete( routinePath );
  test.mustNotThrowError( function()
  {
    got = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 1,
      throwing : 1
    });
  });
  test.identical( got, null );

  /*dst & src not exist, throwing off, allowingMissed off*/

  // provider.filesDelete( routinePath );
  test.mustNotThrowError( function()
  {
    got = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 1,
      throwing : 0
    });
  });
  test.identical( got, null );

  /*dst & src not exist, throwing on, allowingMissed off*/

  // provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( function()
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 0,
      throwing : 1
    });
  });

  /*dst & src not exist, throwing off, allowingMissed off*/

  // provider.filesDelete( routinePath );
  test.mustNotThrowError( function()
  {
    got = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 0,
      throwing : 0
    });
  });
  test.identical( got, null );

  /* - */

  test.case = 'two soft links to terminals';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  provider.fileExchange
  ({
    srcPath,
    dstPath,
    sync : 1,
    allowingMissed : 0,
    throwing : 1
  });
  var src = provider.fileRead( srcPath );
  test.identical( src, dstPathTerminal );
  var dst = provider.fileRead( dstPath );
  test.identical( dst, srcPathTerminal );

  /* - */

  test.case = 'two text links to terminals';
  provider.fieldPush( 'resolvingTextLink', 1 );
  provider.fieldPush( 'usingTextLink', 1 );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.textLink( srcPath, srcPathTerminal );
  provider.textLink( dstPath, dstPathTerminal );
  provider.fileExchange
  ({
    srcPath,
    dstPath,
    sync : 1,
    allowingMissed : 0,
    throwing : 1
  });
  var src = provider.fileRead( srcPath );
  test.identical( src, dstPathTerminal );
  var dst = provider.fileRead( dstPath );
  test.identical( dst, srcPathTerminal );
  provider.fieldPop( 'resolvingTextLink', 1 );
  provider.fieldPop( 'usingTextLink', 1 );

  /* - */

  test.case = 'two soft links to missing, not allowed';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 0,
      throwing : 1
    });
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  test.is( !provider.fileExists( srcPathTerminal ) );
  test.is( !provider.fileExists( dstPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal )
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal )

  /* - */

  test.case = 'two soft links to missing, allowed';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1, makingDirectory : 1 });
  provider.fileExchange
  ({
    srcPath,
    dstPath,
    sync : 1,
    allowingMissed : 1,
    throwing : 1
  });
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  test.is( !provider.fileExists( srcPathTerminal ) );
  test.is( !provider.fileExists( dstPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );

  /* - */

  test.case = 'soft link and terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal });
  provider.fileExchange
  ({
    srcPath,
    dstPath : dstPathTerminal,
    sync : 1,
    allowingMissed : 0,
    throwing : 1
  });
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), dstPathTerminal );
  test.identical( provider.fileRead( srcPathTerminal ), dstPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );

  test.case = 'terminal and soft link';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink({ dstPath, srcPath : dstPathTerminal });
  provider.fileExchange
  ({
    srcPath : srcPathTerminal,
    dstPath,
    sync : 1,
    allowingMissed : 0,
    throwing : 1
  });
  test.is( provider.fileExists( srcPathTerminal ) );
  test.is( provider.fileExists( dstPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.fileRead( srcPathTerminal ), dstPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  // cycled links

  srcPath = path.join( routinePath, 'src' );
  dstPath = path.join( routinePath, 'dst' );

  test.case = 'two context cycled soft links, cycled allowed';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  provider.fileExchange
  ({
    srcPath,
    dstPath,
    sync : 1,
    allowingMissed : 0,
    allowingCycled : 1,
    throwing : 1
  });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../dst' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );

  test.case = 'two context cycled soft links, cycled not allowed';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 0,
      allowingCycled : 0,
      throwing : 1
    });
  })
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );

  test.case = 'two context cycled soft links, cycled not allowed, throwing off';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  got = provider.fileExchange
  ({
    srcPath,
    dstPath,
    sync : 1,
    allowingMissed : 0,
    allowingCycled : 0,
    throwing : 0
  });
  test.identical( got, null );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );

  test.case = 'context cycled and terminal, cycled allowed';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
  provider.fileWrite( dstPathTerminal, dstPathTerminal )
  provider.fileExchange
  ({
    srcPath,
    dstPath : dstPathTerminal,
    sync : 1,
    allowingMissed : 0,
    allowingCycled : 1,
    throwing : 1
  });
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.identical( provider.fileRead( srcPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), test.context.globalFromPreferred( '../src' ) );

  test.case = 'context cycled and terminal, cycled not allowed';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
  provider.fileWrite( dstPathTerminal, dstPathTerminal )
  test.shouldThrowErrorSync( () =>
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath : dstPathTerminal,
      sync : 1,
      allowingMissed : 0,
      allowingCycled : 0,
      throwing : 1
    });
  })
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );

  test.case = 'context cycled and terminal, cycled not allowed, throwing off';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
  provider.fileWrite( dstPathTerminal, dstPathTerminal )
  got = provider.fileExchange
  ({
    srcPath,
    dstPath : dstPathTerminal,
    sync : 1,
    allowingMissed : 0,
    allowingCycled : 0,
    throwing : 0
  });
  test.identical( got, null );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );

}

//

function fileExchangeAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileExchange ) || !_.routineIs( provider.statReadAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var routinePath = test.context.pathFor( 'written/fileExchangeAsync' );
  var srcPath, dstPath, src, dst, got,
    srcPathTerminal, dstPathTerminal;

  srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var consequence = new _.Consequence().take( null );

  consequence

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'swap two files content';
    srcPath = test.context.pathFor( 'written/fileExchangeAsync/src' );
    dstPath = test.context.pathFor( 'written/fileExchangeAsync/dst' );
    return null;
  })

  /*default setting*/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( srcPath, 'src' );
    provider.fileWrite( dstPath, 'dst' );
    return provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 1
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst', 'src' ] );
      src = provider.fileRead( srcPath );
      dst = provider.fileRead( dstPath );
      test.identical( [ src, dst ], [ 'dst', 'src' ] )
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( srcPath, 'src' );
    provider.fileWrite( dstPath, 'dst' );
    return provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 0
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst', 'src' ] );
      src = provider.fileRead( srcPath );
      dst = provider.fileRead( dstPath );
      test.identical( [ src, dst ], [ 'dst', 'src' ] )
      return null;
    })
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'swap two dirs content';
    srcPath = test.context.pathFor( 'written/fileExchangeAsync/src/src.txt' );
    dstPath = test.context.pathFor( 'written/fileExchangeAsync/dst/dst.txt' );
    return null;
  })

  /*throwing on*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, 'src' );
    provider.fileWrite( dstPath, 'dst' );
    return provider.fileExchange
    ({
      srcPath : context.provider.path.dir( srcPath ),
      dstPath : context.provider.path.dir( dstPath ),
      sync : 0,
      allowingMissed : 1,
      throwing : 1
    })
    .ifNoErrorThen( function( arg )
    {
      src = provider.dirRead( context.provider.path.dir( srcPath ) );
      dst = provider.dirRead( context.provider.path.dir( dstPath ) );
      test.identical( [ src, dst ], [ [ 'dst.txt' ], [ 'src.txt' ] ] );
      src = provider.fileRead( _.strReplaceAll( srcPath, 'src.txt', 'dst.txt' ) );
      dst = provider.fileRead( _.strReplaceAll( dstPath, 'dst.txt', 'src.txt' ) );
      test.identical( [ src, dst ], [ 'dst', 'src' ] );
      return null;
    });
  })

  /*throwing off*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, 'src' );
    provider.fileWrite( dstPath, 'dst' );
    return provider.fileExchange
    ({
      srcPath : context.provider.path.dir( srcPath ),
      dstPath : context.provider.path.dir( dstPath ),
      sync : 0,
      allowingMissed : 1,
      throwing : 0
    })
    .ifNoErrorThen( function( arg )
    {
      src = provider.dirRead( context.provider.path.dir( srcPath ) );
      dst = provider.dirRead( context.provider.path.dir( dstPath ) );
      test.identical( [ src, dst ], [ [ 'dst.txt' ], [ 'src.txt' ] ] );
      src = provider.fileRead( _.strReplaceAll( srcPath, 'src.txt', 'dst.txt' ) );
      dst = provider.fileRead( _.strReplaceAll( dstPath, 'dst.txt', 'src.txt' ) );
      test.identical( [ src, dst ], [ 'dst', 'src' ] );
      return null;
    });
  })

  /* - */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'path not exist';
    srcPath = test.context.pathFor( 'written/fileExchangeAsync/src' );
    dstPath = test.context.pathFor( 'written/fileExchangeAsync/dst' );
    return null;
  })

  /*src not exist, throwing on*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, 'dst' );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( function()
    {
      var files  = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return null;
    });
  })

  /*src not exist, throwing on, allowingMissed on*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, 'dst' );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files  = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return null;
    });
  })

  /*src not exist, throwing off, allowingMissed on*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, 'dst' );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files  = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return null;
    });
  })

  /*dst not exist, throwing on, allowingMissed off*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, 'src' );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( function()
    {
      var files  = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return null;
    });
  })

  /*dst not exist, throwing off, allowingMissed on*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, 'src' );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files  = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return null;
    });
  })

  /*dst not exist, throwing on, allowingMissed on*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, 'src' );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files  = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return null;
    });
  })

  /*dst not exist, throwing off, allowingMissed off*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, 'src' );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files  = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return null;
    });
  })

  /*dst & src not exist, throwing on, allowingMissed on*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      return null;
    });
  })

  /*dst & src not exist, throwing off, allowingMissed off*/

  .ifNoErrorThen( function( arg )
  {
    // provider.filesDelete( routinePath );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      return null;
    });
  })

  /*dst & src not exist, throwing on, allowingMissed off*/

  .ifNoErrorThen( function( arg )
  {
    // provider.filesDelete( routinePath );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /*dst & src not exist, throwing off, allowingMissed off*/

  .finally( function()
  {
    // provider.filesDelete( routinePath );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      return null;
    })
  })

  .then( () =>
  {
    test.case = 'two soft links to terminals';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPathTerminal, srcPathTerminal );
    provider.fileWrite( dstPathTerminal, dstPathTerminal );
    provider.softLink( srcPath, srcPathTerminal );
    provider.softLink( dstPath, dstPathTerminal );
    return provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    })
    .then( ( got ) =>
    {
      var src = provider.fileRead( srcPath );
      test.identical( src, dstPathTerminal );
      var dst = provider.fileRead( dstPath );
      test.identical( dst, srcPathTerminal );
      return got;
    })

  })

  /* - */

  .then( () =>
  {
    test.case = 'two text links to terminals';
    provider.fieldPush( 'resolvingTextLink', 1 );
    provider.fieldPush( 'usingTextLink', 1 );
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPathTerminal, srcPathTerminal );
    provider.fileWrite( dstPathTerminal, dstPathTerminal );
    provider.textLink( srcPath, srcPathTerminal );
    provider.textLink( dstPath, dstPathTerminal );
    return provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    })
    .then( ( got ) =>
    {
      var src = provider.fileRead( srcPath );
      test.identical( src, dstPathTerminal );
      var dst = provider.fileRead( dstPath );
      test.identical( dst, srcPathTerminal );
      provider.fieldPop( 'resolvingTextLink', 1 );
      provider.fieldPop( 'usingTextLink', 1 );
      return got;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'two soft links to missing, not allowed';
    provider.filesDelete( routinePath );
    provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1, makingDirectory : 1 });
    provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1, makingDirectory : 1 });
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con )
    .then( () =>
    {
      test.is( provider.fileExists( srcPath ) );
      test.is( provider.fileExists( dstPath ) );
      test.is( !provider.fileExists( srcPathTerminal ) );
      test.is( !provider.fileExists( dstPathTerminal ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal )
      test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal )
      return null;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'two soft links to missing, allowed';
    provider.filesDelete( routinePath );
    provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1, makingDirectory : 1 });
    provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1, makingDirectory : 1 });
    return provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 1
    })
    .then( ( got ) =>
    {
      test.is( provider.fileExists( srcPath ) );
      test.is( provider.fileExists( dstPath ) );
      test.is( !provider.fileExists( srcPathTerminal ) );
      test.is( !provider.fileExists( dstPathTerminal ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
      test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
      return got;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'soft link and terminal';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPathTerminal, srcPathTerminal );
    provider.fileWrite( dstPathTerminal, dstPathTerminal );
    provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal });
    return provider.fileExchange
    ({
      srcPath,
      dstPath : dstPathTerminal,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    })
    .then( ( got ) =>
    {
      test.is( provider.fileExists( srcPath ) );
      test.is( provider.fileExists( dstPathTerminal ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
      test.identical( provider.fileRead( srcPath ), dstPathTerminal );
      test.identical( provider.fileRead( srcPathTerminal ), dstPathTerminal );
      test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );
      return got;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'terminal and soft link';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPathTerminal, srcPathTerminal );
    provider.fileWrite( dstPathTerminal, dstPathTerminal );
    provider.softLink({ dstPath, srcPath : dstPathTerminal });
    return provider.fileExchange
    ({
      srcPath : srcPathTerminal,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    })
    .then( ( got ) =>
    {
      test.is( provider.fileExists( srcPathTerminal ) );
      test.is( provider.fileExists( dstPathTerminal ) );
      test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
      test.identical( provider.fileRead( srcPathTerminal ), dstPathTerminal );
      test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );
      test.identical( provider.fileRead( dstPath ), srcPathTerminal );
      return got;
    })
  })

  //cycled links

  .then( () =>
  {
    test.case = 'two context cycled soft links, cycled allowed';
    provider.filesDelete( routinePath );
    provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
    provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
    return provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      allowingCycled : 1,
      throwing : 1
    })
    .then( ( got ) =>
    {
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../dst' ) );
      test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
      return got;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'two context cycled soft links, cycled not allowed';
    provider.filesDelete( routinePath );
    provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
    provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
    let con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      allowingCycled : 0,
      throwing : 1
    });
    return test.shouldThrowErrorAsync( con )
    .then( () =>
    {
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
      test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
      return null;
    })

  })

  /* - */

  .then( () =>
  {
    test.case = 'two context cycled soft links, cycled not allowed, throwing off';
    provider.filesDelete( routinePath );
    provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
    provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
    return provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      allowingCycled : 0,
      throwing : 0
    })
    .then( ( got ) =>
    {
      test.identical( got, null );
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
      test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
      return null;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'context cycled and terminal, cycled allowed';
    provider.filesDelete( routinePath );
    provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
    provider.fileWrite( dstPathTerminal, dstPathTerminal )
    return provider.fileExchange
    ({
      srcPath,
      dstPath : dstPathTerminal,
      sync : 0,
      allowingMissed : 0,
      allowingCycled : 1,
      throwing : 1
    })
    .then( ( got ) =>
    {
      test.is( provider.isTerminal( srcPath ) );
      test.is( provider.isSoftLink( dstPathTerminal ) );
      test.identical( provider.fileRead( srcPath ), dstPathTerminal );
      test.identical( provider.pathResolveSoftLink( dstPathTerminal ), test.context.globalFromPreferred( '../src' ) );
      return got;
    })

  })

  /* - */

  .then( () =>
  {
    test.case = 'context cycled and terminal, cycled not allowed';
    provider.filesDelete( routinePath );
    provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
    provider.fileWrite( dstPathTerminal, dstPathTerminal )
    let con = provider.fileExchange
    ({
      srcPath,
      dstPath : dstPathTerminal,
      sync : 0,
      allowingMissed : 0,
      allowingCycled : 0,
      throwing : 1
    });
    return test.shouldThrowErrorAsync( con )
    .then( () =>
    {
      test.is( provider.isTerminal( dstPathTerminal ) );
      test.is( provider.isSoftLink( srcPath ) );
      test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );
      test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
      return null;
    })
  })

  /* - */

  .then( () =>
  {
    test.case = 'context cycled and terminal, cycled not allowed, throwing off';
    provider.filesDelete( routinePath );
    provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
    provider.fileWrite( dstPathTerminal, dstPathTerminal )
    return provider.fileExchange
    ({
      srcPath,
      dstPath : dstPathTerminal,
      sync : 0,
      allowingMissed : 0,
      allowingCycled : 0,
      throwing : 0
    })
    .then( ( got ) =>
    {
      test.identical( got, null );
      test.is( provider.isTerminal( dstPathTerminal ) );
      test.is( provider.isSoftLink( srcPath ) );
      test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );
      test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
      return null;
    })
  })

  return consequence;

}

//

function hardLinkSoftLinkResolving( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLink ) )
  {
    test.identical( 1, 1 );
    return;
  }

  /*
  resolvingSrcSoftLink : [ 0, 1 ]
  resolvingDstSoftLink : [ 0, 1 ]
  link : [ normal, double, broken, context cycled, cycled, dst and src resolving to the same file ]
  */

  function hardLink( o )
  {
    let o2 =
    {
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1
    }
    _.mapSupplement( o, o2 );
    return provider.hardLink( o );
  }

  let routinePath = test.context.pathFor( 'written/fileRenameSoftLinkResolving' );
  let srcPath = provider.path.join( routinePath, 'src' );
  let srcPath2 = provider.path.join( routinePath, 'src2' );
  let dstPath = provider.path.join( routinePath, 'dst' );
  let dstPath2 = provider.path.join( routinePath, 'dst2' );
  let srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  let dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  /**/

  test.open( 'normal' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  hardLink( o )
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  hardLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  hardLink( o )
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  hardLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  test.close( 'normal' );

  /**/

  test.open( 'double' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  hardLink( o )
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  hardLink( o );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  hardLink( o );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  hardLink( o );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  test.close( 'double' );

  /**/

  test.open( 'broken' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  hardLink( o )
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  hardLink( o )
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'broken' );

  /**/

  test.open( 'context cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  hardLink( o );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  hardLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'context cycled' );

  /* */

  test.open( 'cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  hardLink( o )
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  hardLink( o )
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'cycled' );

  /**/

  test.open( 'links to same file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  hardLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  hardLink( o );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  hardLink( o );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPathTerminal ), srcPath );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  hardLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, srcPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  test.close( 'links to same file' );
}

//

function hardLinkHardLinkBreaking( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLink ) )
  {
    test.identical( 1, 1 );
    return;
  }

  /*
  resolvingSrcSoftLink : [ 0, 1 ]
  resolvingDstSoftLink : [ 0, 1 ]
  link : [ normal, double, broken, context cycled, cycled, dst and src resolving to the same file ]
  */

  function hardLink( o )
  {
    let o2 =
    {
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1,
      throwing : 1
    }
    _.mapSupplement( o, o2 )
    return provider.hardLink( o );
  }

  let routinePath = test.context.pathFor( 'written/hardLinkHardLinkBreaking' );
  let srcPath = provider.path.join( routinePath, 'src' );
  let srcPath2 = provider.path.join( routinePath, 'src2' );
  let dstPath = provider.path.join( routinePath, 'dst' );
  let dstPath2 = provider.path.join( routinePath, 'dst2' );
  let srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  let dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  // /*  */

  test.case = 'src - terminal, dst - hardlink';

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 0, breakingDstHardLink : 0 };
  test.shouldThrowErrorSync( () => hardLink( o ) );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( provider.areHardLinked([ dstPath, dstPathTerminal ]), hardLinked );
  }
  else
  {
    test.identical( provider.areHardLinked([ dstPath, dstPathTerminal ]), true );
  }
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), false );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 0 };
  hardLink( o );
  test.identical( provider.areHardLinked([ srcPath, dstPath, dstPathTerminal ]), hardLinked );
  test.identical( provider.fileRead( srcPath ), srcPath );
  test.identical( provider.fileRead( dstPath ), srcPath );
  test.identical( provider.fileRead( dstPathTerminal ), srcPath );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 0, breakingDstHardLink : 1 };
  hardLink( o );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( provider.areHardLinked([ srcPath, dstPath ]), hardLinked );
  }
  else
  {
    test.identical( provider.areHardLinked([ srcPath, dstPath ]), true );
  }
  test.identical( provider.areHardLinked([ dstPath, dstPathTerminal ]), false );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 1 };
  hardLink( o );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( provider.areHardLinked([ srcPath, dstPath ]), hardLinked );
  }
  else
  {
    test.identical( provider.areHardLinked([ srcPath, dstPath ]), true );
  }
  test.identical( provider.areHardLinked([ dstPath, dstPathTerminal ]), false );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 1, rewriting : 0 };
  test.shouldThrowErrorSync( () => hardLink( o ) );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( provider.areHardLinked([ dstPath, dstPathTerminal ]), hardLinked );
  }
  else
  {
    test.identical( provider.areHardLinked([ dstPath, dstPathTerminal ]), true );
  }
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), false );

  test.case = 'src - hardlink, dst - terminal';

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPath, dstPath );
  provider.hardLink( srcPath, srcPathTerminal );
  var o = { breakingSrcHardLink : 0, breakingDstHardLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( provider.areHardLinked([ srcPath, srcPathTerminal ]), hardLinked );
  }
  else
  {
    test.identical( provider.areHardLinked([ srcPath, srcPathTerminal ]), true );
  }
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), false );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPath, dstPath );
  provider.hardLink( srcPath, srcPathTerminal );
  var o = { breakingSrcHardLink : 0, breakingDstHardLink : 1 };
  hardLink( o );
  test.identical( provider.areHardLinked([ srcPath, srcPathTerminal ]), hardLinked );
  test.identical( provider.areHardLinked([ dstPath, srcPathTerminal ]), hardLinked );
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), hardLinked );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPath, dstPath );
  provider.hardLink( srcPath, srcPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 0 };
  debugger
  hardLink( o );
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), hardLinked );
  test.identical( provider.areHardLinked([ srcPath, srcPathTerminal ]), false );
  test.identical( provider.areHardLinked([ dstPath, srcPathTerminal ]), false );


  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPath, dstPath );
  provider.hardLink( srcPath, srcPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 1 };
  hardLink( o );
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), hardLinked );
  test.identical( provider.areHardLinked([ srcPath, srcPathTerminal ]), false );
  test.identical( provider.areHardLinked([ dstPath, srcPathTerminal ]), false );

  test.case = 'src - hardlink, dst - missing';

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.hardLink( srcPath, srcPathTerminal );
  var o = { breakingSrcHardLink : 0, breakingDstHardLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  test.identical( provider.areHardLinked([ srcPath, srcPathTerminal ]), hardLinked );
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), false );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.hardLink( srcPath, srcPathTerminal );
  var o = { breakingSrcHardLink : 0, breakingDstHardLink : 1 };
  hardLink( o );
  test.identical( provider.areHardLinked([ srcPath, srcPathTerminal ]), hardLinked );
  test.identical( provider.areHardLinked([ dstPath, srcPathTerminal ]), hardLinked );
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), hardLinked );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.hardLink( srcPath, srcPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 0 };
  hardLink( o );
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), hardLinked );
  test.identical( provider.areHardLinked([ srcPath, srcPathTerminal ]), false );
  test.identical( provider.areHardLinked([ dstPath, srcPathTerminal ]), false );


  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.hardLink( srcPath, srcPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 1 };
  hardLink( o );
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), hardLinked );
  test.identical( provider.areHardLinked([ srcPath, srcPathTerminal ]), false );
  test.identical( provider.areHardLinked([ dstPath, srcPathTerminal ]), false );

  test.case = 'src - hardlink, dst - hardlink';

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( srcPath, srcPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 0, breakingDstHardLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  test.identical( provider.areHardLinked([ srcPath, srcPathTerminal ]), hardLinked );
  test.identical( provider.areHardLinked([ dstPath, dstPathTerminal ]), hardLinked );
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), false );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( srcPath, srcPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 0 };
  hardLink( o );
  test.identical( provider.areHardLinked([ srcPath, srcPathTerminal ]), false );
  test.identical( provider.areHardLinked([ dstPath, dstPathTerminal ]), hardLinked );
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), hardLinked );
  test.identical( provider.areHardLinked([ srcPath, dstPath, dstPathTerminal ]), hardLinked );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( srcPath, srcPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 0, breakingDstHardLink : 1 };
  hardLink( o );
  test.identical( provider.areHardLinked([ srcPath, srcPathTerminal ]), hardLinked );
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), hardLinked );
  test.identical( provider.areHardLinked([ srcPathTerminal, dstPath ]), hardLinked );
  test.identical( provider.areHardLinked([ dstPath, dstPathTerminal ]), false );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( srcPath, srcPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 1 };
  hardLink( o )
  test.identical( provider.areHardLinked([ srcPath, srcPathTerminal ]), false );
  test.identical( provider.areHardLinked([ dstPath, dstPathTerminal ]), false );
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), hardLinked );

}

//

function hardLinkResolvingBasic( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLink ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/hardLinkResolvingBasic' );
  let src1Path = test.context.pathFor( 'written/hardLinkResolvingBasic/src1' );
  let src2Path = test.context.pathFor( 'written/hardLinkResolvingBasic/src2' );
  let src3Path = test.context.pathFor( 'written/hardLinkResolvingBasic/src3' );
  let dstPath = test.context.pathFor( 'written/hardLinkResolvingBasic/dst' );

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  /*
      src1 -> src2 -> src3
      resolvingSrcSoftLink : 0
      hardLink
        - soft link dst -> src1

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 1
      hardLink
        - soft link dst -> src3

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 2
      hardLink
        - hard link dst -> src3
  */

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src3Path );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.areHardLinked([ src3Path, dstPath ]), hardLinked )

  /* */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, src3Path );
  provider.textLink( src1Path, src2Path );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, src3Path );
  provider.textLink( src1Path, src2Path );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src3Path );

  test.case = 'resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, src3Path );
  provider.textLink( src1Path, src2Path );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 2 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.areHardLinked([ src3Path, dstPath ]), hardLinked )

  provider.fieldPop( 'usingTextLink', 1 );

}

function hardLinkGlobal( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( provider instanceof _.FileProvider.System )
  {
    test.identical( 1, 1 )
    return;
  }

  let routinePath = test.context.pathFor( 'written/hardLinkGlobal' );
  let srcPath = test.context.pathFor( 'written/hardLinkGlobal/src' );
  let dstPath = test.context.pathFor( 'written/hardLinkGlobal/dst' );

  var srcPathDefault = path.globalFromPreferred( srcPath );
  var dstPathDefault = path.globalFromPreferred( dstPath );

  var srcPathSecond = 'second://' + srcPath;
  var dstPathSecond = 'second://' + dstPath;

  var dstPathUnknown = 'unknown://' + dstPath;

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  /*  */

  test.open( 'with system' );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.hardLink( dstPathDefault, srcPathDefault );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), hardLinked );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.hardLink( dstPathSecond, srcPathSecond );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), hardLinked );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.hardLink( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.close( 'with system' );

  /* */

  test.open( 'without system' );

  context.system.providerUnregister( provider );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.hardLink( dstPathDefault, srcPathDefault );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), hardLinked );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.hardLink( dstPathSecond, srcPathSecond );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.areHardLinked([ srcPath, dstPath ]), hardLinked );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.hardLink( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  context.system.providerRegister( provider );

  test.close( 'without system' );

}

//

function hardLinkRelativeSoftLinking( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLink ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/hardLinkRelativeSoftLinking' );
  let src1Path = test.context.pathFor( 'written/hardLinkRelativeSoftLinking/src1' );
  let src2Path = test.context.pathFor( 'written/hardLinkRelativeSoftLinking/src2' );
  let src3Path = test.context.pathFor( 'written/hardLinkRelativeSoftLinking/src3' );
  let dstPath = test.context.pathFor( 'written/hardLinkRelativeSoftLinking/dst' );

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  /*
    src1 -> ../src2
    hardLink dst src1
    resolvingSrcSoftLink : 0
    - link dst -> src1

    src1 -> ../src2
    hardLink dst src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 -> ../src2
    hardLink dst ../src1
    resolvingSrcSoftLink : 0
    - link dst -> ../src1

    src1 -> ../src2
    hardLink dst ../src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 as :
    - missing file
    - link

    src2 as :
    - terminal
    - intermediate link
    - missing

  */

  /*  */

  test.case = 'relative link to dir';
  provider.filesDelete( routinePath );
  provider.dirMake( src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isDir( src2Path ) );
  test.is( provider.isDir( dstPath ) );
  test.identical( provider.dirRead( dstPath ), [] );


  /* src1 missing */

  test.case = '../src1 is missing, allowingMissed:0';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = '../src1 is missing, allowingMissed:1';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 0,
      allowingMissed : 1
    });
  })
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /*  */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.areHardLinked([ dstPath, src2Path ]), hardLinked );

  /* */

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.areHardLinked([ dstPath, src2Path ]), hardLinked );

  /* missing absolute src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink
  ({
    srcPath : src1Path,
    dstPath,
    resolvingSrcSoftLink : 2,
    resolvingSrcTextLink : 0,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /* missing relative src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /* chain */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.areHardLinked([ dstPath, src3Path ]), hardLinked );


  /*  */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.areHardLinked([ dstPath, src3Path ]), hardLinked );
}

//

function hardLinkRelativeTextLinking( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLink ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/hardLinkRelativeTextLinking' );
  let src1Path = test.context.pathFor( 'written/hardLinkRelativeTextLinking/src1' );
  let src2Path = test.context.pathFor( 'written/hardLinkRelativeTextLinking/src2' );
  let src3Path = test.context.pathFor( 'written/hardLinkRelativeTextLinking/src3' );
  let dstPath = test.context.pathFor( 'written/hardLinkRelativeTextLinking/dst' );

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  /*
    src1 -> ../src2
    hardLink dst src1
    resolvingSrcTextLink : 0
    - link dst -> src1

    src1 -> ../src2
    hardLink dst src1
    resolvingSrcTextLink : 1
    - link dst -> ../src2

    src1 -> ../src2
    hardLink dst ../src1
    resolvingSrcTextLink : 0
    - link dst -> ../src1

    src1 -> ../src2
    hardLink dst ../src1
    resolvingSrcTextLink : 1
    - link dst -> ../src2

    src1 as :
    - missing file
    - link

    src2 as :
    - terminal
    - intermediate link
    - missing

  */

  provider.fieldPush( 'usingTextLink', 1 );

  /*  */

  test.case = 'relative link to dir';
  provider.filesDelete( routinePath );
  provider.dirMake( src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isDir( src2Path ) );
  test.is( provider.isDir( dstPath ) );
  test.identical( provider.dirRead( dstPath ), [] );


  /* src1 missing */

  test.case = '../src1 is missing, allowingMissed:0';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcTextLink : 0,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = '../src1 is missing, allowingMissed:1';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcTextLink : 0,
      resolvingSrcSoftLink : 0,
      allowingMissed : 1
    });
  })
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /*  */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  debugger
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.areHardLinked([ dstPath, src2Path ]), hardLinked );

  /* */

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.areHardLinked([ dstPath, src2Path ]), hardLinked );

  /* missing absolute src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0, allowingMissed : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcTextLink : 1,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcTextLink : 2,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink
  ({
    srcPath : src1Path,
    dstPath,
    resolvingSrcTextLink : 2,
    resolvingSrcSoftLink : 0,
    allowingMissed : 1
  });
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /* missing relative src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0, allowingMissed : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcTextLink : 1,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcTextLink : 2,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /* chain */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.areHardLinked([ dstPath, src3Path ]), hardLinked );


  /*  */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.areHardLinked([ dstPath, src3Path ]), hardLinked );

  provider.fieldPop( 'usingTextLink', 1 );
}

//

function hardLinkHardLinkedSync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRenameAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  let routinePath = test.context.pathFor( 'written/hardLinkHardLinkedSync' );
  let srcPath = test.context.pathFor( 'written/hardLinkHardLinkedSync/src' );
  let dstPath = test.context.pathFor( 'written/hardLinkHardLinkedSync/dst' );

  /* - */

  test.case = 'breakingSrcHardLink=0 breakingDstHardLink=0'
  provider.filesDelete( routinePath )
  provider.fileWrite( srcPath, 'data' );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
  test.shouldThrowErrorSync( () => provider.hardLink({ dstPath, srcPath, breakingDstHardLink : 0, breakingSrcHardLink : 0 }) );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );

  /* - */

  test.case = 'breakingSrcHardLink=1 breakingDstHardLink=0'
  provider.filesDelete( routinePath )
  provider.fileWrite( srcPath, 'data' );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
  provider.hardLink({ dstPath, srcPath, breakingDstHardLink : 0, breakingSrcHardLink : 1 });
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );

  /* - */

  test.case = 'breakingSrcHardLink=1 breakingDstHardLink=1'
  provider.filesDelete( routinePath )
  provider.fileWrite( srcPath, 'data' );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
  provider.hardLink({ dstPath, srcPath, breakingDstHardLink : 1, breakingSrcHardLink : 0 });
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );

  /* - */

  test.case = 'breakingSrcHardLink=1 breakingDstHardLink=1'
  provider.filesDelete( routinePath )
  provider.fileWrite( srcPath, 'data' );
  provider.hardLink( dstPath, srcPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
  provider.hardLink({ dstPath, srcPath, breakingDstHardLink : 1, breakingSrcHardLink : 1 });
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
}

//

function hardLinkHardLinkedAsync( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLinkAct ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  let routinePath = test.context.pathFor( 'written/hardLinkHardLinkedAsync' );
  let srcPath = test.context.pathFor( 'written/hardLinkHardLinkedAsync/src' );
  let dstPath = test.context.pathFor( 'written/hardLinkHardLinkedAsync/dst' );

  let ready = new _.Consequence().take( null )

  /* - */

  .then( () =>
  {
    test.case = 'breakingSrcHardLink=0 breakingDstHardLink=0'
    provider.filesDelete( routinePath )
    provider.fileWrite( srcPath, 'data' );
    provider.hardLink( dstPath, srcPath );
    if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
    else
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
    var con = provider.hardLink
    ({
      dstPath,
      srcPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 0,
      sync : 0
    });
    return test.shouldThrowErrorAsync( con );
  })
  .then( () =>
  {
    if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
    else
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
    return null;
  })

  /* - */

  .then( () =>
  {
    test.case = 'breakingSrcHardLink=1 breakingDstHardLink=0'
    provider.filesDelete( routinePath )
    provider.fileWrite( srcPath, 'data' );
    provider.hardLink( dstPath, srcPath );
    if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
    else
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
    return provider.hardLink
    ({
      dstPath,
      srcPath,
      breakingSrcHardLink : 1,
      breakingDstHardLink : 0,
      sync : 0
    });
  })
  .then( () =>
  {
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
    return null;
  })

  /* - */

  .then( () =>
  {
    test.case = 'breakingSrcHardLink=0 breakingDstHardLink=1'
    provider.filesDelete( routinePath )
    provider.fileWrite( srcPath, 'data' );
    provider.hardLink( dstPath, srcPath );
    if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
    else
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
    return provider.hardLink
    ({
      dstPath,
      srcPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 0
    });
  })
  .then( () =>
  {
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
    return null;
  })

  /* - */

  .then( () =>
  {
    test.case = 'breakingSrcHardLink=1 breakingDstHardLink=1'
    provider.filesDelete( routinePath )
    provider.fileWrite( srcPath, 'data' );
    provider.hardLink( dstPath, srcPath );
    if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), hardLinked );
    else
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
    return provider.hardLink
    ({
      dstPath,
      srcPath,
      breakingSrcHardLink : 1,
      breakingDstHardLink : 1,
      sync : 0
    });
  })
  .then( () =>
  {
    test.identical( provider.areHardLinked( [ srcPath, dstPath ] ), true );
    return null;
  })

  /* - */

  return ready;
}

//

function hardLinkEscapedPath( test )
{
  let context = this;
  let a = context.assetFor( test, false );

  /* qqq3 : use assetFor in each test routine */
  /* qqq3 : implement similar test routine for each method */

  /* */

  test.case = 'basic';
  a.reflect();
  var srcPath = a.abs( 'File1.txt' );
  var dstPath = a.abs( 'File2.txt' );
  var srcGlobalPath = a.system.path.join( `${a.effectiveProvider.protocol}:///`, srcPath );
  var dstGlobalPath = a.system.path.join( `${a.effectiveProvider.protocol}:///`, dstPath );
  test.is( a.path.isGlobal( srcGlobalPath ) );
  test.is( a.path.isGlobal( dstGlobalPath ) );
  a.system.fileWrite( srcGlobalPath, 'File1.txt' );
  test.is( a.system.fileExists( srcGlobalPath ) );
  test.isNot( a.system.fileExists( dstGlobalPath ) );
  test.isNot( a.system.areHardLinked( dstGlobalPath, srcGlobalPath ) );
  var got = a.system.hardLink( dstGlobalPath, srcGlobalPath );
  test.is( got );
  test.is( a.system.areHardLinked( dstGlobalPath, srcGlobalPath ) );
  var got = a.system.hardLink({ dstPath : dstGlobalPath, srcPath : srcGlobalPath, makingDirectory : 1 });
  test.isNot( got );
  test.is( a.system.areHardLinked( dstGlobalPath, srcGlobalPath ) );

  /* */

  test.case = '# @ ! ?';
  a.reflect();
  var srcPath = a.abs( '"a1#"/"a2@"/"a3!"/"a4?"/"#a5"/"@a6"/"!a7"/"?a8"/File1.txt' );
  var dstPath = a.abs( '"b1#"/"b2@"/"b3!"/"b4?"/"#b5"/"@b6"/"!b7"/"?b8"/File1.txt' );
  var srcGlobalPath = a.system.path.join( `${a.effectiveProvider.protocol}:///`, srcPath );
  var dstGlobalPath = a.system.path.join( `${a.effectiveProvider.protocol}:///`, dstPath );
  test.is( a.path.isGlobal( srcGlobalPath ) );
  test.is( a.path.isGlobal( dstGlobalPath ) );
  if( a.system.pathAllowedAct( srcGlobalPath ) )
  {
    a.system.fileWrite( srcGlobalPath, 'File1.txt' );
    test.is( a.system.fileExists( srcGlobalPath ) );
  }
  else
  {
    test.shouldThrowErrorSync( () =>
    {
      a.system.fileWrite( srcGlobalPath, 'File1.txt' );
    })
  }
  test.isNot( a.system.fileExists( dstGlobalPath ) );
  test.isNot( a.system.areHardLinked( dstGlobalPath, srcGlobalPath ) );
  if( a.system.pathAllowedAct( dstGlobalPath ) )
  {
    var got1 = a.system.hardLink({ dstPath : dstGlobalPath, srcPath : srcGlobalPath, makingDirectory : 1 });
    test.is( got1 );
    test.is( a.system.areHardLinked( dstGlobalPath, srcGlobalPath ) );
    var got1 = a.system.hardLink( dstGlobalPath, srcGlobalPath );
    test.isNot( got1 );
    test.is( a.system.areHardLinked( dstGlobalPath, srcGlobalPath ) );
  }
  else
  {
    test.shouldThrowErrorSync( () =>
    {
      a.system.hardLink({ dstPath : dstGlobalPath, srcPath : srcGlobalPath, makingDirectory : 1 });
    })
  }
}

//

function hardLinkSyncRunner( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  var suite = test.suite;
  var tests = suite.tests;
  var runsLimit = 50;

  for( var i = 0; i < runsLimit; i++ )
  {
    tests.hardLinkSync.call( context, test );
    // if( test.report.testCheckFails > 0 )
    // break;
  }
}

//

function hardLinkAsyncRunner( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  var suite = test.suite;
  var tests = suite.tests;

  var runsLimit = 50;

  var con = _.Consequence().take( null );

  for( var i = 0; i < runsLimit; i++ )(function()
  {
    con.ifNoErrorThen( ( arg ) =>
    {
      return tests.hardLinkAsync.call( context, test );
      // .finally( ( err, got ) =>
      // {
      //   // if( test.report.testCheckFails > 0 )
      //   // return _.Consequence().error( 'Execution stopped after first failed test run.' );
      // })
    })
  })();

  con.ifNoErrorThen( ( err ) => _.errLog( err ) );

  return con;
}

hardLinkAsyncRunner.timeOut = 60000 * 50;

//

function isDir( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let dirPath = test.context.pathFor( 'written/isDir' );
  let filePath = test.context.pathFor( 'written/isDir/file' );
  let linkPath = test.context.pathFor( 'written/isDir/link' );
  let linkPath2 = test.context.pathFor( 'written/isDir/link2' );
  let linkPath3 = test.context.pathFor( 'written/isDir/link3' );

  /* resolving off */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft context cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), false );

  // test.case = 'hardLink -> soft -> text -> dir'
  // provider.filesDelete( dirPath );
  // provider.dirMake( filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  // var got = provider.isDir( o );
  // test.identical( got, false )
  // var got = provider.statRead( o );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isDirectory(), false );

  test.case = 'hardLink -> text -> soft -> dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isTextLink(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false );
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text context cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + '../link' );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  provider.fieldPop( 'usingTextLink', 1 );

}

//

function dirIsEmpty( test )
{
  let context = this;
  let provider = context.provider;

  var filePath = test.context.pathFor( 'written/dirIsEmpty' );
  provider.filesDelete( filePath );

  /* - */

  test.case = 'non existing path'
  test.identical( provider.dirIsEmpty( filePath ), false );

  /* - */

  test.case = 'file'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, '' );
  test.identical( provider.dirIsEmpty( filePath ), false );

  /* - */

  test.case = 'path with dot';
  provider.filesDelete( filePath );
  var path = test.context.pathFor( 'written/.dirIsEmpty' );
  provider.dirMake( path )
  test.identical( provider.dirIsEmpty( path ), true );

  /* - */

  test.case = 'directory with file'
  provider.filesDelete( filePath );
  provider.fileWrite( context.provider.path.join( filePath, 'a' ), '' );
  test.identical( provider.dirIsEmpty( filePath ), false );

  /* - */

  test.case = 'empty directory'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  test.identical( provider.dirIsEmpty( filePath ), true );

  /* - */

  test.case = 'softLink to file';
  provider.filesDelete( filePath );
  var src = filePath + '_';
  provider.fileWrite( src, '' );
  provider.softLink( filePath, src );
  test.identical( provider.dirIsEmpty( filePath ), false );

  /* - */

  test.case = 'textLink to file';
  provider.filesDelete( filePath );
  var src = filePath + '_';
  provider.fileWrite( src, '' );
  provider.textLink( filePath, src );
  test.identical( provider.dirIsEmpty( filePath ), false );

  /* - */

  test.case = 'softLink empty dir';
  provider.filesDelete( filePath );
  var src = filePath + '_';
  provider.dirMake( src );
  provider.softLink( filePath, src );
  test.identical( provider.dirIsEmpty( filePath ), false );

  /* - */

  test.case = 'textLink to empty dir';
  provider.filesDelete( filePath );
  var src = filePath + '_';
  provider.dirMake( src );
  provider.textLink( filePath, src );
  test.identical( provider.dirIsEmpty( filePath ), false );

  test.case = 'softLink empty dir';
  provider.filesDelete( filePath );
  var src = filePath + '_';
  provider.dirMake( src );
  provider.softLink( filePath, src );

  provider.fieldPush( 'resolvingSoftLink', 0 );
  test.identical( provider.resolvedDirIsEmpty( filePath ), false );
  provider.fieldPop( 'resolvingSoftLink', 0 );

  provider.fieldPush( 'resolvingSoftLink', 1 );
  test.identical( provider.resolvedDirIsEmpty( filePath ), true );
  provider.fieldPop( 'resolvingSoftLink', 1 );

  /* - */

  test.case = 'textLink empty dir';
  provider.filesDelete( filePath );
  var src = filePath + '_';
  provider.dirMake( src );
  provider.textLink( filePath, src );

  provider.fieldPush( 'usingTextLink', 0 );

  provider.fieldPush( 'resolvingTextLink', 0 );
  test.identical( provider.resolvedDirIsEmpty( filePath ), false );
  provider.fieldPop( 'resolvingTextLink', 0 );

  provider.fieldPush( 'resolvingTextLink', 1 );
  test.identical( provider.resolvedDirIsEmpty( filePath ), false );
  provider.fieldPop( 'resolvingTextLink', 1 );

  provider.fieldPop( 'usingTextLink', 0 );

  /* - */

  test.case = 'textLink empty dir';
  provider.filesDelete( filePath );
  var src = filePath + '_';
  provider.dirMake( src );
  provider.textLink( filePath, src );

  provider.fieldPush( 'usingTextLink', 1 );

  provider.fieldPush( 'resolvingTextLink', 0 );
  test.identical( provider.resolvedDirIsEmpty( filePath ), false );
  provider.fieldPop( 'resolvingTextLink', 0 );

  provider.fieldPush( 'resolvingTextLink', 1 );
  test.identical( provider.resolvedDirIsEmpty( filePath ), true );
  provider.fieldPop( 'resolvingTextLink', 1 );

  provider.fieldPop( 'usingTextLink', 1 );
};

//

function isTerminal( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let dirPath = test.context.pathFor( 'written/isTerminal' );
  let filePath = test.context.pathFor( 'written/isTerminal/file' );
  let linkPath = test.context.pathFor( 'written/isTerminal/link' );
  let linkPath2 = test.context.pathFor( 'written/isTerminal/link2' );
  let linkPath3 = test.context.pathFor( 'written/isTerminal/link3' );

  /* resolving off */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft context cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath, filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  // var got = provider.isTerminal( o );
  // test.identical( got, true )
  // var got = provider.statRead( o );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isTextLink(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true );
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text context cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  provider.fieldPop( 'usingTextLink', 1 );

  /* resolving */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );


  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null);

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'soft to text to terminal';
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft context cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft context cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft context cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath, filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  // var got = provider.isTerminal( _.mapExtend( null, o ) );
  // test.identical( got, true )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), false );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), false );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath, filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  // var got = provider.isTerminal( _.mapExtend( null, o ) );
  // test.identical( got, true )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), true );
  // test.identical( got.isLink(), true );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath, filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  // var got = provider.isTerminal( _.mapExtend( null, o ) );
  // test.identical( got, true )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), false );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), false );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), true );
  test.identical( got.isTextLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), true );
  test.identical( got.isTextLink(), false );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), true );
  test.identical( got.isTextLink(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text context cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text context cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text context cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  provider.fieldPop( 'usingTextLink', 1 );

};

//

function isSoftLink( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let dirPath = test.context.pathFor( 'written/isSoftLink' );
  let filePath = test.context.pathFor( 'written/isSoftLink/file' );
  let linkPath = test.context.pathFor( 'written/isSoftLink/link' );
  let linkPath2 = test.context.pathFor( 'written/isSoftLink/link2' );
  let linkPath3 = test.context.pathFor( 'written/isSoftLink/link3' );

  /* resolving off */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isDirectory(), true );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft context cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath, filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0 };
  // var got = provider.isSoftLink( o );
  // test.identical( got, false )
  // var got = provider.statRead( o );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false );
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text context cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  provider.fieldPop( 'usingTextLink', 1 );


  /* resolving */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isSoftLink(), false );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft context cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath, filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 1 };
  // var got = provider.isSoftLink( _.mapExtend( null, o ) );
  // test.identical( got, false )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), false );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text context cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) )
  test.identical( got, null );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) )
  test.identical( got, null );

  provider.fieldPop( 'usingTextLink', 1 );

}

//

//

function isTextLink( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let dirPath = test.context.pathFor( 'written/isTextLink' );
  let filePath = test.context.pathFor( 'written/isTextLink/file' );
  let filePath2 = test.context.pathFor( 'written/isTextLink/file2' );
  let linkPath = test.context.pathFor( 'written/isTextLink/link' );

  /**/

  provider.fieldPush( 'usingTextLink', 0 )

  test.case = 'to missing'
  provider.filesDelete( filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'to terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'to directory'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'to text link'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, 'link ' + dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'context cycled'
  provider.filesDelete( filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  test.mustNotThrowError( () => provider.isTextLink( linkPath ) );

  test.case = 'cycled'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.mustNotThrowError( () => provider.isTextLink( linkPath ) );

  test.case = 'to cycled soft link'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : filePath, allowingMissed : 1 });
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.fieldPush( 'resolvingSoftLink', 1 )
  test.is( !provider.isTextLink( linkPath ) );
  provider.fieldPop( 'resolvingSoftLink', 1 );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  test.is( !provider.isTextLink( filePath ) );

  test.case = 'softLink'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : filePath, makingDirectory : 1, allowingMissed : 1 });
  test.is( !provider.isTextLink( filePath ) );

  test.case = 'softLink to softLink to missing'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : filePath, makingDirectory : 1, allowingMissed : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1 });
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'softLink to softLink to terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath2, filePath2 );
  provider.softLink({ dstPath : filePath, srcPath : filePath2 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'softLink to softLink to dir'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : context.provider.path.dir( filePath ), makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath, makingDirectory : 1 });
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'hardLink'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  provider.hardLink({ dstPath : linkPath, srcPath : filePath, makingDirectory : 1 });
  test.is( !provider.isTextLink( linkPath ) );

  provider.fieldPop( 'usingTextLink', 0 )

  /**/

  provider.fieldPush( 'usingTextLink', 1 )
  provider.filesDelete( dirPath );

  test.case = 'to missing'
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink( linkPath ) );

  test.case = 'to terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink( linkPath ) );

  test.case = 'to directory'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink( linkPath ) );

  test.case = 'to text link'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, 'link ' + dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink( linkPath ) );

  test.case = 'context cycled'
  provider.filesDelete( filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  test.is( provider.isTextLink( linkPath ) );

  test.case = 'cycled'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink( linkPath ) );

  test.case = 'to cycled soft link'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : filePath, allowingMissed : 1 });
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.fieldPush( 'resolvingSoftLink', 1 )
  test.is( provider.isTextLink( linkPath ) );
  provider.fieldPop( 'resolvingSoftLink', 1 );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  test.is( !provider.isTextLink( filePath ) );

  test.case = 'softLink'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : filePath, makingDirectory : 1, allowingMissed : 1 });
  test.is( !provider.isTextLink( filePath ) );

  test.case = 'softLink to softLink to missing'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : filePath, makingDirectory : 1, allowingMissed : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1 });
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'softLink to softLink to terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath2, filePath2 );
  provider.softLink({ dstPath : filePath, srcPath : filePath2 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'softLink to softLink to dir'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : context.provider.path.dir( filePath ), makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath, makingDirectory : 1 });
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'hardLink'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  provider.hardLink({ dstPath : linkPath, srcPath : filePath, makingDirectory : 1 });
  test.is( !provider.isTextLink( linkPath ) );

  provider.fieldPop( 'usingTextLink', 1 )

  /* resolving soft link */

  provider.fieldPush( 'usingTextLink', 1 )
  provider.filesDelete( dirPath );

  test.case = 'to missing'
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), true );

  test.case = 'to terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), true );

  test.case = 'to directory'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), true );

  test.case = 'to text link'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, 'link ' + dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), true );

  test.case = 'context cycled'
  provider.filesDelete( filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  test.is( provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), true );

  test.case = 'cycled'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), true );

  test.case = 'to cycled soft link'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : '../file', allowingMissed : 1 });
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.fieldPush( 'resolvingSoftLink', 1 )
  test.is( provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  provider.fieldPop( 'resolvingSoftLink', 1 );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), true );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  test.is( !provider.isTextLink( filePath ) );
  var got = provider.statRead({ filePath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), false );

  test.case = 'softLink to missing'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, makingDirectory : 1, allowingMissed : 1 });
  test.is( !provider.isTextLink( linkPath ) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got, null );

  test.case = 'softLink to softLink to missing'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath2, srcPath : filePath, makingDirectory : 1, allowingMissed : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath2, allowingMissed : 1 });
  test.is( !provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got, null );

  test.case = 'softLink to softLink to terminal'
  provider.filesDelete( provider.path.dir( filePath ) );
  provider.fileWrite( filePath2, filePath2 );
  provider.softLink({ dstPath : filePath, srcPath : filePath2 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  test.is( !provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), false );

  test.case = 'softLink to softLink to dir'
  provider.filesDelete( filePath );
  provider.filesDelete( linkPath );
  provider.softLink({ dstPath : filePath, srcPath : context.provider.path.dir( filePath ), makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath, makingDirectory : 1 });
  test.is( !provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );
  test.identical( got.isLink(), false );

  test.case = 'hardLink'
  provider.filesDelete( filePath );
  provider.filesDelete( linkPath );
  provider.fileWrite( filePath, filePath );
  provider.hardLink({ dstPath : linkPath, srcPath : filePath, makingDirectory : 1 });
  test.is( !provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), false );

  provider.fieldPop( 'usingTextLink', 1 )
};

//

function isHardLink( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let dirPath = test.context.pathFor( 'written/isHardLink' );
  let filePath = test.context.pathFor( 'written/isHardLink/file' );
  let linkPath = test.context.pathFor( 'written/isHardLink/link' );
  let linkPath2 = test.context.pathFor( 'written/isHardLink/link2' );
  let linkPath3 = test.context.pathFor( 'written/isHardLink/link3' );

  /* resolving off */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isDirectory(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft context cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath, filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  // var got = provider.isHardLink( o );
  // test.identical( got, true )
  // var got = provider.statRead( o );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false );
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text context cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  provider.fieldPop( 'usingTextLink', 1 );

  /* resolving */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );


  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null);

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft context cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft context cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft context cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), true );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), true );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), true );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath, filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  // var got = provider.isHardLink( _.mapExtend( null, o ) );
  // test.identical( got, false )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), false );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), false );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath, filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  // var got = provider.isHardLink( _.mapExtend( null, o ) );
  // test.identical( got, true )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), true );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath, filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  // var got = provider.isHardLink( _.mapExtend( null, o ) );
  // test.identical( got, false )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), false );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), true );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), true );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), true );
  test.identical( got.isTextLink(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text context cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );


  test.case = 'text context cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text context cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  provider.fieldPop( 'usingTextLink', 1 );
}

//

function isLink( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let dirPath = test.context.pathFor( 'written/isLink' );
  let filePath = test.context.pathFor( 'written/isLink/file' );
  let linkPath = test.context.pathFor( 'written/isLink/link' );
  let linkPath2 = test.context.pathFor( 'written/isLink/link2' );
  let linkPath3 = test.context.pathFor( 'written/isLink/link3' );

  /* resolving off */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );


  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft context cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath, filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  // var got = provider.isLink( _.mapExtend( null, o ) );
  // test.identical( got, true )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), true );
  // test.identical( got.isDirectory(), false );

  // test.case = 'hardLink -> text -> soft -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath, filePath );
  // provider.softLink( linkPath3, filePath );
  // provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  // var got = provider.isLink( _.mapExtend( null, o ) );
  // test.identical( got, true )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), true );
  // test.identical( got.isDirectory(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text context cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  provider.fieldPop( 'usingTextLink', 1 );

  /* resolving */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null);

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null);

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft context cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft context cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft context cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath, filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  // var got = provider.isLink( _.mapExtend( null, o ) );
  // test.identical( got, false )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), false );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), false );
  // test.identical( got.isDirectory(), false );
  // test.identical( got.isLink(), false );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath, filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  // var got = provider.isLink( _.mapExtend( null, o ) );
  // test.identical( got, true )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), true );
  // test.identical( got.isDirectory(), false );
  // test.identical( got.isLink(), true );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath, filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  // var got = provider.isLink( _.mapExtend( null, o ) );
  // test.identical( got, false )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), false );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), false );
  // test.identical( got.isDirectory(), false );
  // test.identical( got.isLink(), false );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );


  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );
  test.identical( got.isLink(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );
  test.identical( got.isLink(), false );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  test.case = 'text to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );
  test.identical( got.isLink(), false );

  test.case = 'text context cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text context cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text context cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  provider.fieldPop( 'usingTextLink', 1 );
}

//

function fileStatIs( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let filePath = test.context.pathFor( 'written/fileStatIs/file' );

  if( !test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( 1, 1 );
    return;
  }

  let originalValue = provider.UsingBigIntForStat;

  try
  {
    provider.fileWrite( filePath, filePath );

    test.case = 'map'
    test.is( !_.fileStatIs( {} ) );
    test.case = 'string'
    test.is( !_.fileStatIs( '' ) );
    test.case = 'array'
    test.is( !_.fileStatIs( [] ) );
    test.case = 'provider'
    test.is( !_.fileStatIs( provider ) );
    test.case = 'null'
    test.is( !_.fileStatIs( null ) );
    test.case = 'instance of _.FileStat'
    test.is( _.fileStatIs( new _.FileStat  ) );

    test.case = 'stats without bigint'
    provider.UsingBigIntForStat = false;
    var stat = provider.statResolvedRead( filePath );
    test.is( _.fileStatIs( stat ) );

    test.case = 'stats with bigint'
    provider.UsingBigIntForStat = true;
    var stat = provider.statResolvedRead( filePath );
    test.is( _.fileStatIs( stat ) );
  }
  // catch( err )
  // {
  //   throw err;
  // }
  finally
  {
    provider.UsingBigIntForStat = originalValue;
  }
}

//

function areHardLinked( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;
  var textData = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.';

  if( test.context.providerIsInstanceOf( _.FileProvider.Extract ) )
  {
    //!!!Look into cases with soft links, resolvingSoftLink is not implemented in Extract.areHardLinkedAct
    test.identical( 1, 1 );
    return;
  }

  if( Config.interpreter === 'browser' || test.context.providerIsInstanceOf( _.FileProvider.Extract ) )
  var bufferData = new BufferRaw( 4 );
  else
  var bufferData = BufferNode.from( [ 0x01, 0x02, 0x03, 0x04 ] );

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  /* - */

  test.case = 'same text file';
  var filePath = test.context.pathFor( 'written/areHardLinked/file' );
  provider.fileWrite( filePath, textData );
  var got = provider.areHardLinked([ filePath, filePath ]);
  test.identical( got, hardLinked );


  /* - */

  test.case = 'softLink to a file';
  provider.filesDelete( test.context.pathFor( 'written/areHardLinked' ) );
  var filePath = test.context.pathFor( 'written/areHardLinked/file' );
  var linkPath = test.context.pathFor( 'written/areHardLinked/link' );
  provider.fileWrite( filePath, textData );
  provider.softLink( linkPath, filePath );
  /* resolvingSoftLink off */
  provider.fieldPush( 'resolvingSoftLink', 0 );
  var got = provider.areHardLinked([ linkPath, filePath ]);
  provider.fieldPop( 'resolvingSoftLink', 0 );
  test.identical( got, false );
  /* resolvingSoftLink on */
  provider.fieldPush( 'resolvingSoftLink', 1 );
  var got = provider.areHardLinked([ linkPath, filePath ]);
  provider.fieldPop( 'resolvingSoftLink', 1 );
  test.identical( got, false );

  /* - */

  test.case = 'different files with identical binary content';
  var filePath = test.context.pathFor( 'written/areHardLinked/file' );
  var filePath2 = test.context.pathFor( 'written/areHardLinked/file2' );
  provider.filesDelete( test.context.pathFor( 'written/areHardLinked' ) );
  provider.fileWrite( filePath, bufferData );
  provider.fileWrite( filePath2, bufferData );
  var got = provider.areHardLinked([ filePath, filePath2 ]);
  test.identical( got, false );

  /* - */

  test.case = 'symlink to file with  binary content';
  provider.filesDelete( test.context.pathFor( 'written/areHardLinked' ) );
  var filePath = test.context.pathFor( 'written/areHardLinked/file' );
  var linkPath = test.context.pathFor( 'written/areHardLinked/link' );
  provider.fileWrite( filePath, bufferData );
  provider.softLink( linkPath, filePath );
  /* resolvingSoftLink off */
  provider.fieldPush( 'resolvingSoftLink', 0 );
  var got = provider.areHardLinked([ linkPath, filePath ]);
  provider.fieldPop( 'resolvingSoftLink', 0 );
  test.identical( got, false );
  /* resolvingSoftLink on */
  provider.fieldPush( 'resolvingSoftLink', 1 );
  var got = provider.areHardLinked([ linkPath, filePath ]);
  provider.fieldPop( 'resolvingSoftLink', 1 );
  test.identical( got, false );

  /* - */

  test.case = 'hardLink to file with  binary content';
  provider.filesDelete( test.context.pathFor( 'written/areHardLinked' ) );
  var filePath = test.context.pathFor( 'written/areHardLinked/file' );
  var linkPath = test.context.pathFor( 'written/areHardLinked/link' );
  provider.fileWrite( filePath, bufferData );
  provider.hardLink( linkPath, filePath );
  var got = provider.areHardLinked([ linkPath, filePath ]);
  test.identical( got, hardLinked );

  /* - */

  test.case = 'hardLink to file with  text content : file record';
  provider.filesDelete( test.context.pathFor( 'written/areHardLinked' ) );
  var filePath = test.context.pathFor( 'written/areHardLinked/file' );
  var linkPath = test.context.pathFor( 'written/areHardLinked/link' );
  provider.fileWrite( filePath, textData );
  provider.hardLink( linkPath, filePath );
  var fileRecord = provider.recordFactory().record( filePath );
  var linkRecord = provider.recordFactory().record( linkPath );
  var got = provider.areHardLinked([ fileRecord, linkRecord ]);
  test.identical( got, hardLinked );

};

//

function areTextLinked( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = context.pathFor( 'written/areTextLinked' )
  let filePath1 = context.pathFor( 'written/areTextLinked/file1' );
  let filePath2 = context.pathFor( 'written/areTextLinked/file2' );
  let linkPath1 = context.pathFor( 'written/areTextLinked/link1' );
  let linkPath2 = context.pathFor( 'written/areTextLinked/link2' );

  provider.fieldPush( 'usingTextLink', 1 );

  /*
    resolvingTextLink is always on

    options :
    filePath - array with paths
    resolvingSoftLink : 0/1

    kind of file : missing, terminal, dir, link( soft, hard, text ), chain of links
    combine this kinds of file to create test cases
  */

  test.case = 'missing, missing';
  provider.filesDelete( routinePath );
  var got = provider.areTextLinked({ filePath : [ filePath1, filePath2 ], resolvingSoftLink : 0 });
  test.identical( got, false );

  test.case = 'missing, missing';
  provider.filesDelete( routinePath );
  var got = provider.areTextLinked({ filePath : [ filePath1, filePath2 ], resolvingSoftLink : 1 });
  test.identical( got, false );

  test.case = 'missing, terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath2, filePath2 );
  var got = provider.areTextLinked({ filePath : [ filePath1, filePath2 ], resolvingSoftLink : 0 });
  test.identical( got, false );

  test.case = 'missing, terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath2, filePath2 );
  var got = provider.areTextLinked({ filePath : [ filePath1, filePath2 ], resolvingSoftLink : 1 });
  test.identical( got, false );

  test.case = 'terminal, terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  var got = provider.areTextLinked({ filePath : [ filePath1, filePath2 ], resolvingSoftLink : 1 });
  test.identical( got, false );

  test.case = 'terminal, terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  var got = provider.areTextLinked({ filePath : [ filePath1, filePath2 ], resolvingSoftLink : 0 });
  test.identical( got, false );

  test.case = 'terminal, text link to other file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.textLink( linkPath1, filePath2 );
  var got = provider.areTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 1 });
  test.identical( got, false );

  test.case = 'terminal, text link to other file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.textLink( linkPath1, filePath2 );
  var got = provider.areTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 0 });
  test.identical( got, false );

  test.case = 'terminal, text link to same file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( linkPath1, filePath1 );
  var got = provider.areTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 0 });
  test.identical( got, true );

  test.case = 'terminal, text link to same file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( linkPath1, filePath1 );
  var got = provider.areTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 1 });
  test.identical( got, true );

  test.case = 'terminal, soft link to other';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.softLink( linkPath1, filePath2 );
  var got = provider.areTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 1 });
  test.identical( got, false );

  test.case = 'terminal, soft link to other';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.softLink( linkPath1, filePath2 );
  var got = provider.areTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 0 });
  test.identical( got, false );

  test.case = 'terminal, soft link to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.softLink( linkPath1, filePath1 );
  var got = provider.areTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 1 });
  test.identical( got, true );

  test.case = 'terminal, soft link to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.softLink( linkPath1, filePath1 );
  var got = provider.areTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 0 });
  test.identical( got, false );

  test.case = 'terminal, hardlink to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.hardLink( linkPath1, filePath1 );
  var got = provider.areTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 0 });
  test.identical( got, false );

  test.case = 'terminal, hardlink to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.hardLink( linkPath1, filePath1 );
  var got = provider.areTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 1 });
  test.identical( got, false );

  test.case = 'terminal, soft to text to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( linkPath2, filePath1 );
  provider.softLink( linkPath1, linkPath2 );
  var got = provider.areTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 1 });
  test.identical( got, true );

  test.case = 'terminal, soft to text to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( linkPath2, filePath1 );
  provider.softLink( linkPath1, linkPath2 );
  var got = provider.areTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 0 });
  test.identical( got, false );

  provider.fieldPop( 'usingTextLink', 1 );

}

//

function areSoftLinked( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = context.pathFor( 'written/areSoftLinked' )
  let filePath1 = context.pathFor( 'written/areSoftLinked/file1' );
  let filePath2 = context.pathFor( 'written/areSoftLinked/file2' );
  let linkPath1 = context.pathFor( 'written/areSoftLinked/link1' );
  let linkPath2 = context.pathFor( 'written/areSoftLinked/link2' );

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing, missing';
  provider.filesDelete( routinePath );
  var got = provider.areSoftLinked({ filePath : [ filePath1, filePath2 ], resolvingTextLink : 0 });
  test.identical( got, false );

  test.case = 'missing, missing';
  provider.filesDelete( routinePath );
  var got = provider.areSoftLinked({ filePath : [ filePath1, filePath2 ], resolvingTextLink : 1 });
  test.identical( got, false );

  test.case = 'missing, terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath2, filePath2 );
  var got = provider.areSoftLinked({ filePath : [ filePath1, filePath2 ], resolvingTextLink : 0 });
  test.identical( got, false );

  test.case = 'missing, terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath2, filePath2 );
  var got = provider.areSoftLinked({ filePath : [ filePath1, filePath2 ], resolvingTextLink : 1 });
  test.identical( got, false );

  test.case = 'terminal, terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  var got = provider.areSoftLinked({ filePath : [ filePath1, filePath2 ], resolvingTextLink : 1 });
  test.identical( got, false );

  test.case = 'terminal, terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  var got = provider.areSoftLinked({ filePath : [ filePath1, filePath2 ], resolvingTextLink : 0 });
  test.identical( got, false );

  test.case = 'terminal, text link to other file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.textLink( linkPath1, filePath2 );
  var got = provider.areSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 1 });
  test.identical( got, false );

  test.case = 'terminal, text link to other file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.textLink( linkPath1, filePath2 );
  var got = provider.areSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 0 });
  test.identical( got, false );

  test.case = 'terminal, text link to same file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( linkPath1, filePath1 );
  var got = provider.areSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 0 });
  test.identical( got, false );

  test.case = 'terminal, text link to same file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( linkPath1, filePath1 );
  var got = provider.areSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 1 });
  test.identical( got, true );

  test.case = 'terminal, soft link to other';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.softLink( linkPath1, filePath2 );
  var got = provider.areSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 1 });
  test.identical( got, false );

  test.case = 'terminal, soft link to other';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.softLink( linkPath1, filePath2 );
  var got = provider.areSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 0 });
  test.identical( got, false );

  test.case = 'terminal, soft link to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.softLink( linkPath1, filePath1 );
  var got = provider.areSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 1 });
  test.identical( got, true );

  test.case = 'terminal, soft link to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.softLink( linkPath1, filePath1 );
  var got = provider.areSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 0 });
  test.identical( got, true );

  test.case = 'terminal, hardlink to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.hardLink( linkPath1, filePath1 );
  var got = provider.areSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 0 });
  test.identical( got, false );

  test.case = 'terminal, hardlink to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.hardLink( linkPath1, filePath1 );
  var got = provider.areSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 1 });
  test.identical( got, false );

  test.case = 'terminal, soft to text to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( linkPath2, filePath1 );
  provider.softLink( linkPath1, linkPath2 );
  var got = provider.areSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 1 });
  test.identical( got, true );

  test.case = 'terminal, soft to text to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( linkPath2, filePath1 );
  provider.softLink( linkPath1, linkPath2 );
  var got = provider.areSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 0 });
  test.identical( got, false );

  provider.fieldPop( 'usingTextLink', 1 );

}

//

function filesCanBeSame( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  var textData1 = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
  var textData2 = ' Aenean non feugiat mauris'
  var bufferData1, bufferData2;

  if( Config.interpreter === 'browser' || context.providerIsInstanceOf( _.FileProvider.Extract ) )
  {
    bufferData1 = new BufferRaw( 4 );
    bufferData2 = new BufferRaw( 5 );
  }
  else
  {
    bufferData1 = BufferNode.from( [ 0x01, 0x02, 0x03, 0x04 ] );
    bufferData2 =  BufferNode.from( [ 0x07, 0x06, 0x05 ] );
  }


  /* - */

  test.case = 'same file with empty content';
  var filePath = test.context.pathFor( 'written/filesCanBeSame/file' );
  provider.fileWrite( filePath, '' );
  var got = provider.filesCanBeSame( filePath, filePath );
  test.identical( got, true );

  /* - */

  test.case = 'two different files with empty content';
  var filePath = test.context.pathFor( 'written/filesCanBeSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesCanBeSame/file2' );
  provider.fileWrite( filePath, '' );
  provider.fileWrite( filePath2, '' );
  var got = provider.filesCanBeSame( filePath, filePath2 );
  test.identical( got, true );

  /* - */

  test.case = 'files with identical binary content';
  var filePath = test.context.pathFor( 'written/filesCanBeSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesCanBeSame/file2' );
  provider.fileWrite( filePath, bufferData1 );
  provider.fileWrite( filePath2, bufferData1 );
  var got = provider.filesCanBeSame( filePath, filePath2 );
  test.identical( got, true );

  /* - */

  test.case = 'files with non identical text content';
  var filePath = test.context.pathFor( 'written/filesCanBeSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesCanBeSame/file2' );
  provider.fileWrite( filePath, textData1 );
  provider.fileWrite( filePath2, textData2 );
  var got = provider.filesCanBeSame( filePath, filePath2 );
  test.identical( got, false );

  /* - */

  test.case = 'files with non identical binart content';
  var filePath = test.context.pathFor( 'written/filesCanBeSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesCanBeSame/file2' );
  provider.fileWrite( filePath, bufferData1 );
  provider.fileWrite( filePath2, bufferData2 );
  var got = provider.filesCanBeSame( filePath, filePath2 );
  test.identical( got, false );

  /* - */

  test.case = 'file and symlink to file';
  var filePath = test.context.pathFor( 'written/filesCanBeSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesCanBeSame/file2' );
  provider.fileWrite( filePath, textData1 );
  provider.softLink( filePath2, filePath );
  /* resolvingSoftLink off */
  provider.fieldPush( 'resolvingSoftLink', 0 );
  var got = provider.filesCanBeSame( filePath, filePath2 );
  provider.fieldPop( 'resolvingSoftLink', 0 );
  test.identical( got, false );
  /* resolvingSoftLink on */
  provider.fieldPush( 'resolvingSoftLink', 1 );
  var got = provider.filesCanBeSame( filePath, filePath2 );
  provider.fieldPop( 'resolvingSoftLink', 1 );
  test.identical( got, false );

  /* - */

  test.case = 'not existing path';
  var filePath = test.context.pathFor( 'written/filesCanBeSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesCanBeSame/file2' );
  provider.fileWrite( filePath, bufferData1 );
  provider.filesDelete( filePath );
  var got = provider.filesCanBeSame( filePath, filePath2 );
  test.identical( got, false )


  /* - */

  test.case = 'two file records asociated with two regular files';
  var filePath = test.context.pathFor( 'written/filesCanBeSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesCanBeSame/file2' );
  provider.fileWrite( filePath, textData1 );
  provider.fileWrite( filePath, textData1 );
  var got = provider.filesCanBeSame( provider.recordFactory().record( filePath ), provider.recordFactory().record( filePath2 ) );
  test.identical( got, true );

  /* - */

  test.case = 'two file records asociated with two regular files, same content';
  var filePath = test.context.pathFor( 'written/filesCanBeSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesCanBeSame/file2' );
  provider.fileWrite( filePath, textData1 );
  provider.fileWrite( filePath2, textData1 );
  var got = provider.filesCanBeSame( provider.recordFactory().record( filePath ), provider.recordFactory().record( filePath2 ) );
  test.identical( got, true );

  /* - */

  test.case = 'two file records asociated with two regular files, diff content';
  var filePath = test.context.pathFor( 'written/filesCanBeSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesCanBeSame/file2' );
  provider.fileWrite( filePath, textData1 );
  provider.filesDelete( filePath2 );
  provider.fileWrite( filePath2, textData2 );
  var got = provider.filesCanBeSame( provider.recordFactory().record( filePath ), provider.recordFactory().record( filePath2 ) );
  test.identical( got, false );

  /* - */

  test.case = 'two file records asociated with two symlinks, same content';
  var filePath = test.context.pathFor( 'written/filesCanBeSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesCanBeSame/file2' );
  provider.fileWrite( filePath, textData1 );
  provider.filesDelete( filePath2 );
  provider.fileWrite( filePath2, textData1 );
  var linkPath = test.context.pathFor( 'written/filesCanBeSame/link1' );
  var linkPath2 = test.context.pathFor( 'written/filesCanBeSame/link2' );
  provider.softLink( linkPath, filePath );
  provider.softLink( linkPath2, filePath2 );
  /* resolvingSoftLink off */
  provider.fieldPush( 'resolvingSoftLink', 0 );
  var got = provider.filesCanBeSame( provider.recordFactory().record( linkPath ), provider.recordFactory().record( linkPath2 ) );
  provider.fieldPop( 'resolvingSoftLink', 0 );
  test.identical( got, false );
  /* resolvingSoftLink on */
  provider.fieldPush( 'resolvingSoftLink', 1 );
  var got = provider.filesCanBeSame( provider.recordFactory().record( linkPath ), provider.recordFactory().record( linkPath2 ) );
  provider.fieldPop( 'resolvingSoftLink', 1 );
  test.identical( got, true );

  /* - */

  test.case = 'two file records asociated with two symlinks, diff content';
  var filePath = test.context.pathFor( 'written/filesCanBeSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesCanBeSame/file2' );
  provider.fileWrite( filePath, textData1 );
  provider.filesDelete( filePath2 );
  provider.fileWrite( filePath2, textData2 );
  var linkPath = test.context.pathFor( 'written/filesCanBeSame/link1' );
  var linkPath2 = test.context.pathFor( 'written/filesCanBeSame/link2' );
  provider.softLink( linkPath, filePath );
  provider.softLink( linkPath2, filePath2 );
  /* resolvingSoftLink off */
  provider.fieldPush( 'resolvingSoftLink', 0 );
  var got = provider.filesCanBeSame( provider.recordFactory().record( linkPath ), provider.recordFactory().record( linkPath2 ) );
  provider.fieldPop( 'resolvingSoftLink', 0 );
  test.identical( got, false );
  /* resolvingSoftLink on */
  provider.fieldPush( 'resolvingSoftLink', 1 );
  var got = provider.filesCanBeSame( provider.recordFactory().record( linkPath ), provider.recordFactory().record( linkPath2 ) );
  provider.fieldPop( 'resolvingSoftLink', 1 );
  test.identical( got, false );

  /* - */

  if( Config.debug )
  {
    test.case = 'missed arguments';
    test.shouldThrowErrorSync( function( )
    {
      context.provider.filesSame( );
    } );
  }

}

//

function rightsSet( test )
{
  let context = this;
  let a = context.assetFor( test, false );
  let c = 0;

  if( a.effectiveProvider instanceof _.FileProvider.Extract )
  return test.identical( 1, 1 );

  /*
    https://nodejs.org/api/fs.html#fs_file_modes
    Node caveats: on Windows only the write permission can be changed, and the distinction among the permissions of group, owner or others is not implemented.
  */


  /* */

  test.case = 'same';
  c += 1;
  a.fileProvider.fileWrite( a.abs( `F${c}.txt` ), `F${c}.txt` );
  var stat = a.fileProvider.statRead( a.abs( `F${c}.txt` ) );
  console.log( 'stat', stat );
  var rights = a.fileProvider.rightsRead( a.abs( `F${c}.txt` ) );
  console.log( 'rights', ( rights ).toString( 8 ) );
  test.identical( stat.mode, rights );
  if( process.platform === 'win32' )
  test.identical( Number( rights ) & 0o777, 0o666 );
  else
  // test.identical( Number( rights ) & 0o777, 0o644 ); /* Dmytro : this value depends on umask value. The user profile settings for umask can be 002 and 022 */
  test.is( ( Number( rights ) & 0o777 ) === 0o644 || ( Number( rights ) & 0o777 ) === 0o664 );

  /* */

  test.case = 'setRights';
  c += 1;
  a.fileProvider.fileWrite( a.abs( `F${c}.txt` ), `F${c}.txt` );
  var got = a.fileProvider.rightsWrite({ filePath : a.abs( `F${c}.txt` ), setRights : 0o777 });
  test.identical( got, true );
  var rights = a.fileProvider.rightsRead( a.abs( `F${c}.txt` ) );
  console.log( 'rights', ( rights ).toString( 8 ) );
  if( process.platform === 'win32' )
  test.identical( Number( rights ) & 0o777, 0o666 );
  else
  test.identical( Number( rights ) & 0o777, 0o777 );

  /* */

  test.case = 'addRights';
  c += 1;
  a.fileProvider.fileWrite( a.abs( `F${c}.txt` ), `F${c}.txt` );
  var got = a.fileProvider.rightsWrite({ filePath : a.abs( `F${c}.txt` ), addRights : 0o777 });
  test.identical( got, true );
  var rights = a.fileProvider.rightsRead( a.abs( `F${c}.txt` ) );
  console.log( 'rights', ( rights ).toString( 8 ) );
  if( process.platform === 'win32' )
  test.identical( Number( rights ) & 0o777, 0o666 );
  else
  test.identical( Number( rights ) & 0o777, 0o777 );

  /* */

  test.case = 'delRights';
  c += 1;
  a.fileProvider.fileWrite( a.abs( `F${c}.txt` ), `F${c}.txt` );
  var got = a.fileProvider.rightsWrite({ filePath : a.abs( `F${c}.txt` ), delRights : 0o777 });
  test.identical( got, true );
  var rights = a.fileProvider.rightsRead( a.abs( `F${c}.txt` ) );
  console.log( 'rights', ( rights ).toString( 8 ) );
  if( process.platform === 'win32' )
  test.identical( Number( rights ) & 0o777, 0o444 );
  else
  test.identical( Number( rights ) & 0o777, 0 );

  /* */

  test.case = 'args';
  c += 1;
  a.fileProvider.fileWrite( a.abs( `F${c}.txt` ), `F${c}.txt` );
  var got = a.fileProvider.rightsWrite( a.abs( `F${c}.txt` ), 0o001 );
  test.identical( got, true );
  var rights = a.fileProvider.rightsRead( a.abs( `F${c}.txt` ) );
  console.log( 'rights', ( rights ).toString( 8 ) );
  if( process.platform === 'win32' )
  test.identical( Number( rights ) & 0o777, 0o444 );
  else
  test.identical( Number( rights ) & 0o777, 0o001 );

  /* */

  /* qqq : extend the test. try BigInts. try all options */
  /* qqq : implements similar tests for rightsAdd, rightsDel */

}

//

function statsAreHardLinked( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = context.pathFor( 'written/statsAreHardLinked' );
  let filePath1 = context.pathFor( 'written/statsAreHardLinked/file1' );
  let filePath2 = context.pathFor( 'written/statsAreHardLinked/file2' );
  let linkPath1 = context.pathFor( 'written/statsAreHardLinked/link1' );
  let linkPath2 = context.pathFor( 'written/statsAreHardLinked/link2' );

  if( !_.routineIs( _.files.stat.areHardLinked ) )
  {
    test.identical( 1, 1 )
    return;
  }

  test.case = 'comparing same file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  var stat = provider.statRead( filePath1 );
  var got = _.files.stat.areHardLinked( stat, stat );
  if( provider.UsingBigIntForStat )
  test.identical( got, true );
  else
  test.identical( got, _.maybe );

  test.case = 'comparing with different terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  var got = _.files.stat.areHardLinked( stat1, stat2 );
  test.identical( got, false );

  test.case = 'comparing with terminal of same content';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath1 );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  var got = _.files.stat.areHardLinked( stat1, stat2 );
  test.identical( got, false );

  test.case = 'imitate problem with same ino, on lower nodejs versions, compare similar files';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, 'diff' );
  provider.fileWrite( filePath2, 'fidd' );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  stat1.ino = stat2.ino = Number( stat1.ino );
  stat1.mtime = stat2.mtime;
  stat1.birthtime = stat2.birthtime;
  stat1.ctime = stat2.ctime;
  var got = _.files.stat.areHardLinked( stat1, stat2 );
  test.identical( got, _.maybe );

  test.case = 'comparing with hardlink';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.hardLink( filePath2, filePath1 );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  var got = _.files.stat.areHardLinked( stat1, stat2 );
  if( provider.UsingBigIntForStat )
  test.identical( got, true );
  else
  test.identical( got, _.maybe );

  test.case = 'comparing with softlink';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.softLink( filePath2, filePath1 );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  var got = _.files.stat.areHardLinked( stat1, stat2 );
  test.identical( got, false );

  test.case = 'comparing with textlink';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( filePath2, filePath1 );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  var got = _.files.stat.areHardLinked( stat1, stat2 );
  test.identical( got, false );

  test.case = 'comparing two diff hardlinks';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.hardLink( linkPath1, filePath1 );
  provider.hardLink( linkPath2, filePath2 );
  var stat1 = provider.statRead( linkPath1 );
  var stat2 = provider.statRead( linkPath2 );
  var got = _.files.stat.areHardLinked( stat1, stat2 );
  test.identical( got, false );

  test.case = 'comparing two hardlinks to same file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.hardLink( linkPath1, filePath1 );
  provider.hardLink( linkPath2, filePath1 );
  var stat1 = provider.statRead( linkPath1 );
  var stat2 = provider.statRead( linkPath2 );
  var got = _.files.stat.areHardLinked( stat1, stat2 );
  if( provider.UsingBigIntForStat )
  test.identical( got, true );
  else
  test.identical( got, _.maybe );

  test.case = 'same ino different size';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  stat1.ino = stat2.ino = 1;
  stat1.size = 1;
  stat2.size = 2;
  var got = _.files.stat.areHardLinked( stat1, stat2 );
  test.identical( got, false );

  test.case = 'same ino different nlink';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  stat1.ino = stat2.ino = 1;
  stat1.nlink = 1;
  stat2.nlink = 2;
  var got = _.files.stat.areHardLinked( stat1, stat2 );
  test.identical( got, false );

  test.case = 'same ino, size, but different date';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  stat1.ino = stat2.ino = 1;
  stat1.size = stat2.size = 1;
  stat1.mtime = new Date( Date.UTC( 2018, 1, 1 ) );
  var got = _.files.stat.areHardLinked( stat1, stat2 );
  test.identical( got, false );

}

//

function filesSize( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  var textData1 = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
  var textData2 = ' Aenean non feugiat mauris'
  var bufferData1, bufferData2;

  if( Config.interpreter === 'browser' || test.context.providerIsInstanceOf( _.FileProvider.Extract ) )
  {
    bufferData1 = new BufferRaw( 4 );
    bufferData2 = new BufferRaw( 5 );
  }
  else
  {
    bufferData1 = BufferNode.from( [ 0x01, 0x02, 0x03, 0x04 ] );
    bufferData2 =  BufferNode.from( [ 0x07, 0x06, 0x05 ] );
  }

  var  testChecks =
  [
    {
      name : 'empty file',
      path : 'filesSize/filesSize/rtext1.txt',
      expected : 0,
      data : ''
    },
    {
      name : 'text file1',
      data : textData1,
      path : 'filesSize/filesSize/text2.txt',
      expected : textData1.length
    },
    {
      name : 'text file 2',
      data : textData2,
      path : 'filesSize/filesSize/text3.txt',
      expected : textData2.length
    },
    {
      name : 'file binary',
      data : bufferData1,
      path : 'filesSize/filesSize/data1',
      expected : bufferData1.byteLength
    },
    {
      name : 'binary file 2',
      data : bufferData2,
      path : 'filesSize/filesSize/data2',
      expected : bufferData2.byteLength
    },
  ];

  for( var testCheck of testChecks )
  {
    // join several test aspects together

    let path = test.context.pathFor( testCheck.path );
    var got1;

    test.case = testCheck.name;

    provider.fileWrite( path, testCheck.data );

    try
    {
      got1 = provider.filesSize( path );
    }
    catch( err )
    {
      _.errLog( err );
    }

    let expected = testCheck.expected;
    if( _.bigIntIs( got1 ) )
    expected = BigInt( expected );
    test.identical( got1, expected );
  }

  var paths = testChecks.map( ( c ) => test.context.pathFor( c.path ) );
  var expected = testChecks.reduce( ( pc, cc ) => { return pc + cc.expected; }, 0 );

  test.case = 'all paths together';
  var got = provider.filesSize( paths );
  if( _.bigIntIs( got ) )
  expected = BigInt( expected );
  test.identical( got, expected );

  test.case = 'single path that exists';
  path = testChecks[ testChecks.length - 1 ].path
  var got = provider.filesSize( test.context.pathFor( path ) );
  var expected = testChecks[ testChecks.length - 1 ].expected;
  if( _.bigIntIs( got ) )
  expected = BigInt( expected );
  test.identical( got, expected )

  if( !Config.debug )
  return;

  test.case = 'single path that not exists';
  path = test.context.pathFor( 'filesSize/filesSize/notExistingPath' );
  test.shouldThrowErrorOfAnyKind( () => provider.filesSize({ filePath : path, throwing : 1 }) );

  test.case = 'single path that not exists';
  path = test.context.pathFor( 'filesSize/filesSize/notExistingPath' );
  var got = provider.filesSize({ filePath : path, throwing : 0 });
  test.identical( got, null );

  test.case = 'not existing path in array';
  path = test.context.pathFor( 'filesSize/filesSize/notExistingPath' );
  var path2 = testChecks[ testChecks.length - 1 ].path;
  var paths = [ path2, path ];
  test.shouldThrowErrorOfAnyKind( () => provider.filesSize( paths ) );

};

//

function fileSize( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  var textData1 = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
  var  textData2 = ' Aenean non feugiat mauris'
  var bufferData1, bufferData2;

  if( Config.interpreter === 'browser' || test.context.providerIsInstanceOf( _.FileProvider.Extract ) )
  {
    bufferData1 = new BufferRaw( 4 );
    bufferData2 = new BufferRaw( 5 );
  }
  else
  {
    bufferData1 = BufferNode.from( [ 0x01, 0x02, 0x03, 0x04 ] );
    bufferData2 =  BufferNode.from( [ 0x07, 0x06, 0x05 ] );
  }
  var  testChecks =
  [
    {
      name : 'empty file',
      path : 'tmp.tmp/fileSize/rtext1.txt',
      expected : 0,
      data : ''
    },
    {
      name : 'text file1',
      data : textData1,
      path : 'tmp.tmp/fileSize/text2.txt',
      expected : textData1.length
    },
    {
      name : 'text file 2',
      data : textData2,
      path : 'tmp.tmp/fileSize/text3.txt',
      expected : textData2.length
    },
    {
      name : 'file binary',
      data : bufferData1,
      path : 'tmp.tmp/fileSize/data1',
      expected : bufferData1.byteLength
    },
    {
      name : 'binary file 2',
      data : bufferData2,
      path : 'tmp.tmp/fileSize/data2',
      expected : bufferData2.byteLength
    },
  ];

  for( var testCheck of testChecks )
  {
    // join several test aspects together

    let path = test.context.pathFor( testCheck.path )
    var got;

    test.case = testCheck.name;

    provider.fileWrite( path, testCheck.data );

    try
    {
      got = provider.fileSize( path );
    }
    catch( err ) {}

    let expected = testCheck.expected;
    if( _.bigIntIs( got ) )
    expected = BigInt( expected );
    test.identical( got, expected );
  }

  /* - */

  if( Config.debug )
  return;

  test.case = 'missed arguments';
  test.shouldThrowErrorSync( function( )
  {
    provider.fileSize( );
  });

  test.case = 'extra arguments';
  test.shouldThrowErrorSync( function( )
  {
    provider.fileSize( test.context.pathFor( 'tmp.tmp/fileSize/data2' ), test.context.pathFor( 'tmp.tmp/fileSize/data3' ) );
  });

  test.case = 'path is not string';
  test.shouldThrowErrorSync( function( )
  {
    provider.fileSize( { filePath : null } );
  });

  test.case = 'passed unexpected property';
  test.shouldThrowErrorSync( function( )
  {
    provider.fileSize( { filePath : test.context.pathFor( 'tmp.tmp/fileSize/data2' ), dir : test.context.pathFor( 'tmp.tmp/fileSize/data3' ) } );
  });

};

//

function fileExists( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let testDirPath = test.context.pathFor( 'written/fileExists' );
  let srcPath = test.context.pathFor( 'written/fileExists/src' );
  let dstPath = test.context.pathFor( 'written/fileExists/dst' );

  let hardLinked = true;
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  provider.filesDelete( testDirPath );

  test.case = 'not existing file';
  var got = provider.fileExists( srcPath );
  test.identical( got, false );

  test.case = 'terminal file as directory';
  provider.fileWrite( srcPath, srcPath );
  var filePath = provider.path.join( srcPath, 'notExistingFile' );
  var got = provider.fileExists( filePath );
  test.identical( got, false );

  test.case = 'regular file';
  provider.fileWrite( srcPath, srcPath );
  var got = provider.fileExists( srcPath );
  test.identical( got, true );

  test.case = 'directory';
  provider.dirMakeForFile( srcPath );
  var got = provider.fileExists( testDirPath );
  test.is( provider.isDir( testDirPath ) );
  test.identical( got, true );

  test.case = 'hard link to file';
  provider.fileWrite( srcPath, srcPath );
  provider.hardLink( dstPath, srcPath );
  var got = provider.fileExists( dstPath );
  if( context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.areHardLinked([ dstPath, srcPath ]), hardLinked );
  else
  test.identical( provider.areHardLinked([ dstPath, srcPath ]), true );
  test.identical( got, true );

  if( !test.context.softLinkIsSupported() )
  return;

  test.case = 'soft link to file';
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPath, srcPath );
  var got = provider.fileExists( dstPath );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( got, true );

  test.case = 'soft link to file that not exists';
  provider.filesDelete( srcPath );
  provider.softLink({ dstPath, srcPath, allowingMissed : 1 });
  var got = provider.fileExists( dstPath );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( got, true );
}

//

function fileExistsCompliantBehavior( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/fileExistsCompliantBehavior' );
  let srcPath = test.context.pathFor( 'written/fileExistsCompliantBehavior/src' );
  let dstPath = test.context.pathFor( 'written/fileExistsCompliantBehavior/dst' );
  let dstPath2 = test.context.pathFor( 'written/fileExistsCompliantBehavior/dst2' );

  /*
    checks that fileExists has same behavior for hd & extract providers:
    resolves intermediate directories, but does not resolve terminal
  */

  test.case = 'soft link to missing, not intermediate links';
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    dstPath,
    srcPath,
    allowingMissed : 1,
    makingDirectory : 1
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );

  /* - */

  test.case = 'soft link chain to missing, not intermediate links';
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    dstPath : dstPath2,
    srcPath,
    allowingMissed : 1,
    makingDirectory : 1
  });
  provider.softLink
  ({
    dstPath,
    srcPath : dstPath2,
    allowingMissed : 1,
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  test.is( provider.fileExists( dstPath2 ) );

  /* - */

  test.case = 'path to missing, intermediate link to testDir';
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    dstPath,
    srcPath : routinePath,
    allowingMissed : 1,
    makingDirectory : 1
  });
  var pathToCheck = path.join( dstPath, 'src' );
  test.is( !provider.fileExists( pathToCheck ) );
  test.is( provider.fileExists( dstPath ) );

  /* - */

  test.case = 'path to terminal, intermediate link to testDir';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink
  ({
    dstPath,
    srcPath : routinePath,
  });
  var pathToCheck = path.join( dstPath, 'src' );
  test.is( provider.fileExists( pathToCheck ) );
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );

  /* - */

  test.case = 'path to terminal, intermediate link to soft link in same directory';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath2, dstPath2 );
  provider.softLink
  ({
    dstPath : srcPath,
    srcPath : routinePath,
  });
  provider.softLink
  ({
    dstPath,
    srcPath,
  });
  /* dst -> src -> routinePath */
  var pathToCheck = path.join( routinePath, 'dst/dst2' );
  test.is( provider.fileExists( pathToCheck ) );
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );

}

// --
// record
// --

function record( test )
{
  let context = this;
  let system = context.system || context.provider;
  let providerEffective = context.providerEffective || context.provider;

  test.is( providerEffective.system === system );
  test.is( _.longHas( _.mapKeys( system.providersWithProtocolMap ), providerEffective.protocol ) );

  var filePath = '/record/terminal';
  var expected = filePath;
  var record = context.provider.record( filePath );
  test.identical( record.absolute, expected );

  var filePath = test.context.globalFromPreferred( '/record/terminal' );
  var expected = '/record/terminal';
  var record = context.provider.record( filePath );
  test.identical( record.absolute, expected );

}

//

function recordStat( test )
{
  let context = this;
  let system = context.system || context.provider;
  let providerEffective = context.providerEffective || context.provider;

  test.is( providerEffective.system === system );
  test.is( _.longHas( _.mapKeys( system.providersWithProtocolMap ), providerEffective.protocol ) );

  let filePath = test.context.pathFor( 'written/recordStat/file' );
  var record = context.provider.recordFactory({ allowingMissed : 1 }).record( filePath );
  test.identical( record.stat, null );
  test.identical( record.absolute, providerEffective.path.preferredFromGlobal( filePath ) );
  test.identical( record.real, providerEffective.path.preferredFromGlobal( filePath ) );
}

recordStat.description =
`
  FileRecord instance for non existing file is created using global path and factory option allowingMissed.
  First request of record.stat property returns null.
  No errors are thrown on path resolving stage.
`

// --
// path
// --

function localsFromGlobals( test )
{
  let context = this;
  let srcProvider = context.providerEffective || context.provider;
  let provider = new srcProvider.constructor({ protocol : 'global' });

  test.open( 'string' );

  test.case = 'local';
  var got = provider.path.localsFromGlobals( '/a' );
  test.identical( got, '/a' );

  test.case = 'relative';
  var got = provider.path.localsFromGlobals( 'a' );
  test.identical( got, 'a' );

  test.case = 'single global string';
  var got = provider.path.localsFromGlobals( 'global:///a' );
  test.identical( got, '/a' )

  test.close( 'string' );

  test.open( 'array' );

  test.case = 'single global in array';
  var got = provider.path.localsFromGlobals( [ 'global:///a' ] );
  test.identical( got, [ '/a' ] )

  test.case = 'globals in array';
  var got = provider.path.localsFromGlobals( [ 'global:///a', 'global:///a/b' ] );
  test.identical( got, [ '/a', '/a/b' ] )

  test.close( 'array' );

  test.open( 'map' );

  var got = provider.path.localsFromGlobals( { 'global:///a' : 'global:///a' } );
  test.identical( got, { '/a' : '/a' } )

  var got = provider.path.localsFromGlobals( { '/a' : 'global:///a' } );
  test.identical( got, { '/a' : '/a' } )

  var got = provider.path.localsFromGlobals( { 'global:///a' : '/a' } );
  test.identical( got, { '/a' : '/a' } )

  var got = provider.path.localsFromGlobals( { 'global:///a' : 1 } );
  test.identical( got, { '/a' : 1 } )

  var got = provider.path.localsFromGlobals( { 1 : 'global:///a' } );
  test.identical( got, { 1 : '/a' } )

  var got = provider.path.localsFromGlobals( { 1 : 1 } );
  test.identical( got, { 1 : 1 } )

  test.close( 'map' );

  if( !Config.debug )
  return;

  test.shouldThrowErrorSync( () => provider.path.localsFromGlobals( '/a', '/b' ) );
  test.shouldThrowErrorSync( () => provider.path.localsFromGlobals( 'b:///a' ) );
  test.shouldThrowErrorSync( () => provider.path.localsFromGlobals( [ 'b:///a' ] ) );
  test.shouldThrowErrorSync( () => provider.path.localsFromGlobals( { 'b:///a' : '/a' } ) );
  test.shouldThrowErrorSync( () => provider.path.localsFromGlobals( { '/a' : 'b:///a' } ) );
  test.shouldThrowErrorSync( () => provider.path.localsFromGlobals( { '/a' : [] } ) );
  test.shouldThrowErrorSync( () => provider.path.localsFromGlobals( { '/a' : {} } ) );

  provider.finit();

}

//

function globalsFromLocals( test )
{
  let context = this;
  // let a = context.assetFor( test, false ); xxx
  let srcProvider = context.providerEffective || context.provider;
  let provider = new srcProvider.constructor({ protocol : 'global' });

  test.open( 'string' );

  test.case = 'local';
  var got = provider.path.globalsFromLocals( '/a' );
  test.identical( got, 'global:///a' );

  test.case = 'relative';
  var got = provider.path.globalsFromLocals( 'a' );
  test.identical( got, 'global://a' );

  test.case = 'global string';
  var got = provider.path.globalsFromLocals( 'global:///a' );
  test.identical( got, 'global:///a' )

  test.case = 'global string';
  var got = provider.path.globalsFromLocals( 'other:///a' );
  test.identical( got, 'other:///a' )

  test.close( 'string' );

  test.open( 'array' );

  test.case = 'single global in array';
  var got = provider.path.globalsFromLocals( [ 'global:///a' ] );
  test.identical( got, [ 'global:///a' ] )

  test.case = 'single global in array';
  var got = provider.path.globalsFromLocals( [ 'other:///a' ] );
  test.identical( got, [ 'other:///a' ] )

  test.case = 'globals in array';
  var got = provider.path.globalsFromLocals( [ 'global:///a', '/a/b', 'other:///a' ] );
  test.identical( got, [ 'global:///a', 'global:///a/b', 'other:///a' ] )

  test.close( 'array' );

  test.open( 'map' );

  var got = provider.path.globalsFromLocals( { 'global:///a' : 'other:///a' } );
  test.identical( got, { 'global:///a' : 'other:///a' } )

  var got = provider.path.globalsFromLocals( { 'other:///a' : 'global:///a' } );
  test.identical( got, { 'other:///a' : 'global:///a' } )

  var got = provider.path.globalsFromLocals( { '/a' : 'global:///a' } );
  test.identical( got, { 'global:///a' : 'global:///a' } )

  var got = provider.path.globalsFromLocals( { '/a' : '/a' } );
  test.identical( got, { 'global:///a' : 'global:///a' } )

  var got = provider.path.globalsFromLocals( { 'global:///a' : '/a' } );
  test.identical( got, { 'global:///a' : 'global:///a' } )

  var got = provider.path.globalsFromLocals( { 'global:///a' : 1 } );
  test.identical( got, { 'global:///a' : 1 } )

  var got = provider.path.globalsFromLocals( { 1 : '/a' } );
  test.identical( got, { 'global://1' : 'global:///a' } )

  var got = provider.path.globalsFromLocals( { 1 : 'global:///a' } );
  test.identical( got, { 'global://1' : 'global:///a' } )

  var got = provider.path.globalsFromLocals( { 1 : 1 } );
  test.identical( got, { 'global://1' : 1 } )

  test.close( 'map' );

  if( !Config.debug )
  return;

  test.shouldThrowErrorSync( () => provider.path.globalsFromLocals( '/a', '/b' ) );
  test.shouldThrowErrorSync( () => provider.path.globalsFromLocals( { '/a' : [] } ) );
  test.shouldThrowErrorSync( () => provider.path.globalsFromLocals( { '/a' : {} } ) );

  provider.finit();

}

//

function pathResolve( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;
  let resolve = _.routineJoin( provider.path, provider.path.resolve );
  let join = _.routineJoin( provider.path, provider.path.join );
  let current = _.routineJoin( provider.path, provider.path.current );

  test.case = 'join windows os paths';
  var got = resolve( 'c:\\', 'foo\\', 'bar\\' );
  var expected = '/c/foo/bar/';
  test.identical( got, expected );

  test.case = 'join unix os paths';
  var got = resolve( '/bar/', '/baz', 'foo/', '.' )
  var expected = '/baz/foo';
  test.identical( got, expected );

  /* */

  test.case = 'here cases';

  var expected = join( current(), 'aa/cc' );
  var got = resolve( 'aa', '.', 'cc' );
  test.identical( got, expected );

  var expected = join( current(), 'aa/cc' );
  var got = resolve( 'aa', 'cc', '.' )
  test.identical( got, expected );

  var expected = join( current(), 'aa/cc' );
  var got = resolve( '.', 'aa', 'cc' );
  test.identical( got, expected );

  /* */

  test.case = 'down cases';

  var expected = join( current(), 'aa' );
  var got = resolve( '.', 'aa', 'cc', '..' );
  test.identical( got, expected );

  var expected = current();
  var got = resolve( '.', 'aa', 'cc', '..', '..' );
  test.identical( got, expected );

  var expected = _.strIsolateRightOrNone( current(), '/' )[ 0 ];
  if( current() === '/' )
  expected = '/..';
  var got = resolve( 'aa', 'cc', '..', '..', '..' );
  test.identical( got, expected );

  /* */

  test.case = 'like-down or like-here cases';

  var expected = join( current(), '.x./aa/bb/.x.' );
  var got = resolve( '.x.', 'aa', 'bb', '.x.' );
  test.identical( got, expected );

  var expected = join( current(), '..x../aa/bb/..x..' );
  var got = resolve( '..x..', 'aa', 'bb', '..x..' )
  test.identical( got, expected );

  /* */

  test.case = 'period and double period combined';

  var expected = '/a/b';
  var got = resolve( '/abc', './../a/b');
  test.identical( got, expected );

  var expected = '/abc/a/b';
  var got = resolve( '/abc', 'a/.././a/b');
  test.identical( got, expected );

  var expected = '/a/b';
  var got = resolve( '/abc', '.././a/b' );
  test.identical( got, expected );

  var expected = '/a/b';
  var got = resolve( '/abc', './.././a/b'  );
  test.identical( got, expected );

  var expected = '/';
  var got = resolve( '/abc', './../.' );
  test.identical( got, expected );

  var expected = '/..';
  var got = resolve( '/abc', './../../.' );
  test.identical( got, expected );

  var expected = '/';
  var got = resolve( '/abc', './../.' );
  test.identical( got, expected );

  /* - */

  // var expected = current();
  var expected = null;
  var got = resolve( null );
  test.identical( got, expected );

  var expected = '/a/b';
  var got = resolve( null, '/a', 'b' );
  test.identical( got, expected );

  var expected = '/a/b';
  var got = resolve( null, '/a', 'b' );
  test.identical( got, expected );

  debugger;
  // var expected = join( current(), 'b' );
  var expected = 'b';
  debugger;
  var got = resolve( '/a', null, 'b' );
  test.identical( got, expected );
  debugger;

  var expected = null;
  var got = resolve( '/a', 'b', null );
  test.identical( got, expected );

  var expected = '/b';
  var got = resolve( null, 'a', '/b' );
  test.identical( got, expected );

  var expected = '/b';
  var got = resolve( 'a', null, '/b' );
  test.identical( got, expected );

  var expected = null;
  var got = resolve( 'a', '/b', null );
  test.identical( got, expected );

  var expected = '/b';
  var got = resolve( null, '/a', '../b' );
  test.identical( got, expected );

  // var expected = join( provider.path.dir( current() ), 'b' );
  var expected = '../b';
  var got = resolve( '/a', null, '../b' );
  test.identical( got, expected );

  var expected = current();
  var got = resolve();
  test.identical( got, expected );

  if( !Config.debug )
  return;

  // test.case = 'nothing passed';
  // test.shouldThrowErrorSync( function()
  // {
  //   resolve();
  // });

  test.case = 'non string passed';
  test.shouldThrowErrorSync( function()
  {
    resolve( {} );
  });

}

//

function uriResolve( test )
{
  let context = this;
  let a = context.assetFor( test, false );
  let provider = a.fileProvider;
  let path = provider.path;
  let resolve = _.routineJoin( provider.path, provider.path.resolve );
  let join = _.routineJoin( provider.path, provider.path.join );
  let current = _.routineJoin( provider.path, provider.path.current );

  if( !path.Uri )
  {
    test.identical( 1, 1 );
    return;
  }

  test.open( 'with protocol' );

  var got = resolve( 'http://www.site.com:13', 'a' );
  test.identical( got, join( current(), 'http://www.site.com:13/a' ) );

  var got = resolve( 'http://www.site.com:13/', 'a' );
  test.identical( got, join( current(), 'http://www.site.com:13/a' ) );

  var got = resolve( 'http://www.site.com:13/', 'a', 'b' );
  test.identical( got, join( current(), 'http://www.site.com:13/a/b' ) );

  var got = resolve( 'http://www.site.com:13', 'a', '/b' );
  test.identical( got, join( current(), 'http:///b' ) );

  var got = resolve( 'http://www.site.com:13/', 'a', 'b', '.' );
  test.identical( got, join( current(), 'http://www.site.com:13/a/b' ) );

  var got = resolve( 'http://www.site.com:13', 'a', '/b', 'c' );
  test.identical( got, join( current(), 'http:///b/c' ) );

  var got = resolve( 'http://www.site.com:13', '/a/', '/b/', 'c/', '.' );
  test.identical( got, join( current(), 'http:///b/c' ) );

  var got = resolve( 'http://www.site.com:13', 'a', '.', 'b' );
  test.identical( got, join( current(), 'http://www.site.com:13/a/b' ) );

  var got = resolve( 'http://www.site.com:13/', 'a', '.', 'b' );
  test.identical( got, join( current(), 'http://www.site.com:13/a/b' ) );

  var got = resolve( 'http://www.site.com:13', 'a', '..', 'b' );
  test.identical( got, join( current(), 'http://www.site.com:13/b' ) );

  var got = resolve( 'http://www.site.com:13', 'a', '..', '..', 'b' );
  test.identical( got, join( current(), 'http://b' ) );

  var got = resolve( 'http://www.site.com:13', '.a.', 'b', '.c.' );
  test.identical( got, join( current(), 'http://www.site.com:13/.a./b/.c.' ) );

  var got = resolve( 'http://www.site.com:13', 'a/../' );
  test.identical( got, join( current(), 'http://www.site.com:13/' ) );

  test.close( 'with protocol' );

  /* - */

  test.open( 'with null protocol' );

  var got = resolve( '://www.site.com:13', 'a' );
  test.identical( got, join( current(), '://www.site.com:13/a' ) );

  var got = resolve( '://www.site.com:13', 'a', '/b' );
  test.identical( got, join( current(), ':///b' ) );

  var got = resolve( '://www.site.com:13', 'a', '/b', 'c' );
  test.identical( got, join( current(), ':///b/c' ) );

  var got = resolve( '://www.site.com:13', '/a/', '/b/', 'c/', '.' );
  test.identical( got, join( current(), ':///b/c' ) );

  var got = resolve( '://www.site.com:13', 'a', '.', 'b' );
  test.identical( got, join( current(), '://www.site.com:13/a/b' ) );

  var got = resolve( '://www.site.com:13', 'a', '..', 'b' );
  test.identical( got, join( current(), '://www.site.com:13/b' ) );

  var got = resolve( '://www.site.com:13', 'a', '..', '..', 'b' );
  test.identical( got, join( current(), '://b' ) );

  var got = resolve( '://www.site.com:13', '.a.', 'b', '.c.' );
  test.identical( got, join( current(), '://www.site.com:13/.a./b/.c.' ) );

  var got = resolve( '://www.site.com:13', 'a/../' );
  test.identical( got, join( current(), '://www.site.com:13/' ) );

  test.close( 'with null protocol' );

  /* */

  var got = resolve( ':///www.site.com:13', 'a' );
  test.identical( got, ':///www.site.com:13/a' );

  var got = resolve( ':///www.site.com:13/', 'a' );
  test.identical( got, ':///www.site.com:13/a' );

  var got = resolve( ':///www.site.com:13', 'a', '/b' );
  test.identical( got, ':///b' );

  var got = resolve( ':///www.site.com:13', 'a', '/b', 'c' );
  test.identical( got, ':///b/c' );

  var got = resolve( ':///www.site.com:13', '/a/', '/b/', 'c/', '.' );
  test.identical( got, ':///b/c' );

  var got = resolve( ':///www.site.com:13', 'a', '.', 'b' );
  test.identical( got, ':///www.site.com:13/a/b' );

  var got = resolve( ':///www.site.com:13/', 'a', '.', 'b' );
  test.identical( got, ':///www.site.com:13/a/b' );

  var got = resolve( ':///www.site.com:13', 'a', '..', 'b' );
  test.identical( got, ':///www.site.com:13/b' );

  var got = resolve( ':///www.site.com:13', 'a', '..', '..', 'b' );
  test.identical( got, ':///b' );

  var got = resolve( ':///www.site.com:13', '.a.', 'b', '.c.' );
  test.identical( got, ':///www.site.com:13/.a./b/.c.' );

  var got = resolve( ':///www.site.com:13/', '.a.', 'b', '.c.' );
  test.identical( got, ':///www.site.com:13/.a./b/.c.' );

  var got = resolve( ':///www.site.com:13', 'a/../' );
  test.identical( got, ':///www.site.com:13/' );

  var got = resolve( ':///www.site.com:13/', 'a/../' );
  test.identical( got, ':///www.site.com:13/' );

  /* */

  var got = resolve( '/some/staging/index.html', 'a' );
  test.identical( got, '/some/staging/index.html/a' );

  var got = resolve( '/some/staging/index.html', '.' );
  test.identical( got, '/some/staging/index.html' );

  var got = resolve( '/some/staging/index.html/', 'a' );
  test.identical( got, '/some/staging/index.html/a' );

  var got = resolve( '/some/staging/index.html', 'a', '/b' );
  test.identical( got, '/b' );

  var got = resolve( '/some/staging/index.html', 'a', '/b', 'c' );
  test.identical( got, '/b/c' );

  var got = resolve( '/some/staging/index.html', '/a/', '/b/', 'c/', '.' );
  test.identical( got, '/b/c' );

  var got = resolve( '/some/staging/index.html', 'a', '.', 'b' );
  test.identical( got, '/some/staging/index.html/a/b' );

  var got = resolve( '/some/staging/index.html/', 'a', '.', 'b' );
  test.identical( got, '/some/staging/index.html/a/b' );

  var got = resolve( '/some/staging/index.html', 'a', '..', 'b' );
  test.identical( got, '/some/staging/index.html/b' );

  var got = resolve( '/some/staging/index.html', 'a', '..', '..', 'b' );
  test.identical( got, '/some/staging/b' );

  var got = resolve( '/some/staging/index.html', '.a.', 'b', '.c.' );
  test.identical( got, '/some/staging/index.html/.a./b/.c.' );

  var got = resolve( '/some/staging/index.html/', '.a.', 'b', '.c.' );
  test.identical( got, '/some/staging/index.html/.a./b/.c.' );

  var got = resolve( '/some/staging/index.html', 'a/../' );
  test.identical( got, '/some/staging/index.html/' );

  var got = resolve( '/some/staging/index.html/', 'a/../' );
  test.identical( got, '/some/staging/index.html/' );

  var got = resolve( '//some/staging/index.html', '.', 'a' );
  test.identical( got, '//some/staging/index.html/a' )

  var got = resolve( '///some/staging/index.html', 'a', '.', 'b', '..' );
  test.identical( got, '///some/staging/index.html/a' )

  var got = resolve( 'file:///some/staging/index.html', '../..' );
  test.identical( got, 'file:///some' )

  var got = resolve( 'svn+https://user@subversion.com/svn/trunk', '../a', 'b', '../c' );
  test.identical( got, join( current(), 'svn+https://user@subversion.com/svn/a/c' ) );

  var got = resolve( 'complex+protocol://www.site.com:13/path/name?query=here&and=here#anchor', '../../path/name' );
  test.identical( got, join( current(), 'complex+protocol://www.site.com:13/path/name?query=here&and=here#anchor' ) );

  var got = resolve( 'https://web.archive.org/web/*\/http://www.heritage.org/index/ranking', '../../../a.com' );
  test.identical( got, join( current(), 'https://web.archive.org/web/*\/http://a.com' ) );

  var got = resolve( '127.0.0.1:61726', '../path'  );
  test.identical( got, join( current(), 'path' ) )

  var got = resolve( 'http://127.0.0.1:61726', '../path'  );
  test.identical( got, join( current(), 'http://path' ) );

  /* - */

  var expected = 'file:///staging';
  var got = resolve( null, 'file:///some/index.html', '/staging' );
  test.identical( got, expected );

  // var expected = join( current(), 'staging' );
  var expected = 'staging';
  var got = resolve( 'file:///some/index.html', null, 'staging' );
  test.identical( got, expected );

  var expected = null;
  var got = resolve( 'file:///some', 'staging', null );
  test.identical( got, expected );

  var expected = 'file:///some';
  var got = resolve( null, 'a', 'file:///some' );
  test.identical( got, expected );

  var expected = 'file:///some';
  var got = resolve( 'a', null, 'file:///some' );
  test.identical( got, expected );

  var expected = null;
  var got = resolve( 'a', 'file:///some', null );
  test.identical( got, expected );

  var expected = 'file:///b';
  var got = resolve( null, 'file:///some', '../b' );
  test.identical( got, expected );

  // var expected = join( provider.path.dir( current() ), 'b' );
  var expected = '../b';
  var got = resolve( 'file:///some', null, '../b' );
  test.identical( got, expected );

}

//

function linkingCriticalCases( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  /*
    qqq : cases with preservingRelative : 0 or resolvingHeadDirect : 0 are disabled,
    pathResolveLinkFull does not allow to disable these option for now
    Vova : low priority
  */

  let routinePath = test.context.pathFor( 'written/linkingCriticalCases' );
  let filePath = test.context.pathFor( 'written/linkingCriticalCases/file' );
  let linkPath = test.context.pathFor( 'written/linkingCriticalCases/link' );
  let linkPath2 = test.context.pathFor( 'written/linkingCriticalCases/link2' );

  /* */

  test.case = 'not existing file, allowingMissed : 0';
  provider.filesDelete( context.provider.path.dir( filePath ) );

  // works after change in pathResolveLinkHeadDirect
  var got = provider.pathResolveLinkFull
  ({
    filePath,
    allowingMissed : 0,
    resolvingHeadDirect : 1,
    resolvingHeadReverse : 1,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
  });
  test.identical( got.filePath, null );
  test.identical( got.absolutePath, null );
  test.identical( got.relativePath, null );

  test.case = 'not existing file, allowingMissed : 1';

  var got = provider.pathResolveLinkFull
  ({
    filePath,
    allowingMissed : 1,
    resolvingHeadDirect : 1,
    resolvingHeadReverse : 1,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
  });
  test.identical( got.absolutePath, filePath );

  // test.case = 'not existing file, allowingMissed : 0, resolvingHeadDirect : 0, resolvingHeadReverse : 0';

  // var got = provider.pathResolveLinkFull
  // ({
  //   filePath,
  //   allowingMissed : 0,
  //   resolvingHeadDirect : 0,
  //   resolvingHeadReverse : 0,
  //   resolvingSoftLink : 1,
  //   resolvingTextLink : 1,
  //   throwing : 0,
  // });
  // test.identical( got, null );

  // var got = provider.pathResolveLinkFull
  // ({
  //   filePath,
  //   allowingMissed : 0,
  //   resolvingHeadDirect : 1,
  //   resolvingHeadReverse : 0,
  //   resolvingSoftLink : 1,
  //   resolvingTextLink : 1,
  //   throwing : 0,
  // });
  // test.identical( got, null );

  /* - */

  test.case = 'not existing file';
  provider.filesDelete( context.provider.path.dir( filePath ) );

  //should return same even if resolvingHead is off
  // var got = provider.pathResolveLinkFull
  // ({
  //   filePath,
  //   allowingMissed : 0,
  //   resolvingHeadDirect : 0,
  //   resolvingHeadReverse : 0,
  //   resolvingSoftLink : 1,
  //   resolvingTextLink : 1,
  //   throwing : 0,
  // });
  // test.identical( got, null );

  /* */

  // works after change in pathResolveLinkHeadDirect
  // test.case = 'two soft links in path';
  // provider.filesDelete( path.dir( filePath ) );
  // provider.fileWrite( filePath, filePath );
  // provider.softLink( linkPath, '..' );
  // provider.softLink( linkPath2, '../file' );
  // var o =
  // {
  //   filePath : path.join( routinePath, 'link/link2' ),
  //   preservingRelative : 1,
  //   resolvingHeadDirect : 1,
  //   resolvingHeadReverse : 0,
  //   allowingMissed : 0,
  //   throwing : 1
  // };
  // var got = provider.pathResolveLinkFull( o );
  // var expectedResult = filePath;
  // test.identical( got, expectedResult );

  /* */

  //this case does not work becase of _softLinkSkip
  test.case = 'cycle softLink, throwing on'
  provider.filesDelete( context.provider.path.dir( filePath ) );

  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });

  test.is( provider.isSoftLink( linkPath ) );
  test.is( provider.isSoftLink( linkPath2 ) );

  let files = provider.dirRead( routinePath );
  test.identical( files, [ 'link', 'link2' ] );

  var o =
  {
    filePath : linkPath,
    preservingRelative : 1,
    allowingCycled : 1,
    throwing : 1
  };
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath, null ] );

}

//

function pathResolveLinkTailChain( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  /* - */

  let o1 =
  {
    system : null,
    filePath : null,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    preservingRelative : 0,
    allowingMissed : 1,
    throwing : 1
  }

  let routinePath = test.context.pathFor( 'written/pathResolveLinkTailChain' );
  let filePath = test.context.pathFor( 'written/pathResolveLinkTailChain/file' );
  let linkPath = test.context.pathFor( 'written/pathResolveLinkTailChain/link' );
  let linkPath2 = test.context.pathFor( 'written/pathResolveLinkTailChain/link2' );
  let linkPath3 = test.context.pathFor( 'written/pathResolveLinkTailChain/link3' );

  provider.fieldPush( 'usingTextLink', true );

  /* - */

  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, filePath );

  var o =
  {
    filePath : linkPath,
    resolvingSoftLink : 1,
  }
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] );
  test.identical( o.found, [ linkPath, filePath ] );

  /* trivial */

  // var tree =
  // {
  //   directory :
  //   {
  //     terminal : 'terminal'
  //   },
  //   toDir : [{ softLink : '/directory' }]
  // }

  provider.fileWrite( path.join( routinePath, 'directory/terminal' ), 'terminal' );
  provider.dirMake( path.join( routinePath, 'toDir' ) );
  provider.softLink( path.join( routinePath, 'toDir/softLink' ), path.join( routinePath, 'directory/terminal' ) );

  var o =
  {
    filePath : path.join( routinePath, 'toDir/softLink' ),
    // resolvingHeadDirectories : 1,
    allowingMissed : 1,
    throwing : 1,
  }
  var got = provider.pathResolveLinkTailChain( o );

  test.is( got === o.result );
  test.identical( o.result, [ path.join( routinePath, 'toDir/softLink' ), path.join( routinePath, 'directory/terminal' ) ] );
  test.identical( o.found, [ path.join( routinePath, 'toDir/softLink' ), path.join( routinePath, 'directory/terminal' ) ] );

  /*
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    preservingRelative : [ 0, 1 ],
    allowingMissed : [ 0, 1 ],
    throwing : 1
  */

  /* basic */

  test.case = 'not existing file';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  var o = _.mapExtend( null, o1, { filePath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ filePath, null ] )
  test.identical( o.found, [ filePath, null ] )

  test.case = 'existing file';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  var o = _.mapExtend( null, o1, { filePath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ filePath ] )
  test.identical( o.found, [ filePath ] )

  test.case = 'hardLink';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.hardLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath ] )
  test.identical( o.found, [ linkPath ] )

  test.case = 'softLink';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] )
  test.identical( o.found, [ linkPath, filePath ] )

  test.case = 'relative softLink';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, '../file' );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] )
  test.identical( o.found, [ linkPath, filePath ] )

  test.case = 'relative softLink, preservingRelative : 1';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, '../file' );
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  provider.pathResolveLinkTailChain( o );
  var expectedFound = [ linkPath, filePath ]
  var expectedResult = [ linkPath, test.context.globalFromPreferred( '../file' ) ]
  test.identical( o.result, expectedResult );
  test.identical( o.found, expectedFound );

  test.case = 'textLink';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] )
  test.identical( o.found, [ linkPath, filePath ] )

  /* - */

  test.case = 'absolute softLink to missing'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePath,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0 } );
  var got = provider.pathResolveLinkTailChain( o );
  var expectedResult =
  [
    linkPath,
    filePath,
    null
  ]
  var expectedFound =
  [
    linkPath,
    filePath,
    null
  ]
  test.identical( o.result, expectedResult );
  test.identical( o.found, expectedFound );

  /* - */

  test.case = 'absolute softLink to missing'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePath,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, preservingRelative : 1 } );
  var got = provider.pathResolveLinkTailChain( o );
  var expectedResult =
  [
    linkPath,
    filePath,
    null
  ]
  var expectedFound =
  [
    linkPath,
    filePath,
    null
  ]
  test.identical( o.result, expectedResult );
  test.identical( o.found, expectedFound );

  /* - */

  test.case = 'relative softLink to missing'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  var filePathRelative = provider.path.relative( linkPath, filePath );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePathRelative,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0 } );
  var got = provider.pathResolveLinkTailChain( o );
  var expectedResult =
  [
    linkPath,
    filePath,
    null
  ]
  var expectedFound =
  [
    linkPath,
    filePath,
    null
  ]
  test.identical( o.result, expectedResult );
  test.identical( o.found, expectedFound );

  /* - */

  test.case = 'relative softLink to missing'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  var filePathRelative = provider.path.relative( linkPath, filePath );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePathRelative,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, preservingRelative : 1 } );
  var got = provider.pathResolveLinkTailChain( o );
  var expectedFound =
  [
    linkPath,
    filePath,
    null
  ]
  var expectedResult =
  [
    linkPath,
    test.context.globalFromPreferred( '../file' ),
    null
  ]
  test.identical( o.result, expectedResult );
  test.identical( o.found, expectedFound );

  /* - */

  test.case = 'absolute softLink to missing, allowingMissed : 0'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePath,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 0 } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );

  /* - */

  test.case = 'absolute softLink to missing, allowingMissed : 1'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePath,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 1 } );
  var got = provider.pathResolveLinkTailChain( o );
  var expectedFound =
  [
    linkPath,
    filePath,
    null
  ]
  var expectedResult =
  [
    linkPath,
    filePath,
    null
  ]
  test.identical( o.result, expectedResult );
  test.identical( o.found, expectedFound );

  /* - */

  test.case = 'relative softLink to missing'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  var filePathRelative = provider.path.relative( linkPath, filePath );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePathRelative,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 0  } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );

  /* - */

  test.case = 'relative softLink to missing'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  var filePathRelative = provider.path.relative( linkPath, filePath );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePathRelative,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 1  } );
  var got = provider.pathResolveLinkTailChain( o );
  var expectedFound =
  [
    linkPath,
    filePath,
    null
  ]
  var expectedResult =
  [
    linkPath,
    filePath,
    null
  ]
  test.identical( o.result, expectedResult );
  test.identical( o.found, expectedFound );

  /* chain */

  test.case = 'soft-soft-file';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath2, filePath );
  provider.softLink( linkPath, linkPath2 );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, filePath ] );
  test.identical( o.found, [ linkPath, linkPath2, filePath ] );

  test.case = 'soft-soft-file, preservingRelative';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath2, filePath );
  provider.softLink( linkPath, linkPath2 );
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, filePath ] );
  test.identical( o.found, [ linkPath, linkPath2, filePath ] );

  test.case = 'text-text-file';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, filePath ] );
  test.identical( o.found, [ linkPath, linkPath2, filePath ] );

  test.case = 'text-text-file, preservingRelative';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, filePath ] );
  test.identical( o.found, [ linkPath, linkPath2, filePath ] );

  test.case = 'soft-text-soft-file';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.softLink( linkPath, linkPath2 );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath3, filePath ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath3, filePath ] );

  test.case = 'soft-text-soft-file, preservingRelative';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.softLink( linkPath, linkPath2 );
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath3, filePath ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath3, filePath ] );

  test.case = 'text-soft-text-file';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink( linkPath2, linkPath3 );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath3, filePath ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath3, filePath ] );

  test.case = 'text-soft-text-file, preservingRelative';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink( linkPath2, linkPath3 );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath3, filePath ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath3, filePath ] );

  test.case = 'relative soft-relative soft-soft-file, preservingRelative : 1';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath3, filePath );
  provider.softLink( linkPath2, '../link3' );
  provider.softLink( linkPath, test.context.globalFromPreferred( '../link2' ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  provider.pathResolveLinkTailChain( o );
  var expectedFound =
  [
    linkPath,
    linkPath2,
    linkPath3,
    filePath
  ]
  var expectedResult =
  [
    linkPath,
    test.context.globalFromPreferred( '../link2' ),
    test.context.globalFromPreferred( '../link3' ),
    filePath
  ]
  test.identical( o.result, expectedResult );
  test.identical( o.found, expectedFound);

  debugger;

  test.case = 'soft-hard-text-file';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.hardLink( linkPath2, linkPath3 );
  provider.softLink( linkPath, linkPath2 );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath3, filePath ] )
  test.identical( o.found, [ linkPath, linkPath2, linkPath3, filePath ] )

  test.case = 'relative soft-hard-text-file';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.hardLink( linkPath2, linkPath3 );
  provider.softLink( linkPath, provider.path.relative( linkPath, linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 0 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath3, filePath ] )
  test.identical( o.found, [ linkPath, linkPath2, linkPath3, filePath ] )

  test.case = 'relative soft-hard-text-file';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.hardLink( linkPath2, linkPath3 );
  provider.softLink( linkPath, provider.path.relative( linkPath, linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.found, [ linkPath, linkPath2, linkPath3, filePath ] )
  test.identical( o.result, [ linkPath, test.context.globalFromPreferred( '../link2' ), linkPath3, filePath ]  )

  // /* chain, resolvingHeadDirectories : [ 0, 1 ] */

  // test.case = 'two soft links in path';
  // provider.filesDelete( context.provider.path.dir( filePath ) );
  // provider.fileWrite( filePath, filePath );
  // provider.softLink( linkPath, '..' );
  // provider.softLink( linkPath2, '../file' );
  // var o = _.mapExtend( null, o1, { filePath : path.join( routinePath, 'link/link2' ), preservingRelative : 1, resolvingHeadDirectories : 0 } );
  // var got = provider.pathResolveLinkTailChain( o );
  // var expectedFound =
  // [
  //   path.join( routinePath, 'link/link2' ),
  //   '../file',
  //   path.join( routinePath, 'link/file' ),
  // ]
  // var expectedResult =
  // [
  //   path.join( routinePath, 'link/link2' ),
  //   path.join( routinePath, 'link/file' ),
  // ]
  // test.identical( o.result, expectedResult );
  // test.identical( o.found, expectedFound );

  // //

  // test.case = 'two soft links in path';
  // provider.filesDelete( context.provider.path.dir( filePath ) );
  // provider.fileWrite( filePath, filePath );
  // provider.softLink( linkPath, '..' );
  // provider.softLink( linkPath2, '../file' );
  // var o = _.mapExtend( null, o1, { filePath : path.join( routinePath, 'link/link2' ), preservingRelative : 1, resolvingHeadDirectories : 1 } );
  // var got = provider.pathResolveLinkTailChain( o );
  // var expectedFound =
  // [
  //   path.join( routinePath, 'link/link2' ),
  //   path.join( routinePath, 'link' ),
  //   '..',
  //   routinePath,
  //   linkPath2,
  //   '../file',
  //   filePath,
  // ]
  // var expectedResult =
  // [
  //   path.join( routinePath, 'link/link2' ),
  //   path.join( routinePath, 'link' ),
  //   routinePath,
  //   linkPath2,
  //   filePath
  // ]
  // test.identical( o.result, expectedResult );
  // test.identical( o.found, expectedFound );

  // //

  // test.case = 'several absolute soft links in path';
  // var dirPath = context.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile, pathToFile );
  // provider.softLink( linkToDir1Path, dir1Path );
  // provider.softLink( linkToTerminalPath, dirPath2 );
  // provider.softLink( linkInDir2, pathToFile );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath, preservingRelative : 1, resolvingHeadDirectories : 0 } );
  // var got = provider.pathResolveLinkTailChain( o );
  // test.identical( o.result, [ routinePath, pathToFile ] )
  // test.identical( o.found, [ routinePath, pathToFile ] )

  // //

  // test.case = 'several absolute soft links in path';
  // var dirPath = context.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile, pathToFile );
  // provider.softLink( linkToDir1Path, dir1Path );
  // provider.softLink( linkToTerminalPath, dirPath2 );
  // provider.softLink( linkInDir2, pathToFile );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath, preservingRelative : 1, resolvingHeadDirectories : 1 } );
  // var got = provider.pathResolveLinkTailChain( o );
  // test.identical( o.result, [ routinePath, linkToDir1Path, dir1Path, linkToTerminalPath, dirPath2, linkInDir2, pathToFile ] )
  // test.identical( o.found, [ routinePath, linkToDir1Path, dir1Path, linkToTerminalPath, dirPath2, linkInDir2, pathToFile ] )

  // //

  // test.case = 'several relative soft links in path';
  // var dirPath = context.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile, pathToFile );
  // provider.softLink( linkToDir1Path, provider.path.relative( linkToDir1Path, dir1Path ) );
  // provider.softLink( linkToTerminalPath, provider.path.relative( linkToTerminalPath, dirPath2 ) );
  // provider.softLink( linkInDir2, provider.path.relative( linkInDir2, pathToFile ) );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath, preservingRelative : 1, resolvingHeadDirectories : 0 } );
  // var got = provider.pathResolveLinkTailChain( o );
  // test.identical( o.found, [ routinePath, '../../file', path.join( dirPath, 'linkToDir1/file'), null ] )
  // test.identical( o.result, [ routinePath, path.join( dirPath, 'linkToDir1/file'), null ] )

  // //

  // test.case = 'several relative soft links in path';
  // var dirPath = context.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile, pathToFile );
  // provider.softLink( linkToDir1Path, provider.path.relative( linkToDir1Path, dir1Path ) );
  // provider.softLink( linkToTerminalPath, provider.path.relative( linkToTerminalPath, dirPath2 ) );
  // provider.softLink( linkInDir2, provider.path.relative( linkInDir2, pathToFile ) );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath, preservingRelative : 1, resolvingHeadDirectories : 1 } );
  // var got = provider.pathResolveLinkTailChain( o );
  // test.identical( o.found, [ routinePath, linkToDir1Path, '../dir1', dir1Path, linkToTerminalPath, '../../dir2', dirPath2, linkInDir2, '../../file', pathToFile ] )
  // test.identical( o.result, [ routinePath, linkToDir1Path, dir1Path, linkToTerminalPath, dirPath2, linkInDir2, pathToFile ] )

  // //

  // test.case = 'several absolute text links in path';
  // var dirPath = context.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile, pathToFile );
  // provider.textLink( linkToDir1Path, dir1Path );
  // provider.textLink( linkToTerminalPath, dirPath2 );
  // provider.textLink( linkInDir2, pathToFile );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath, preservingRelative : 1, resolvingHeadDirectories : 1 } );
  // var got = provider.pathResolveLinkTailChain( o );
  // test.identical( o.result, [ routinePath, linkToDir1Path, dir1Path, linkToTerminalPath, dirPath2, linkInDir2, pathToFile ] )
  // test.identical( o.found, [ routinePath, linkToDir1Path, dir1Path, linkToTerminalPath, dirPath2, linkInDir2, pathToFile ] )

  // //

  // test.case = 'several absolute text links in path';
  // var dirPath = context.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile, pathToFile );
  // provider.textLink( linkToDir1Path, dir1Path );
  // provider.textLink( linkToTerminalPath, dirPath2 );
  // provider.textLink( linkInDir2, pathToFile );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath, preservingRelative : 1, resolvingHeadDirectories : 0 } );
  // var got = provider.pathResolveLinkTailChain( o );
  // test.identical( o.result, [ routinePath, null ] )
  // test.identical( o.found, [ routinePath, null ] )

  /* cycle, throwing : [ 0, 1 ], allowingMissed : [ 0, 1 ] */

  test.case = 'context cycle softLink, throwing on'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath, null ] );

  test.case = 'context cycle softLink, throwing on'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 0, allowingCycled : 0 } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );

  test.case = 'context cycle softLink, throwing off'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath, null ] );

  test.case = 'context cycle softLink, throwing off'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 0 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath, null ] );

  test.case = 'context cycle text, throwing on '
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath, 'link ' + '../link' );
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath, null ] );

  test.case = 'context cycle text, throwing on '
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath, 'link ' + '../link' );
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 0, allowingCycled : 0 } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );

  test.case = 'context cycle text, throwing off'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath, 'link ' + '../link' );
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath, null ] );

  test.case = 'context cycle text, throwing off'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath, 'link ' + '../link' );
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 0 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath, null ] );

  test.case = 'cycle softLink, throwing on'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath, null ] );

  test.case = 'cycle softLink, throwing on'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 0, allowingCycled : 0 } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );

  test.case = 'cycle softLink, throwing off'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath, null ] );

  test.case = 'cycle softLink, throwing off'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 0 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath, null ] );

  test.case = 'cycle text link, throwing on'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath, null ] );

  test.case = 'cycle text link, throwing on'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 0, allowingCycled : 0 } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );

  test.case = 'cycle text link, throwing off'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath, null ] );

  test.case = 'cycle text link, throwing off'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath, null ] );

  test.case = 'cycle soft text, throwing on'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath, null ] );

  test.case = 'cycle soft text, throwing on'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 0, allowingCycled : 0 } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );

  test.case = 'cycle soft text, throwing off'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath, null ] );

  test.case = 'cycle soft text, throwing off'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 0 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath, null ] );


  /* allowingMissed : 0 throwing : 1, preservingRelative : [ 0, 1 ] */

  o1.allowingMissed = 0;
  o1.throwing = 1;

  /* - */

  test.case = 'not existing file';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  var o = _.mapExtend( null, o1, { filePath } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ filePath, null ] )
  test.identical( o.found, [ filePath, null ] )

  test.case = 'existing file';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  var o = _.mapExtend( null, o1, { filePath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ filePath ] )
  test.identical( o.found, [ filePath ] )

  test.case = 'hardLink';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.hardLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath ] )
  test.identical( o.found, [ linkPath ] )

  test.case = 'softLink';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] )
  test.identical( o.found, [ linkPath, filePath ] )

  test.case = 'relative softLink';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, '../file' );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] )
  test.identical( o.found, [ linkPath, filePath ] )

  test.case = 'textLink';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] )
  test.identical( o.found, [ linkPath, filePath ] )

  test.case = 'softLink to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, filePath, null ] )
  test.identical( o.found, [ linkPath, filePath, null ] )

  test.case = 'relative softLink to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, filePath, null ] )
  test.identical( o.found, [ linkPath, filePath, null ] )

  test.case = 'relative softLink to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, test.context.globalFromPreferred( '../file' ), null ] )
  test.identical( o.found, [ linkPath, filePath, null ] )

  test.case = 'textLink to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.textLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, filePath, null ] )
  test.identical( o.found, [ linkPath, filePath, null ] )

  test.case = 'textLink to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.textLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, test.context.globalFromPreferred( '../file' ), null ] )
  test.identical( o.found, [ linkPath, filePath, null ] )

  test.case = 'double textLink to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.textLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, linkPath2, filePath, null ] )
  test.identical( o.found, [ linkPath, linkPath2, filePath, null ] )

  test.case = 'double softLink to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, linkPath2, filePath, null ] )
  test.identical( o.found, [ linkPath, linkPath2, filePath, null ] )

  test.case = 'soft to text to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.textLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, linkPath2, filePath, null ] )
  test.identical( o.found, [ linkPath, linkPath2, filePath, null ] )

  test.case = 'text to soft to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, linkPath2, filePath, null ] )
  test.identical( o.found, [ linkPath, linkPath2, filePath, null ] )

  /* allowingMissed : 0 throwing : 0, preservingRelative : [ 0, 1 ] */

  o1.allowingMissed = 0;
  o1.throwing = 0;

  /* - */

  test.case = 'not existing file';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  var o = _.mapExtend( null, o1, { filePath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ filePath, null ] )
  test.identical( o.found, [ filePath, null ] )

  test.case = 'existing file';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  var o = _.mapExtend( null, o1, { filePath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ filePath ] )
  test.identical( o.found, [ filePath ] )

  test.case = 'hardLink';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.hardLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath ] )
  test.identical( o.found, [ linkPath ] )

  test.case = 'softLink';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] )
  test.identical( o.found, [ linkPath, filePath ] )

  test.case = 'relative softLink';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, '../file' );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] )
  test.identical( o.found, [ linkPath, filePath ] )

  test.case = 'textLink';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] )
  test.identical( o.found, [ linkPath, filePath ] )

  test.case = 'softLink to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, filePath, null ] )
  test.identical( o.found, [ linkPath, filePath, null ] )

  test.case = 'relative softLink to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, filePath, null ] )
  test.identical( o.found, [ linkPath, filePath, null ] )

  test.case = 'relative softLink to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, test.context.globalFromPreferred( '../file' ), null ] )
  test.identical( o.found, [ linkPath, filePath, null ] )

  test.case = 'textLink to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.textLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, filePath, null ] )
  test.identical( o.found, [ linkPath, filePath, null ] )

  test.case = 'textLink to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.textLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, test.context.globalFromPreferred( '../file' ), null ] )
  test.identical( o.found, [ linkPath, filePath, null ] )

  test.case = 'double textLink to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.textLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, linkPath2, filePath, null ] )
  test.identical( o.found, [ linkPath, linkPath2, filePath, null ] )

  test.case = 'double softLink to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, linkPath2, filePath, null ] )
  test.identical( o.found, [ linkPath, linkPath2, filePath, null ] )

  test.case = 'soft to text to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.textLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, linkPath2, filePath, null ] )
  test.identical( o.found, [ linkPath, linkPath2, filePath, null ] )

  test.case = 'text to soft to missing';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, linkPath2, filePath, null ] )
  test.identical( o.found, [ linkPath, linkPath2, filePath, null ] )

  provider.fieldPop( 'usingTextLink', true );
}

//

function pathResolveLinkFull( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  /*
    qqq : cases with preservingRelative : 0 or resolvingHeadDirect : 0 are disabled,
    pathResolveLinkFull does not allow to disable these option for now
    Vova : low priority
  */

  let routinePath = test.context.pathFor( 'written/pathResolveLinkFull' );
  let filePath = test.context.pathFor( 'written/pathResolveLinkFull/file' );
  let linkPath = test.context.pathFor( 'written/pathResolveLinkFull/link' );
  let linkPath2 = test.context.pathFor( 'written/pathResolveLinkFull/link2' );
  let linkPath3 = test.context.pathFor( 'written/pathResolveLinkFull/link3' );
  let terminalInDirPath = provider.path.join( routinePath, 'terminal' );
  let toDirPath = path.join( routinePath, 'toDir' );

  provider.fieldPush( 'usingTextLink', true );

  /* - */

  test.open( 'critical' );

  var tree =
  {
    directory :
    {
      terminal : 'terminal',
    },
    toDir : [ { softLink : '/directory' } ],
  }

  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.softLink( toDirPath, routinePath );

  var o2 =
  {
    filePath : path.join( toDirPath, 'terminal' ),
    allowingMissed : 0,
    throwing : 0,
  }
  var got = provider.pathResolveLinkFull( o2 );
  test.identical( got.absolutePath, terminalInDirPath );

  test.close( 'critical' );

  /* - */

  test.case = 'not existing file';
  provider.filesDelete( path.dir( filePath ) );

  var got = provider.pathResolveLinkFull
  ({
    filePath,
    allowingMissed : 0,
    throwing : 0,
  });
  test.identical( got.absolutePath, null );
  test.identical( got.filePath, null );
  test.identical( got.relativePath, null );

  var got = provider.pathResolveLinkFull
  ({
    filePath,
    allowingMissed : 1,
    throwing : 0,
  });
  test.identical( got.absolutePath, filePath );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath,
      allowingMissed : 0,
      throwing : 1,
    });
  })

  var got = provider.pathResolveLinkFull
  ({
    filePath,
    allowingMissed : 1,
    throwing : 1,
  });
  test.identical( got.absolutePath, filePath );

  // var got = provider.pathResolveLinkFull
  // ({
  //   filePath,
  //   allowingMissed : 0,
  //   resolvingHeadDirect : 0,
  //   resolvingHeadReverse : 0,
  //   resolvingSoftLink : 1,
  //   resolvingTextLink : 1,
  //   throwing : 0,
  // });
  // test.identical( got, null );

  var got = provider.pathResolveLinkFull
  ({
    filePath,
    allowingMissed : 0,
    resolvingHeadDirect : 1,
    resolvingHeadReverse : 1,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
  });
  test.identical( got.absolutePath, null );
  test.identical( got.filePath, null );
  test.identical( got.relativePath, null );

  // var got = provider.pathResolveLinkFull
  // ({
  //   filePath,
  //   allowingMissed : 0,
  //   resolvingHeadDirect : 1,
  //   resolvingHeadReverse : 0,
  //   resolvingSoftLink : 1,
  //   resolvingTextLink : 1,
  //   throwing : 0,
  // });
  // test.identical( got, null );

  // var got = provider.pathResolveLinkFull
  // ({
  //   filePath,
  //   allowingMissed : 0,
  //   resolvingHeadDirect : 0,
  //   resolvingHeadReverse : 1,
  //   resolvingSoftLink : 1,
  //   resolvingTextLink : 1,
  //   throwing : 0,
  // });
  // test.identical( got, null );

  var got = provider.pathResolveLinkFull
  ({
    filePath,
    allowingMissed : 1,
    resolvingHeadDirect : 1,
    resolvingHeadReverse : 1,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
  });
  test.identical( got.absolutePath, filePath );

  // var got = provider.pathResolveLinkFull
  // ({
  //   filePath,
  //   allowingMissed : 1,
  //   resolvingHeadDirect : 0,
  //   resolvingHeadReverse : 1,
  //   resolvingSoftLink : 1,
  //   resolvingTextLink : 1,
  //   throwing : 0,
  // });
  // test.identical( got, filePath );

  // var got = provider.pathResolveLinkFull
  // ({
  //   filePath,
  //   allowingMissed : 1,
  //   resolvingHeadDirect : 1,
  //   resolvingHeadReverse : 0,
  //   resolvingSoftLink : 1,
  //   resolvingTextLink : 1,
  //   throwing : 0,
  // });
  // test.identical( got, filePath );

  // var got = provider.pathResolveLinkFull
  // ({
  //   filePath,
  //   allowingMissed : 1,
  //   resolvingHeadDirect : 0,
  //   resolvingHeadReverse : 0,
  //   resolvingSoftLink : 1,
  //   resolvingTextLink : 1,
  //   throwing : 0,
  // });
  // test.identical( got, filePath );

  // test.shouldThrowErrorOfAnyKind( () =>
  // {
  //   provider.pathResolveLinkFull
  //   ({
  //     filePath,
  //     allowingMissed : 0,
  //     resolvingHeadDirect : 0,
  //     resolvingHeadReverse : 0,
  //     resolvingSoftLink : 1,
  //     resolvingTextLink : 1,
  //     throwing : 1,
  //   });
  // })

  // test.shouldThrowErrorOfAnyKind( () =>
  // {
  //   provider.pathResolveLinkFull
  //   ({
  //     filePath,
  //     allowingMissed : 0,
  //     resolvingHeadDirect : 1,
  //     resolvingHeadReverse : 0,
  //     resolvingSoftLink : 1,
  //     resolvingTextLink : 1,
  //     throwing : 1,
  //   });
  // })

  // test.shouldThrowErrorOfAnyKind( () =>
  // {
  //   provider.pathResolveLinkFull
  //   ({
  //     filePath,
  //     allowingMissed : 0,
  //     resolvingHeadDirect : 0,
  //     resolvingHeadReverse : 1,
  //     resolvingSoftLink : 1,
  //     resolvingTextLink : 1,
  //     throwing : 1,
  //   });
  // })

  // test.shouldThrowErrorOfAnyKind( () =>
  // {
  //   provider.pathResolveLinkFull
  //   ({
  //     filePath,
  //     allowingMissed : 0,
  //     resolvingHeadDirect : 0,
  //     resolvingHeadReverse : 0,
  //     resolvingSoftLink : 0,
  //     resolvingTextLink : 0,
  //     throwing : 1,
  //   });

  // })

  // var got = provider.pathResolveLinkFull
  // ({
  //   filePath,
  //   allowingMissed : 1,
  //   resolvingHeadDirect : 0,
  //   resolvingHeadReverse : 0,
  //   resolvingSoftLink : 0,
  //   resolvingTextLink : 0,
  //   throwing : 1,
  // });
  // test.identical( got, filePath )

  // var got = provider.pathResolveLinkFull
  // ({
  //   filePath,
  //   allowingMissed : 0,
  //   resolvingHeadDirect : 0,
  //   resolvingHeadReverse : 0,
  //   resolvingSoftLink : 0,
  //   resolvingTextLink : 0,
  //   throwing : 0,
  // });
  // test.identical( got, null );

  /* - */

  test.case = 'absolute softLink to missing'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePath,
    makingDirectory : 1,
    allowingMissed : 1
  });

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    allowingMissed : 0,
    throwing : 0,
  });
  test.identical( got.absolutePath, null );
  test.identical( got.filePath, null );
  test.identical( got.relativePath, null );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    allowingMissed : 1,
    throwing : 0,
  });
  test.identical( got.absolutePath, filePath );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : linkPath,
      allowingMissed : 0,
      throwing : 1,
    });
  })

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    allowingMissed : 1,
    throwing : 1,
  });
  test.identical( got.absolutePath, filePath );

  /* - */

  test.case = 'context cycle softLink'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    allowingCycled : 0,
    throwing : 0,
  });
  test.identical( got.absolutePath, null );
  test.identical( got.filePath, null );
  test.identical( got.relativePath, null );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    allowingCycled : 1,
    throwing : 0,
  });
  test.identical( got.absolutePath, linkPath );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : linkPath,
      allowingCycled : 0,
      throwing : 1,
    });
  })
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    allowingCycled : 1,
    throwing : 1,
  });
  test.identical( got.absolutePath, linkPath );

  /* - */

  test.case = 'cycle softLink'
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    allowingCycled : 0,
    throwing : 0,
  });
  test.identical( got.absolutePath, null );
  test.identical( got.relativePath, null );
  test.identical( got.filePath, null );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    allowingCycled : 1,
    throwing : 0,
  });
  test.identical( got.absolutePath, linkPath );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : linkPath,
      allowingCycled : 0,
      throwing : 1,
    });
  })
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    allowingCycled : 1,
    throwing : 1,
  });
  test.identical( got.absolutePath, linkPath );

  provider.fieldPop( 'usingTextLink', true );

  /* chain, resolvingHeadDirect : [ 0, 1 ], resolvingHeadReverse : 0 */

  var o1 =
  {
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    allowingMissed : 1,
    resolvingHeadDirect : 0,
    resolvingHeadReverse : 0,
    throwing : 1
  }

  // test.case = 'two soft links in path';
  // provider.filesDelete( context.provider.path.dir( filePath ) );
  // provider.fileWrite( filePath, filePath );
  // provider.softLink( linkPath, '..' );
  // provider.softLink( linkPath2, '../file' );
  // var o = _.mapExtend( null, o1, { filePath : path.join( routinePath, 'link/link2' ), preservingRelative : 1, resolvingHeadDirect : 0, resolvingHeadReverse : 0 } );
  // var got = provider.pathResolveLinkFull( o );
  // var expected = path.join( routinePath, 'link/file' );
  // test.identical( got, expected )

  /* - */

  // test.case = 'two soft links in path';
  // provider.filesDelete( context.provider.path.dir( filePath ) );
  // provider.fileWrite( filePath, filePath );
  // provider.softLink( linkPath, '..' );
  // provider.softLink( linkPath2, '../file' );
  // var o = _.mapExtend( null, o1, { filePath : path.join( routinePath, 'link/link2' ), preservingRelative : 1, resolvingHeadDirect : 0, resolvingHeadReverse : 1 } );
  // var got = provider.pathResolveLinkFull( o );
  // var expected = filePath;
  // test.identical( got, expected );

  /* - */

  // test.case = 'several absolute soft links in path';
  // var dirPath = context.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile, pathToFile );
  // provider.softLink( linkToDir1Path, dir1Path );
  // provider.softLink( linkToTerminalPath, dirPath2 );
  // provider.softLink( linkInDir2, pathToFile );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath, preservingRelative : 1, resolvingHeadDirect : 0, resolvingHeadReverse : 0 } );
  // var got = provider.pathResolveLinkFull( o );
  // test.identical( got, path.join( dirPath, pathToFile ) );

  /* - */

  // test.case = 'several absolute soft links in path';
  // var dirPath = context.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile, pathToFile );
  // provider.softLink( linkToDir1Path, dir1Path );
  // provider.softLink( linkToTerminalPath, dirPath2 );
  // provider.softLink( linkInDir2, pathToFile );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath, preservingRelative : 1, resolvingHeadDirect : 0, resolvingHeadReverse : 1 } );
  // var got = provider.pathResolveLinkFull( o );
  // test.identical( got, pathToFile );

  /* - */

  // test.case = 'several relative soft links in path';
  // var dirPath = context.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile, pathToFile );
  // provider.softLink( linkToDir1Path, provider.path.relative( linkToDir1Path, dir1Path ) );
  // provider.softLink( linkToTerminalPath, provider.path.relative( linkToTerminalPath, dirPath2 ) );
  // provider.softLink( linkInDir2, provider.path.relative( linkInDir2, pathToFile ) );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath, preservingRelative : 1, resolvingHeadDirect : 0, resolvingHeadReverse : 0 } );
  // var got = provider.pathResolveLinkFull( o );
  // var expected = path.join( dirPath, 'linkToDir1/file' );
  // test.identical( got, expected );


  /* - */

  test.case = 'several relative soft links in path';
  var dirPath = context.provider.path.dir( filePath );
  var dir1Path = path.join( dirPath, 'dir1' );
  var dirPath2 = path.join( dirPath, 'dir2' );
  var pathToFile = path.join( dirPath, 'file' );
  var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  provider.filesDelete( dirPath );
  provider.dirMake( dirPath );
  provider.dirMake( dir1Path );
  provider.dirMake( dirPath2 );
  provider.fileWrite( pathToFile, pathToFile );
  provider.softLink( linkToDir1Path, provider.path.relative( linkToDir1Path, dir1Path ) );
  provider.softLink( linkToTerminalPath, provider.path.relative( linkToTerminalPath, dirPath2 ) );
  provider.softLink( linkInDir2, provider.path.relative( linkInDir2, pathToFile ) );

  /*
    dir :
      dir1 :
        linkToDir2
      dir2 :
        linkToTerminal
      linkToDir1
      file

    path : 'dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  */

  routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  var o2 = { filePath : routinePath, preservingRelative : 0, resolvingHeadDirect : 1, resolvingHeadReverse : 1 };
  var o = _.mapExtend( null, o1, o2 );
  var got = provider.pathResolveLinkFull( o );
  test.identical( got.absolutePath, pathToFile );

  /* - */

  test.case = 'several relative soft links in path';
  var dirPath = context.provider.path.dir( filePath );
  var dir1Path = path.join( dirPath, 'dir1' );
  var dirPath2 = path.join( dirPath, 'dir2' );
  var pathToFile = path.join( dirPath, 'file' );
  var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  provider.filesDelete( dirPath );
  provider.dirMake( dirPath );
  provider.dirMake( dir1Path );
  provider.dirMake( dirPath2 );
  provider.fileWrite( pathToFile, pathToFile );
  provider.softLink( linkToDir1Path, provider.path.relative( linkToDir1Path, dir1Path ) );
  provider.softLink( linkToTerminalPath, provider.path.relative( linkToTerminalPath, dirPath2 ) );
  provider.softLink( linkInDir2, provider.path.relative( linkInDir2, pathToFile ) );

  /*
    dir :
      dir1 :
        linkToDir2
      dir2 :
        linkToTerminal
      linkToDir1
      file

    path : 'dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  */

  routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  var o2 = { filePath : routinePath, preservingRelative : 1, resolvingHeadDirect : 1, resolvingHeadReverse : 1 };
  var o = _.mapExtend( null, o1, o2 );
  var got = provider.pathResolveLinkFull( o );
  var expected = provider.path.relative( linkInDir2, pathToFile );
  test.identical( got.filePath, expected );

  /* - */

  // test.case = 'several absolute text links in path';
  // var dirPath = context.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile, pathToFile );
  // provider.textLink( linkToDir1Path, dir1Path );
  // provider.textLink( linkToTerminalPath, dirPath2 );
  // provider.textLink( linkInDir2, pathToFile );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath, preservingRelative : 1, resolvingHeadDirect : 1, resolvingHeadReverse : 0 } );
  // var got = provider.pathResolveLinkFull( o );
  // test.identical( got, routinePath );

  /* - */

  // test.case = 'several absolute text links in path';
  // var dirPath = context.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile, pathToFile );
  // provider.textLink( linkToDir1Path, dir1Path );
  // provider.textLink( linkToTerminalPath, dirPath2 );
  // provider.textLink( linkInDir2, pathToFile );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath, preservingRelative : 1, resolvingHeadDirect : 0, resolvingHeadReverse : 1 } );
  // var got = provider.pathResolveLinkFull( o );
  // test.identical( got, pathToFile );

}

//

function pathResolveLinkFullRecursive( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/pathResolveLinkFullRecursive' );
  let filePath = test.context.pathFor( 'written/pathResolveLinkFullRecursive/file' );
  let linkPath = test.context.pathFor( 'written/pathResolveLinkFullRecursive/link1' );
  let linkPath2 = test.context.pathFor( 'written/pathResolveLinkFullRecursive/link2' );
  let linkPath3 = test.context.pathFor( 'written/pathResolveLinkFullRecursive/link3' );

  /*
    - missing
    - terminal
    - link to missing file
    - link to existing file
    - chain of three links to missing
    - chain of three links to file
    - cycled links
  */

  test.open( 'missing' );
  provider.filesDelete( routinePath );

  var got = provider.pathResolveLinkFull
  ({
    filePath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 0
  })
  test.identical( got.absolutePath, filePath );

  var got = provider.pathResolveLinkFull
  ({
    filePath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 1
  })
  test.identical( got.absolutePath, filePath );

  var got = provider.pathResolveLinkFull
  ({
    filePath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 2
  })
  test.identical( got.absolutePath, filePath );

  var got = provider.pathResolveLinkFull
  ({
    filePath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 3
  })
  test.identical( got.absolutePath, filePath );

  test.close( 'missing' );

  /* - */

  test.open( 'terminal' )
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );

  var got = provider.pathResolveLinkFull
  ({
    filePath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 0
  })
  test.identical( got.absolutePath, filePath );

  var got = provider.pathResolveLinkFull
  ({
    filePath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 1
  })
  test.identical( got.absolutePath, filePath );

  var got = provider.pathResolveLinkFull
  ({
    filePath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 2
  })
  test.identical( got.absolutePath, filePath );

  var got = provider.pathResolveLinkFull
  ({
    filePath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 3
  })
  test.identical( got.absolutePath, filePath );

  test.close( 'terminal' )

  /*  */

  test.open( 'link to missing' )
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath )
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1 });

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 0
  })
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 1
  })
  test.identical( got.absolutePath, filePath );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 2
  })
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 3
  })
  test.identical( got.absolutePath, filePath );

  test.close( 'link to missing' )

  /* - */

  test.open( 'link to terminal' )
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, filePath );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 0
  })
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 1
  })
  test.identical( got.absolutePath, filePath );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 2
  })
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 3
  })
  test.identical( got.absolutePath, filePath );

  test.close( 'link to terminal' )

  /* - */

  test.open( 'chain of three links to missing' );
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : linkPath3, srcPath : filePath, allowingMissed : 1 });
  provider.softLink( linkPath2, linkPath3 );
  provider.softLink( linkPath, linkPath2 );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 0
  })
  test.identical( got.absolutePath, linkPath );

  debugger
  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 1
  })
  test.identical( got.absolutePath, linkPath2 );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 2
  })
  test.identical( got.absolutePath, linkPath3 );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 3
  })
  test.identical( got.absolutePath, filePath );

  test.close( 'chain of three links to missing' );

  /* - */

  test.open( 'chain of three links to terminal' );
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath3, filePath );
  provider.softLink( linkPath2, linkPath3 );
  provider.softLink( linkPath, linkPath2 );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 0
  })
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 1
  })
  test.identical( got.absolutePath, linkPath2 );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 2
  })
  test.identical( got.absolutePath, linkPath3 );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 3
  })
  test.identical( got.absolutePath, filePath );

  test.close( 'chain of three links to terminal' );

  /* - */

  test.open( 'cycled links' );
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : linkPath3, srcPath : linkPath, allowingMissed : 1 });
  provider.softLink( linkPath2, linkPath3 );
  provider.softLink( linkPath, linkPath2 );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 0
  })
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 1
  })
  test.identical( got.absolutePath, linkPath2 );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 2
  })
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkFull
  ({
    filePath : linkPath,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    recursive : 3
  })
  test.identical( got.absolutePath, linkPath );

  test.close( 'cycled links' );
}

//

function pathResolveSoftLink( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/pathResolveSoftLink' );
  let filePath = test.context.pathFor( 'written/pathResolveSoftLink/file' );
  let linkPath = test.context.pathFor( 'written/pathResolveSoftLink/link' );
  let linkPath2 = test.context.pathFor( 'written/pathResolveSoftLink/link2' );
  let linkPath3 = test.context.pathFor( 'written/pathResolveSoftLink/link3' );
  let dirPath = test.context.pathFor( 'written/pathResolveSoftLink/dir' );
  let terminalInDirPath = test.context.pathFor( 'written/pathResolveSoftLink/dir/terminal' );
  let testData = 'pathResolveSoftLink';

  var o1 =
  {
  };

  test.case = 'not existing file';
  provider.filesDelete( routinePath );
  var o = _.mapExtend( null, o1, { filePath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, filePath );

  test.case = 'existing regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  var o = _.mapExtend( null, o1, { filePath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, filePath );

  test.case = 'hardlink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.hardLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, linkPath );

  // textLinks

  test.case = 'textlink';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, linkPath );

  test.case = 'textlink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath };
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, linkPath );

  test.case = 'absolute textlink to file that does not exist';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, linkPath );

  test.case = 'relative textlink to file that does not exist';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : '../file2', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, linkPath );

  // softLinks

  test.case = 'absolute softlink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, filePath );

  test.case = 'relative softlink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink( linkPath, '../file' );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, test.context.globalFromPreferred( '../file' ) );

  test.case = 'absolute softlink to missing'
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePath,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, filePath );

  test.case = 'relative softlink to missing'
  provider.filesDelete( routinePath );
  var filePathRelative = provider.path.relative( linkPath, filePath );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePathRelative,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, filePathRelative );

  // Chains of links

  test.case = 'Chain with two absolute soft links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveSoftLink( { filePath : linkPath } );
  test.identical( got, linkPath2 );
  var got1 = provider.pathResolveSoftLink( { filePath : got } );
  test.identical( got1, filePath );
  var got2 = provider.pathResolveSoftLink( { filePath : got1 } );
  test.identical( got2, filePath );

  test.case = 'Chain with relative and absolute soft links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : '../file' });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveSoftLink( { filePath : linkPath } );
  test.identical( got, linkPath2 );
  var got1 = provider.pathResolveSoftLink( { filePath : got } );
  test.identical( got1, test.context.globalFromPreferred( '../file' ) );
  var got2 = provider.path.resolve( linkPath2, got1 );
  test.identical( got2, filePath );

  test.case = 'Chain with absolute and relative soft link that doesnt exist';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : '../file0', allowingMissed : 1, makingDirectory : 1  });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2  });
  var got = provider.pathResolveSoftLink( { filePath : linkPath } );
  test.identical( got, linkPath2 );
  var got1 = provider.pathResolveSoftLink( { filePath : got } );
  test.identical( got1, test.context.globalFromPreferred( '../file0' ) );
  var got2 = provider.path.resolve( linkPath2, got1 );
  test.identical( got2, filePath + '0' );

  test.case = 'Chain with two absolute text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : filePath });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveSoftLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with relative and absolute text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : '../file' });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveSoftLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with absolute and relative text link that doesnt exist';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : '../file0', allowingMissed : 1, makingDirectory : 1  });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2  });
  var got = provider.pathResolveSoftLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with absolute soft and text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath, srcPath : filePath });
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveSoftLink( { filePath : linkPath2 } );
  test.identical( got, linkPath );

  test.case = 'Chain with relative soft and text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveSoftLink( { filePath : linkPath2 } );
  test.identical( got, linkPath );

  /* resolvingMultiple */

  test.case = 'single soft link';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath, resolvingMultiple : 1 } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, filePath );

  test.case = 'double soft link';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink( linkPath2, filePath );
  provider.softLink( linkPath, linkPath2 );
  var o = _.mapExtend( null, o1, { filePath : linkPath, resolvingMultiple : 3 } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, filePath );

  test.case = 'Chain with two softlink and text link to missing file';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath });
  provider.softLink({ dstPath : linkPath3, srcPath : linkPath2 });
  var got = provider.pathResolveSoftLink( { filePath : linkPath3, resolvingMultiple : 3 } );
  test.identical( got, linkPath );

  test.case = 'Chain with two softlink, last link is broken';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveSoftLink( { filePath : linkPath2, resolvingMultiple : 3 } );
  test.identical( got, filePath );

  test.case = 'Chain with two textlinks';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveSoftLink( { filePath : linkPath2, resolvingMultiple : 3 } );
  test.identical( got, linkPath2 );

  test.case = 'Chain with two relative softLinks';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath2, srcPath : '../link' });
  var got = provider.pathResolveSoftLink( { filePath : linkPath2, resolvingMultiple : 3 } );
  test.identical( got, test.context.globalFromPreferred( '../file' ) );

  test.case = 'Chain with relative and absolute softLinks';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath });
  provider.softLink({ dstPath : linkPath3, srcPath : '../link2' });
  var got = provider.pathResolveSoftLink( { filePath : linkPath3, resolvingMultiple : 3 } );
  test.identical( got, test.context.globalFromPreferred( '../file' ) );

  /* resolvingIntermediateDirectories */

  test.case = 'two soft links in path';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, '..' );
  provider.softLink( linkPath2, test.context.globalFromPreferred( '../file' ) );
  var pathToResolve = provider.path.join( routinePath, 'link/link2' )
  var o = _.mapExtend( null, o1, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 1 } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, filePath );

  test.case = 'intermediate absolute soft link to other directory';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.softLink( linkPath, dirPath );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, o1, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 1 } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, terminalInDirPath );

  test.case = 'intermediate absolute soft link to other directory';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.softLink( linkPath, dirPath );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, o1, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 3 } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, terminalInDirPath );

  test.case = 'intermediate chain of soft links to other directory, resolvingMultiple off';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, linkPath2 );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, o1, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 1 } );
  var got = provider.pathResolveSoftLink( o );
  var expected = provider.path.join( linkPath2, 'terminal' );
  test.identical( got, expected );

  test.case = 'intermediate chain of soft links to other directory, resolvingMultiple on';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, linkPath2 );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, o1, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 3 } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, terminalInDirPath );

  test.case = 'intermediate chain of relative soft links to other directory, resolvingMultiple on';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.softLink( linkPath2, '../dir' );
  provider.softLink( linkPath, test.context.globalFromPreferred( '../link2' ) );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, o1, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 1 } );
  var got = provider.pathResolveSoftLink( o );
  var expected = provider.path.join( linkPath2, 'terminal' );
  test.identical( got, expected );

  test.case = 'intermediate chain of relative soft links to other directory, resolvingMultiple on';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.softLink( linkPath2, '../dir' );
  provider.softLink( linkPath, test.context.globalFromPreferred( '../link2' ) );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, o1, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 3 } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, terminalInDirPath );

  /* */

  if( !Config.debug )
  return;

  test.case = 'No object input';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : filePath } );
  test.mustNotThrowError( () => provider.pathResolveSoftLink( linkPath ) );

  test.case = 'No arguments';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveSoftLink( ) );

  test.case = 'Too many arguments';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveSoftLink( { filePath : linkPath }, { filePath : linkPath } ) );

  test.case = 'No filePath option';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveSoftLink( { otherPath : linkPath } ) );

  test.case = 'Wrong filePath options - undefined';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveSoftLink( { filePath : undefined } ) );

  test.case = 'Wrong filePath options - number';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveSoftLink( { filePath : 3.14159 } ) );

  test.case = 'Wrong filePath options - array';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveSoftLink( { filePath : [ 0, 'a' ] } ) );

  test.case = 'Wrong filePath options - null';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveSoftLink( { filePath : null } ) );

  test.case = 'Wrong filePath options - NaN';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveSoftLink( { filePath : NaN } ) );

}

//

function pathResolveSoftLinkExtended( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/pathResolveSoftLink' );
  let filePath = test.context.pathFor( 'written/pathResolveSoftLink/file' );
  let linkPath = test.context.pathFor( 'written/pathResolveSoftLink/link' );
  let linkPath2 = test.context.pathFor( 'written/pathResolveSoftLink/link2' );
  let linkPath3 = test.context.pathFor( 'written/pathResolveSoftLink/link3' );
  let dirPath = test.context.pathFor( 'written/pathResolveSoftLink/dir' );
  let terminalInDirPath = test.context.pathFor( 'written/pathResolveSoftLink/dir/terminal' );
  let testData = 'pathResolveSoftLink';

  /* implement options "throwing", "allowingMissed", "allowingCycled" for pathResolveSoftLink and pathResolveTextLink( not in Act ) */
  /* rename option resolvingMultiple to recursive and teach all routines to accept 3 values 0, 1, 2 */

  test.open( 'file path does not exist' );
  provider.filesDelete( routinePath );

  var got = provider.pathResolveSoftLink
  ({
    filePath,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 0
  });
  test.identical( got, null )

  var got = provider.pathResolveSoftLink
  ({
    filePath,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 0
  });
  test.identical( got, null )

  var got = provider.pathResolveSoftLink
  ({
    filePath,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 0
  });
  test.identical( got, null )

  /* - */

  var got = provider.pathResolveSoftLink
  ({
    filePath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 0
  });
  test.identical( got, filePath )

  var got = provider.pathResolveSoftLink
  ({
    filePath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 0
  });
  test.identical( got, filePath )

  var got = provider.pathResolveSoftLink
  ({
    filePath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 0
  });
  test.identical( got, filePath )

  /* - */

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveSoftLink
    ({
      filePath,
      allowingMissed : 0,
      allowingCycled : 1,
      resolvingMultiple : 1,
      throwing : 1
    });
  })

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveSoftLink
    ({
      filePath,
      allowingMissed : 0,
      allowingCycled : 1,
      resolvingMultiple : 2,
      throwing : 1
    });
  })

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveSoftLink
    ({
      filePath,
      allowingMissed : 0,
      allowingCycled : 1,
      resolvingMultiple : 3,
      throwing : 1
    });
  })

  /* - */

  var got = provider.pathResolveSoftLink
  ({
    filePath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, filePath );

  var got = provider.pathResolveSoftLink
  ({
    filePath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 1
  });
  test.identical( got, filePath );

  var got = provider.pathResolveSoftLink
  ({
    filePath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 1
  });
  test.identical( got, filePath );

  test.close( 'file path does not exist' );

  /* */

  /* */

  test.open( 'file path is not a text link' );

  provider.fileWrite( linkPath, linkPath );

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 0,
    throwing : 1
  });
  test.identical( got, linkPath )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, linkPath )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 1
  });
  test.identical( got, linkPath )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 1
  });
  test.identical( got, linkPath )

  test.close( 'file path is not a text link' );

  /* */

  test.open( 'soft link to missing' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1 })

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 0
  });
  test.identical( got, null )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 0
  });
  test.identical( got, null )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 0
  });
  test.identical( got, null )

  /* - */

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 0
  });
  test.identical( got, filePath )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 0
  });
  test.identical( got, filePath )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 0
  });
  test.identical( got, filePath )

  /* - */

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveSoftLink
    ({
      filePath : linkPath,
      allowingMissed : 0,
      allowingCycled : 1,
      resolvingMultiple : 1,
      throwing : 1
    });
  })

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveSoftLink
    ({
      filePath : linkPath,
      allowingMissed : 0,
      allowingCycled : 1,
      resolvingMultiple : 2,
      throwing : 1
    });
  })

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveSoftLink
    ({
      filePath : linkPath,
      allowingMissed : 0,
      allowingCycled : 1,
      resolvingMultiple : 3,
      throwing : 1
    });
  })

  /* - */

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, filePath )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 1
  });
  test.identical( got, filePath )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 1
  });
  test.identical( got, filePath )

  test.close( 'soft link to missing' );

  /*  */

  test.open( 'context cycled link' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1 })

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 0,
    resolvingMultiple : 1,
    throwing : 0
  });
  test.identical( got, null )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 0,
    resolvingMultiple : 2,
    throwing : 0
  });
  test.identical( got, null )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 0,
    resolvingMultiple : 3,
    throwing : 0
  });
  test.identical( got, null )

  /* - */

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 0
  });
  test.identical( got, test.context.globalFromPreferred( '../link' ) )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 0
  });
  test.identical( got, linkPath )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 0
  });
  test.identical( got, linkPath )

  /* - */

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveSoftLink
    ({
      filePath : linkPath,
      allowingMissed : 1,
      allowingCycled : 0,
      resolvingMultiple : 1,
      throwing : 1
    });
  })

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveSoftLink
    ({
      filePath : linkPath,
      allowingMissed : 1,
      allowingCycled : 0,
      resolvingMultiple : 2,
      throwing : 1
    });
  })

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveSoftLink
    ({
      filePath : linkPath,
      allowingMissed : 1,
      allowingCycled : 0,
      resolvingMultiple : 3,
      throwing : 1
    });
  })

  /* - */

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link' ) )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 1
  });
  test.identical( got, linkPath )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 1
  });
  test.identical( got, linkPath )

  test.close( 'context cycled link' );

  /*  */

  test.open( 'option recursive' );

  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath })
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath })
  provider.softLink({ dstPath : linkPath3, srcPath : linkPath2 })

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 0,
    throwing : 1
  });
  test.identical( got, linkPath3 )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, linkPath2 )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 1
  });
  test.identical( got, linkPath )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 1
  });
  test.identical( got, filePath )

  test.close( 'option recursive' );

  /* */

  test.open( 'cycled links' );

  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath2, srcPath : '../link3', allowingMissed : 1, allowingCycled : 1 })
  provider.softLink({ dstPath : linkPath3, srcPath : '../link2', allowingMissed : 1, allowingCycled : 1 })

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 0,
    throwing : 1
  });
  test.identical( got, linkPath3 )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link2' ) )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 0,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link2' ) )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link2' ) )

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveSoftLink
    ({
      filePath : linkPath3,
      allowingMissed : 1,
      allowingCycled : 0,
      resolvingMultiple : 2,
      throwing : 1
    });
  })

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 0,
    resolvingMultiple : 2,
    throwing : 0
  });
  test.identical( got, null )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link2' ) )

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveSoftLink
    ({
      filePath : linkPath3,
      allowingMissed : 1,
      allowingCycled : 0,
      resolvingMultiple : 3,
      throwing : 1
    });
  })

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 0,
    resolvingMultiple : 3,
    throwing : 0
  });
  test.identical( got, null )

  test.close( 'cycled links' );

  /* */

  test.open( 'relative links, option recursive' );

  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../file' })
  provider.softLink({ dstPath : linkPath2, srcPath : '../link' })
  provider.softLink({ dstPath : linkPath3, srcPath : '../link2' })

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 0,
    throwing : 1
  });
  test.identical( got, linkPath3 )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link2' ) )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link' ) )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../file' ) )

  test.close( 'relative links, option recursive' );

  /*  */

  test.open( 'chain of relative links to missing' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1 })
  provider.softLink({ dstPath : linkPath2, srcPath : '../link' })
  provider.softLink({ dstPath : linkPath3, srcPath : '../link2' })

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 0,
    throwing : 1
  });
  test.identical( got, linkPath3 )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link2' ) )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link2' ) )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../file' ) )

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveSoftLink
    ({
      filePath : linkPath3,
      allowingMissed : 0,
      allowingCycled : 1,
      resolvingMultiple : 2,
      throwing : 1
    });
  })

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 0
  });
  test.identical( got, null )

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../file' ) )

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveSoftLink
    ({
      filePath : linkPath3,
      allowingMissed : 0,
      allowingCycled : 1,
      resolvingMultiple : 3,
      throwing : 1
    });
  })

  var got = provider.pathResolveSoftLink
  ({
    filePath : linkPath3,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 0
  });
  test.identical( got, null )

  test.close( 'chain of relative links to missing' );
}

//

function pathResolveTextLink( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/pathResolveSoftLink' );
  let filePath = test.context.pathFor( 'written/pathResolveSoftLink/file' );
  let linkPath = test.context.pathFor( 'written/pathResolveSoftLink/link' );
  let linkPath2 = test.context.pathFor( 'written/pathResolveSoftLink/link2' );
  let linkPath3 = test.context.pathFor( 'written/pathResolveSoftLink/link3' );
  let dirPath = test.context.pathFor( 'written/pathResolveSoftLink/dir' );
  let terminalInDirPath = test.context.pathFor( 'written/pathResolveSoftLink/dir/terminal' );
  let testData = 'pathResolveTextLink';

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  var o = { filePath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, filePath );

  test.case = 'hardLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'absolute softLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'absolute textLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, filePath );

  test.case = 'file with jsdoc link tag'
  var jsdocData = '@link module:Tools/base/Proto.wTools.define.own'
  provider.filesDelete( routinePath );
  provider.fileWrite( linkPath, jsdocData );
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'file with jsdoc link tag'
  var jsdocData = '/**\n  @link module:Tools/base/Proto.wTools.define.own\n*/'
  provider.filesDelete( routinePath );
  provider.fileWrite( linkPath, jsdocData );
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'line on second line'
  var jsdocData = '\nlink ' + filePath;
  provider.filesDelete( routinePath );
  provider.fileWrite( linkPath, jsdocData );
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  /*

    Add test cases :

    absolute textLink to file that does not exist
    relative textLink to file that does not exist
    relative textLink to regular file

    use allowingMissed : 1 option to create link for missing file
  */

  test.case = 'absolute textLink to file that does not exist';
  provider.filesDelete( routinePath );  // remove temp files created by previous test case
  provider.textLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1  });
  var o = { filePath : linkPath }; // create options map for current test case
  var got = provider.pathResolveTextLink( o ); // call routine and save result
  test.identical( got, filePath ); // check result

  test.case = 'relative textLink to file that does not exist';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : '../file2', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, test.context.globalFromPreferred( '../file2' ) );

  test.case = 'relative textLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath, srcPath : '../file' });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, test.context.globalFromPreferred( '../file' ) );

  test.case = 'absolute softLink to file that does not exist';
  provider.filesDelete( routinePath );  // remove temp files created by previous test case
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 }); // prepare link for test case
  var o = { filePath : linkPath }; // create options map for current test case
  var got = provider.pathResolveTextLink( o ); // call routine and save result
  test.identical( got, linkPath ); // check result

  test.case = 'relative softLink to file that does not exist';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../file2', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'relative softLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : '../file' });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'Chain with two absolute text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : filePath });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath2 );
  var got1 = provider.pathResolveTextLink( { filePath : got } );
  test.identical( got1, filePath );
  var got2 = provider.pathResolveTextLink( { filePath : got1 } );
  test.identical( got2, filePath );

  test.case = 'Chain with relative and absolute text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : '../file' });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath2 );
  var got1 = provider.pathResolveTextLink( { filePath : got } );
  test.identical( got1, test.context.globalFromPreferred( '../file' ) );
  var got2 = provider.path.resolve( linkPath2, got1 );
  test.identical( got2, filePath );

  test.case = 'Chain with absolute and relative text link that doesnt exist';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : '../file0', allowingMissed : 1, makingDirectory : 1  });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2  });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath2 );
  var got1 = provider.pathResolveTextLink( { filePath : got } );
  test.identical( got1, test.context.globalFromPreferred( '../file0' ) );
  var got2 = provider.path.resolve( linkPath2, got1 );
  test.identical( got2, filePath + '0' );

  test.case = 'Chain with two absolute soft links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with relative and absolute soft links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : '../file' });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with absolute and relative soft link that doesnt exist';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : '../file0', allowingMissed : 1, makingDirectory : 1  });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2  });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with absolute soft and text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  provider.textLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveTextLink( { filePath : linkPath2 } );
  test.identical( got, linkPath );

  test.case = 'Chain with relative soft and text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveTextLink( { filePath : linkPath2 } );
  test.identical( got, linkPath );

  provider.fieldPop( 'usingTextLink', 1 );

  /**/

  provider.fieldPush( 'usingTextLink', 0 );

  test.case = 'regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  var o = { filePath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, filePath );

  test.case = 'hardLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'absolute softLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'absolute textLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'absolute textLink to file that does not exist';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1  });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'relative textLink to file that does not exist';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : '../file2', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'relative textLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath, srcPath : '../file' });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'absolute softLink to file that does not exist';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 }); // prepare link for test case
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'relative softLink to file that does not exist';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../file2', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'relative softLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : '../file' });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'Chain with two absolute text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : filePath });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with relative and absolute text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : '../file' });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with absolute and relative text link that doesnt exist';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : '../file0', allowingMissed : 1, makingDirectory : 1  });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2  });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with two absolute soft links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with relative and absolute soft links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : '../file' });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with absolute and relative soft link that doesnt exist';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : '../file0', allowingMissed : 1, makingDirectory : 1  });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2  });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with absolute soft and text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  provider.textLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveTextLink( { filePath : linkPath2 } );
  test.identical( got, linkPath2 );

  test.case = 'Chain with relative soft and text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveTextLink( { filePath : linkPath2 } );
  test.identical( got, linkPath2 );

  provider.fieldPop( 'usingTextLink', 0 );


  provider.fieldPush( 'usingTextLink', 1 );

  /* resolvingMultiple */

  test.case = 'single text link';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink( linkPath, filePath );
  var got = provider.pathResolveTextLink({ filePath : linkPath, resolvingMultiple : 1 });
  test.identical( got, filePath );

  test.case = 'double text link';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink( linkPath2, filePath );
  provider.textLink( linkPath, linkPath2 );
  var got = provider.pathResolveTextLink({ filePath : linkPath, resolvingMultiple : 3 });
  test.identical( got, filePath );

  test.case = 'Chain with two textlinks and soft link to missing file';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath2, srcPath : linkPath });
  provider.textLink({ dstPath : linkPath3, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath3, resolvingMultiple : 3 } );
  test.identical( got, linkPath );

  test.case = 'Chain with two textlinks, last link is broken';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveTextLink( { filePath : linkPath2, resolvingMultiple : 3 } );
  test.identical( got, filePath );

  test.case = 'Chain with two softlinks';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveTextLink( { filePath : linkPath2, resolvingMultiple : 3 } );
  test.identical( got, linkPath2 );

  test.case = 'Chain with two relative textlinks';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath2, srcPath : '../link' });
  var got = provider.pathResolveTextLink( { filePath : linkPath2, resolvingMultiple : 3 } );
  test.identical( got, context.globalFromPreferred( '../file' ) );

  test.case = 'Chain with relative and absolute textlinks';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath2, srcPath : linkPath });
  provider.textLink({ dstPath : linkPath3, srcPath : '../link2' });
  var got = provider.pathResolveTextLink( { filePath : linkPath3, resolvingMultiple : 3 } );
  test.identical( got, context.globalFromPreferred( '../file' ) );

  /* resolvingIntermediateDirectories */

  test.case = 'two text links in path';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.textLink( linkPath, test.context.globalFromPreferred( '..' ) );
  provider.textLink( linkPath2, '../file' );
  var pathToResolve = provider.path.join( routinePath, 'link/link2' )
  var o = _.mapExtend( null, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 1 } );
  var got = provider.pathResolveTextLink( o );
  test.identical( got, filePath );

  test.case = 'intermediate absolute text link to other directory';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.textLink( linkPath, dirPath );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 1 } );
  var got = provider.pathResolveTextLink( o );
  test.identical( got, terminalInDirPath );

  test.case = 'intermediate absolute soft link to other directory';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.softLink( linkPath, dirPath );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 3 } );
  var got = provider.pathResolveTextLink( o );
  test.identical( got, pathToResolve );

  test.case = 'intermediate chain of text links to other directory, resolvingMultiple off';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.textLink( linkPath2, dirPath );
  provider.textLink( linkPath, linkPath2 );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 1 } );
  var got = provider.pathResolveTextLink( o );
  var expected = provider.path.join( linkPath2, 'terminal' );
  test.identical( got, expected );

  test.case = 'intermediate chain of text links to other directory, resolvingMultiple on';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.textLink( linkPath2, dirPath );
  provider.textLink( linkPath, linkPath2 );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 3 } );
  var got = provider.pathResolveTextLink( o );
  test.identical( got, terminalInDirPath );

  test.case = 'intermediate chain of relative text links to other directory, resolvingMultiple on';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.textLink( linkPath2, '../dir' );
  provider.textLink( linkPath, test.context.globalFromPreferred( '../link2' ) );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 1 } );
  var got = provider.pathResolveTextLink( o );
  var expected = provider.path.join( linkPath2, 'terminal' );
  test.identical( got, expected );

  test.case = 'intermediate chain of relative text links to other directory, resolvingMultiple on';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.textLink( linkPath2, '../dir' );
  provider.textLink( linkPath, test.context.globalFromPreferred( '../link2' ) );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 3 } );
  var got = provider.pathResolveTextLink( o );
  test.identical( got, terminalInDirPath );

  provider.fieldPop( 'usingTextLink', 1 );

  /* */

  if( !Config.debug )
  return;

  test.case = 'Expects object input';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath, srcPath : filePath });
  test.mustNotThrowError( () => provider.pathResolveTextLink( linkPath ) );

  test.case = 'No arguments';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveTextLink( ) );

  test.case = 'Too many arguments';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveTextLink( { filePath : linkPath },  { filePath : linkPath } ) );

  test.case = 'No filePath option';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveTextLink( { otherPath : linkPath } ) );

  test.case = 'Wrong filePath options - undefined';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveTextLink( { filePath : undefined } ) );

  test.case = 'Wrong filePath options - number';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveTextLink( { filePath : 3.14159 } ) );

  test.case = 'Wrong filePath options - array';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveTextLink( { filePath : [ 0, 'a' ] } ) );

  test.case = 'Wrong filePath options - null';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveTextLink( { filePath : null } ) );

  test.case = 'Wrong filePath options - NaN';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveTextLink( { filePath : NaN } ) );

}

//

function pathResolveTextLinkExtended( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/pathResolveTextLink' );
  let filePath = test.context.pathFor( 'written/pathResolveTextLink/file' );
  let linkPath = test.context.pathFor( 'written/pathResolveTextLink/link' );
  let linkPath2 = test.context.pathFor( 'written/pathResolveTextLink/link2' );
  let linkPath3 = test.context.pathFor( 'written/pathResolveTextLink/link3' );
  let dirPath = test.context.pathFor( 'written/pathResolveTextLink/dir' );
  let terminalInDirPath = test.context.pathFor( 'written/pathResolveTextLink/dir/terminal' );
  let testData = 'pathResolveTextLink';

  /* implement options "throwing", "allowingMissed", "allowingCycled" for pathResolveTextLink and pathResolveTextLink( not in Act ) */
  /* rename option resolvingMultiple to recursive and teach all routines to accept 3 values 0, 1, 2 */

  provider.fieldPush( 'usingTextLink', 1 );

  test.open( 'file path does not exist' );
  provider.filesDelete( routinePath );

  var got = provider.pathResolveTextLink
  ({
    filePath,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 0
  });
  test.identical( got, null )

  var got = provider.pathResolveTextLink
  ({
    filePath,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 0
  });
  test.identical( got, null )

  var got = provider.pathResolveTextLink
  ({
    filePath,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 0
  });
  test.identical( got, null )

  /* - */

  var got = provider.pathResolveTextLink
  ({
    filePath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 0
  });
  test.identical( got, filePath )

  var got = provider.pathResolveTextLink
  ({
    filePath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 0
  });
  test.identical( got, filePath )

  var got = provider.pathResolveTextLink
  ({
    filePath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 0
  });
  test.identical( got, filePath )

  /* - */

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveTextLink
    ({
      filePath,
      allowingMissed : 0,
      allowingCycled : 1,
      resolvingMultiple : 1,
      throwing : 1
    });
  })

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveTextLink
    ({
      filePath,
      allowingMissed : 0,
      allowingCycled : 1,
      resolvingMultiple : 2,
      throwing : 1
    });
  })

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveTextLink
    ({
      filePath,
      allowingMissed : 0,
      allowingCycled : 1,
      resolvingMultiple : 3,
      throwing : 1
    });
  })

  /* - */

  var got = provider.pathResolveTextLink
  ({
    filePath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, filePath );

  var got = provider.pathResolveTextLink
  ({
    filePath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 1
  });
  test.identical( got, filePath );

  var got = provider.pathResolveTextLink
  ({
    filePath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 1
  });
  test.identical( got, filePath );

  test.close( 'file path does not exist' );

  /* */

  test.open( 'file path is not a text link' );

  provider.fileWrite( linkPath, linkPath );

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 0,
    throwing : 1
  });
  test.identical( got, linkPath )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, linkPath )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 1
  });
  test.identical( got, linkPath )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 1
  });
  test.identical( got, linkPath )

  test.close( 'file path is not a text link' );

  /* */

  test.open( 'Text link to missing' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1 })

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 0
  });
  test.identical( got, null )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 0
  });
  test.identical( got, null )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 0
  });
  test.identical( got, null )

  /* - */

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 0
  });
  test.identical( got, filePath )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 0
  });
  test.identical( got, filePath )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 0
  });
  test.identical( got, filePath )

  /* - */

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveTextLink
    ({
      filePath : linkPath,
      allowingMissed : 0,
      allowingCycled : 1,
      resolvingMultiple : 1,
      throwing : 1
    });
  })

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveTextLink
    ({
      filePath : linkPath,
      allowingMissed : 0,
      allowingCycled : 1,
      resolvingMultiple : 2,
      throwing : 1
    });
  })

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveTextLink
    ({
      filePath : linkPath,
      allowingMissed : 0,
      allowingCycled : 1,
      resolvingMultiple : 3,
      throwing : 1
    });
  })

  /* - */

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, filePath )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 1
  });
  test.identical( got, filePath )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 1
  });
  test.identical( got, filePath )

  test.close( 'Text link to missing' );

  /*  */

  test.open( 'context cycled link' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1 })

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 0,
    resolvingMultiple : 1,
    throwing : 0
  });
  test.identical( got, null )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 0,
    resolvingMultiple : 2,
    throwing : 0
  });
  test.identical( got, null )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 0,
    resolvingMultiple : 3,
    throwing : 0
  });
  test.identical( got, null )

  /* - */

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 0
  });
  test.identical( got, test.context.globalFromPreferred( '../link' ) )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 0
  });
  test.identical( got, linkPath )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 0
  });
  test.identical( got, linkPath )

  /* - */

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveTextLink
    ({
      filePath : linkPath,
      allowingMissed : 1,
      allowingCycled : 0,
      resolvingMultiple : 1,
      throwing : 1
    });
  })

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveTextLink
    ({
      filePath : linkPath,
      allowingMissed : 1,
      allowingCycled : 0,
      resolvingMultiple : 2,
      throwing : 1
    });
  })

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveTextLink
    ({
      filePath : linkPath,
      allowingMissed : 1,
      allowingCycled : 0,
      resolvingMultiple : 3,
      throwing : 1
    });
  })

  /* - */

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link' ) )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 1
  });
  test.identical( got, linkPath )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 1
  });
  test.identical( got, linkPath )

  test.close( 'context cycled link' );

  /*  */

  test.open( 'option recursive' );

  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.textLink({ dstPath : linkPath, srcPath : filePath })
  provider.textLink({ dstPath : linkPath2, srcPath : linkPath })
  provider.textLink({ dstPath : linkPath3, srcPath : linkPath2 })

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 0,
    throwing : 1
  });
  test.identical( got, linkPath3 )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, linkPath2 )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 1
  });
  test.identical( got, linkPath )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 1
  });
  test.identical( got, filePath )

  test.close( 'option recursive' );

  /* */

  test.open( 'cycled links' );

  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ../link3' );
  provider.fileWrite( linkPath3, 'link ../link2' );

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 0,
    throwing : 1
  });
  test.identical( got, linkPath3 )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link2' ) )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 0,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link2' ) )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link2' ) )

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveTextLink
    ({
      filePath : linkPath3,
      allowingMissed : 1,
      allowingCycled : 0,
      resolvingMultiple : 2,
      throwing : 1
    });
  })

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 0,
    resolvingMultiple : 2,
    throwing : 0
  });
  test.identical( got, null )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link2' ) )

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveTextLink
    ({
      filePath : linkPath3,
      allowingMissed : 1,
      allowingCycled : 0,
      resolvingMultiple : 3,
      throwing : 1
    });
  })

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 0,
    resolvingMultiple : 3,
    throwing : 0
  });
  test.identical( got, null )

  test.close( 'cycled links' );

  /* */

  test.open( 'relative links, option recursive' );

  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.textLink({ dstPath : linkPath, srcPath : '../file' })
  provider.textLink({ dstPath : linkPath2, srcPath : '../link' })
  provider.textLink({ dstPath : linkPath3, srcPath : '../link2' })

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 0,
    throwing : 1
  });
  test.identical( got, linkPath3 )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link2' ) )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link' ) )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../file' ) )

  test.close( 'relative links, option recursive' );

  /*  */

  test.open( 'chain of relative links to missing' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1 })
  provider.textLink({ dstPath : linkPath2, srcPath : '../link' })
  provider.textLink({ dstPath : linkPath3, srcPath : '../link2' })

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 0,
    throwing : 1
  });
  test.identical( got, linkPath3 )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link2' ) )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 1,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../link2' ) )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../file' ) )

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveTextLink
    ({
      filePath : linkPath3,
      allowingMissed : 0,
      allowingCycled : 1,
      resolvingMultiple : 2,
      throwing : 1
    });
  })

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 2,
    throwing : 0
  });
  test.identical( got, null )

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 1
  });
  test.identical( got, test.context.globalFromPreferred( '../file' ) )

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveTextLink
    ({
      filePath : linkPath3,
      allowingMissed : 0,
      allowingCycled : 1,
      resolvingMultiple : 3,
      throwing : 1
    });
  })

  var got = provider.pathResolveTextLink
  ({
    filePath : linkPath3,
    allowingMissed : 0,
    allowingCycled : 1,
    resolvingMultiple : 3,
    throwing : 0
  });
  test.identical( got, null )

  test.close( 'chain of relative links to missing' );

  /* */

  provider.fieldPop( 'usingTextLink', 1 );

}

//

function pathResolveLinkFullSpecial( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/pathResolveLinkFull' );
  let filePath = test.context.pathFor( 'written/pathResolveLinkFull/file' );
  let linkPath = test.context.pathFor( 'written/pathResolveLinkFull/link' );
  let linkPath2 = test.context.pathFor( 'written/pathResolveLinkFull/link2' );
  let linkPath3 = test.context.pathFor( 'written/pathResolveLinkFull/link3' );
  let terminalInDirPath = provider.path.join( routinePath, 'terminal' );
  let toDirPath = path.join( routinePath, 'toDir' );

  provider.fieldPush( 'usingTextLink', 1 );

  var o1 =
  {
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    allowingMissed : 1,
    resolvingHeadDirect : 0,
    resolvingHeadReverse : 0,
    throwing : 1
  }

  /* - */

  test.case = 'two soft links in path';
  provider.filesDelete( context.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, '..' );
  provider.softLink( linkPath2, '../file' );
  var o2 =
  {
    filePath : path.join( routinePath, 'link/link2' ),
    preservingRelative : 1,
    resolvingHeadDirect : 1,
    resolvingHeadReverse : 1,
  }
  var o = _.mapExtend( null, o1, o2 );
  var got = provider.pathResolveLinkFull( o ).relativePath;
  var expected = test.context.globalFromPreferred( '../file' );
  test.identical( got, expected );

  /* - */

  test.case = 'cycled softLink, throwing on'
  provider.filesDelete( context.provider.path.dir( filePath ) );

  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });

  test.is( provider.isSoftLink( linkPath ) );
  test.is( provider.isSoftLink( linkPath2 ) );

  let files = provider.dirRead( routinePath );
  test.identical( files, [ 'link', 'link2' ] );

  var o =
  {
    filePath : linkPath,
    preservingRelative : 1,
    allowingCycled : 1,
    throwing : 1
  };
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath, null ] );

  /* - */

  test.case = 'several absolute soft links in path';
  var dirPath = context.provider.path.dir( filePath );
  var dir1Path = path.join( dirPath, 'dir1' );
  var dirPath2 = path.join( dirPath, 'dir2' );
  var pathToFile = path.join( dirPath, 'file' );
  var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  provider.filesDelete( dirPath );
  provider.dirMake( dirPath );
  provider.dirMake( dir1Path );
  provider.dirMake( dirPath2 );
  provider.fileWrite( pathToFile, pathToFile );
  provider.softLink( linkToDir1Path, dir1Path );
  provider.softLink( linkToTerminalPath, dirPath2 );
  provider.softLink( linkInDir2, pathToFile );

  /*
    dir :
      dir1 :
        linkToDir2
      dir2 :
        linkToTerminal
      linkToDir1
      file
    path : 'dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  */

  routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  var o2 =
  {
    filePath : routinePath,
    preservingRelative : 1,
    resolvingHeadDirect : 1,
    resolvingHeadReverse : 1,
  }
  var o = _.mapExtend( null, o1, o2 );
  debugger;
  var got = provider.pathResolveLinkFull( o );
  debugger;
  test.identical( got.absolutePath, pathToFile );

  /* - */

  test.case = 'several absolute text links in path';
  var dirPath = context.provider.path.dir( filePath );
  var dir1Path = path.join( dirPath, 'dir1' );
  var dirPath2 = path.join( dirPath, 'dir2' );
  var pathToFile = path.join( dirPath, 'file' );
  var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  provider.filesDelete( dirPath );
  provider.dirMake( dirPath );
  provider.dirMake( dir1Path );
  provider.dirMake( dirPath2 );
  provider.fileWrite( pathToFile, pathToFile );
  provider.textLink( linkToDir1Path, dir1Path );
  provider.textLink( linkToTerminalPath, dirPath2 );
  provider.textLink( linkInDir2, pathToFile );

  /*
    dir :
      dir1 :
        linkToDir2
      dir2 :
        linkToTerminal
      linkToDir1
      file
    path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  */

  routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  var o2 =
  {
    filePath : routinePath,
    preservingRelative : 1,
    resolvingHeadDirect : 1,
    resolvingHeadReverse : 1,
  }
  var o = _.mapExtend( null, o1, o2 );
  var got = provider.pathResolveLinkFull( o );
  test.is( !!provider.usingTextLink );
  test.identical( got.absolutePath, pathToFile );

  provider.fieldPop( 'usingTextLink', 1 );
}

//

function pathResolveLinkFullResult( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/pathResolveLinkFullResult' );
  let srcPath = test.context.pathFor( 'written/pathResolveLinkFullResult/file' );
  let src2Path = test.context.pathFor( 'written/pathResolveLinkFullResult/file2' );
  let dstPath = test.context.pathFor( 'written/pathResolveLinkFullResult/link' );

  var o =
  {
    resolvingHeadDirect : 1,
    resolvingHeadReverse : 1,
    preservingRelative : 0,
    relativeOriginalFile : 1,
    resolvingSoftLink : null,
    resolvingTextLink : null,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1
  }

  test.case = 'missing path';
  provider.filesDelete( routinePath );
  var o2 = { filePath : srcPath };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, srcPath );
  test.identical( got.absolutePath, srcPath );

  test.case = 'terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var o2 = { filePath : srcPath };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, srcPath );
  test.identical( got.absolutePath, srcPath );

  /* */

  test.open( 'soft links' );

  test.case = 'absolute soft link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPath, srcPath )
  var o2 = { filePath : dstPath };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, srcPath );
  test.identical( got.absolutePath, srcPath );

  test.case = 'relative soft link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPath, '../file' )
  var o2 = { filePath : dstPath };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.case = 'relative soft link to terminal, preservingRelative:1';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPath, '../file' )
  var o2 = { filePath : dstPath, preservingRelative : 1 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.case = 'relative soft link to terminal, preservingRelative:0';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPath, '../file' )
  var o2 = { filePath : dstPath, preservingRelative : 0 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.case = 'chain of absolute soft links'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( src2Path,  srcPath )
  provider.softLink( dstPath,  src2Path )
  var o2 = { filePath : dstPath };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, srcPath );
  test.identical( got.absolutePath, srcPath );

  test.case = 'chain of absolute soft links, preservingRelative:1'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( src2Path,  '../file' )
  provider.softLink( dstPath,  '../file2' )
  var o2 = { filePath : dstPath, preservingRelative : 1 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.case = 'chain of relative soft links, preservingRelative:0'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( src2Path,  '../file' )
  provider.softLink( dstPath,  '../file2' )
  var o2 = { filePath : dstPath, preservingRelative : 0 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.close( 'soft links' );

  /* */

  test.open( 'text links' );

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'absolute text link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( dstPath, srcPath )
  var o2 = { filePath : dstPath, resolvingTextLink : 1 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, srcPath );
  test.identical( got.absolutePath, srcPath );

  test.case = 'relative soft link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( dstPath,  test.context.globalFromPreferred( '../file' ) );
  var o2 = { filePath : dstPath, resolvingTextLink : 1 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.case = 'relative soft link to terminal, preservingRelative:1';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( dstPath,  test.context.globalFromPreferred( '../file' ) );
  var o2 = { filePath : dstPath, resolvingTextLink : 1, preservingRelative : 1 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.case = 'relative soft link to terminal, preservingRelative:0';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( dstPath,  test.context.globalFromPreferred( '../file' ) );
  var o2 = { filePath : dstPath, resolvingTextLink : 1, preservingRelative : 0 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.case = 'chain of absolute soft links'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( src2Path,  srcPath )
  provider.textLink( dstPath,  src2Path )
  var o2 = { filePath : dstPath, resolvingTextLink : 1 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, srcPath );
  test.identical( got.absolutePath, srcPath );

  test.case = 'chain of absolute soft links, preservingRelative:1'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( src2Path,  test.context.globalFromPreferred( '../file' ) );
  provider.textLink( dstPath,  test.context.globalFromPreferred( '../file2' ) );
  var o2 = { filePath : dstPath, resolvingTextLink : 1, preservingRelative : 1 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.case = 'chain of relative soft links, preservingRelative:0'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( src2Path,  test.context.globalFromPreferred( '../file' ) );
  provider.textLink( dstPath,  test.context.globalFromPreferred( '../file2' ) );
  var o2 = { filePath : dstPath, resolvingTextLink : 1, preservingRelative : 0 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  provider.fieldPop( 'usingTextLink', 1 );

  test.close( 'text links' );
}

//

function pathResolveLinkStep( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/pathResolveLinkStep' );
  let terminalPath = test.context.pathFor( 'written/pathResolveLinkStep/terminal' );
  let linkPath = test.context.pathFor( 'written/pathResolveLinkStep/link' );
  let link2Path = test.context.pathFor( 'written/pathResolveLinkStep/link2' );
  let link3Path = test.context.pathFor( 'written/pathResolveLinkStep/link3' );

  /* */

  test.open( 'absolute soft links' );

  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( link2Path, terminalPath );
  provider.softLink( linkPath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, link2Path );
  test.identical( got.relativePath, link2Path );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    relativeOriginalFile : 1,
    preservingRelative : 0
  })
  test.identical( got.filePath, link2Path );
  test.identical( got.relativePath, link2Path );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    relativeOriginalFile : 0,
    preservingRelative : 1
  })
  test.identical( got.filePath, link2Path );
  test.identical( got.relativePath, link2Path );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    relativeOriginalFile : 1,
    preservingRelative : 1
  })
  test.identical( got.filePath, link2Path );
  test.identical( got.relativePath, link2Path );
  test.identical( got.absolutePath, link2Path );

  test.close( 'absolute soft links' );

  /* */

  test.open( 'absolute text links' );

  provider.fieldPush( 'usingTextLink', 1 );

  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.textLink( link2Path, terminalPath );
  provider.textLink( linkPath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, link2Path );
  test.identical( got.relativePath, link2Path );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    relativeOriginalFile : 1,
    preservingRelative : 0
  })
  test.identical( got.filePath, link2Path );
  test.identical( got.relativePath, link2Path );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    relativeOriginalFile : 0,
    preservingRelative : 1
  })
  test.identical( got.filePath, link2Path );
  test.identical( got.relativePath, link2Path );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    relativeOriginalFile : 1,
    preservingRelative : 1
  })
  test.identical( got.filePath, link2Path );
  test.identical( got.relativePath, link2Path );
  test.identical( got.absolutePath, link2Path );

  provider.fieldPop( 'usingTextLink', 1 );

  test.close( 'absolute text links' );

  /* */

  test.open( 'relative soft links' );

  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( link2Path, '../terminal' );
  provider.softLink( linkPath, '../link2' );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, link2Path );
  test.identical( got.relativePath, link2Path );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    relativeOriginalFile : 0,
    preservingRelative : 1
  })
  test.identical( got.filePath, test.context.globalFromPreferred( '../link2' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../link2' ) );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    relativeOriginalFile : 1,
    preservingRelative : 0
  })
  test.identical( got.filePath, link2Path );
  test.identical( got.relativePath, link2Path );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    relativeOriginalFile : 1,
    preservingRelative : 1
  })
  test.identical( got.filePath, test.context.globalFromPreferred( '../link2' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../link2' ) );
  test.identical( got.absolutePath, link2Path );

  test.close( 'relative soft links' );

  /* */

  test.open( 'relative text links' );

  provider.fieldPush( 'usingTextLink', 1 );

  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.textLink( link2Path, '../terminal' );
  provider.textLink( linkPath, '../link2' );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, link2Path );
  test.identical( got.relativePath, link2Path );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    relativeOriginalFile : 0,
    preservingRelative : 1
  })
  test.identical( got.filePath, test.context.globalFromPreferred( '../link2' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../link2' ) );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    relativeOriginalFile : 1,
    preservingRelative : 0
  })
  test.identical( got.filePath, link2Path );
  test.identical( got.relativePath, link2Path );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1,
    relativeOriginalFile : 1,
    preservingRelative : 1
  })
  test.identical( got.filePath, test.context.globalFromPreferred( '../link2' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../link2' ) );
  test.identical( got.absolutePath, link2Path );

  provider.fieldPop( 'usingTextLink', 1 );

  test.close( 'relative text links' );

  /* */

  test.open( 'absolute soft link to missing' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : terminalPath, allowingMissed : 1 });

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
    allowingMissed : 0,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, null );
  test.identical( got.relativePath, null );
  test.identical( got.absolutePath, null );

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveLinkStep
    ({
      filePath : linkPath,
      resolvingSoftLink : 1,
      resolvingTextLink : 1,
      throwing : 1,
      allowingMissed : 0,
      allowingCycled : 0,
      relativeOriginalFile : 0,
      preservingRelative : 0
    })
  })

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, terminalPath );
  test.identical( got.relativePath, terminalPath );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, terminalPath );
  test.identical( got.relativePath, terminalPath );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 1
  })
  test.identical( got.filePath, terminalPath );
  test.identical( got.relativePath, terminalPath );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 1,
    preservingRelative : 1
  })
  test.identical( got.filePath, terminalPath );
  test.identical( got.relativePath, terminalPath );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 1,
    preservingRelative : 0
  })
  test.identical( got.filePath, terminalPath );
  test.identical( got.relativePath, terminalPath );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 0,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, linkPath );
  test.identical( got.relativePath, linkPath );
  test.identical( got.absolutePath, linkPath );

  test.close( 'absolute soft link to missing' );

  /* */

  test.open( 'absolute text link to missing' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : terminalPath, allowingMissed : 1 });

  provider.fieldPush( 'usingTextLink', 1 );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
    allowingMissed : 0,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, null );
  test.identical( got.relativePath, null );
  test.identical( got.absolutePath, null );

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveLinkStep
    ({
      filePath : linkPath,
      resolvingSoftLink : 1,
      resolvingTextLink : 1,
      throwing : 1,
      allowingMissed : 0,
      allowingCycled : 0,
      relativeOriginalFile : 0,
      preservingRelative : 0
    })
  })

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, terminalPath );
  test.identical( got.relativePath, terminalPath );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, terminalPath );
  test.identical( got.relativePath, terminalPath );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 1
  })
  test.identical( got.filePath, terminalPath );
  test.identical( got.relativePath, terminalPath );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 1,
    preservingRelative : 1
  })
  test.identical( got.filePath, terminalPath );
  test.identical( got.relativePath, terminalPath );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 1,
    preservingRelative : 0
  })
  test.identical( got.filePath, terminalPath );
  test.identical( got.relativePath, terminalPath );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 0,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, linkPath );
  test.identical( got.relativePath, linkPath );
  test.identical( got.absolutePath, linkPath );

  provider.fieldPop( 'usingTextLink', 1 );

  test.close( 'absolute text link to missing' );

  /* */

  test.open( 'relative soft link to missing' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../terminal', allowingMissed : 1 });

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
    allowingMissed : 0,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, null );
  test.identical( got.relativePath, null );
  test.identical( got.absolutePath, null );

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveLinkStep
    ({
      filePath : linkPath,
      resolvingSoftLink : 1,
      resolvingTextLink : 1,
      throwing : 1,
      allowingMissed : 0,
      allowingCycled : 0,
      relativeOriginalFile : 0,
      preservingRelative : 0
    })
  })

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, terminalPath );
  test.identical( got.relativePath, terminalPath );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, terminalPath );
  test.identical( got.relativePath, terminalPath );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 1
  })
  test.identical( got.filePath, context.globalFromPreferred( '../terminal' ) );
  test.identical( got.relativePath, context.globalFromPreferred( '../terminal' ) );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 1,
    preservingRelative : 1
  })
  test.identical( got.filePath, context.globalFromPreferred( '../terminal' ) );
  test.identical( got.relativePath, context.globalFromPreferred( '../terminal' ) );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 1,
    preservingRelative : 0
  })
  test.identical( got.filePath, terminalPath );
  test.identical( got.relativePath, terminalPath );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 0,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, linkPath );
  test.identical( got.relativePath, linkPath );
  test.identical( got.absolutePath, linkPath );

  test.close( 'relative soft link to missing' );

  /* */

  test.open( 'relative text link to missing' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : '../terminal', allowingMissed : 1 });

  provider.fieldPush( 'usingTextLink', 1 )

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
    allowingMissed : 0,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, null );
  test.identical( got.relativePath, null );
  test.identical( got.absolutePath, null );

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveLinkStep
    ({
      filePath : linkPath,
      resolvingSoftLink : 1,
      resolvingTextLink : 1,
      throwing : 1,
      allowingMissed : 0,
      allowingCycled : 0,
      relativeOriginalFile : 0,
      preservingRelative : 0
    })
  })

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, terminalPath );
  test.identical( got.relativePath, terminalPath );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, terminalPath );
  test.identical( got.relativePath, terminalPath );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 1
  })
  test.identical( got.filePath, context.globalFromPreferred( '../terminal' ) );
  test.identical( got.relativePath, context.globalFromPreferred( '../terminal' ) );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 1,
    preservingRelative : 1
  })
  test.identical( got.filePath, context.globalFromPreferred( '../terminal' ) );
  test.identical( got.relativePath, context.globalFromPreferred( '../terminal' ) );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 0,
    relativeOriginalFile : 1,
    preservingRelative : 0
  })
  test.identical( got.filePath, terminalPath );
  test.identical( got.relativePath, terminalPath );
  test.identical( got.absolutePath, terminalPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 0,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, linkPath );
  test.identical( got.relativePath, linkPath );
  test.identical( got.absolutePath, linkPath );

  provider.fieldPop( 'usingTextLink', 1 )

  test.close( 'relative text link to missing' );

  /* */

  test.open( 'context cycled soft link' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, allowingCycled : 1 });

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
    allowingMissed : 0,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, null );
  test.identical( got.relativePath, null );
  test.identical( got.absolutePath, null );

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveLinkStep
    ({
      filePath : linkPath,
      resolvingSoftLink : 1,
      resolvingTextLink : 1,
      throwing : 1,
      allowingMissed : 0,
      allowingCycled : 0,
      relativeOriginalFile : 0,
      preservingRelative : 0
    })
  })

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
    allowingMissed : 0,
    allowingCycled : 1,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, linkPath );
  test.identical( got.relativePath, linkPath );
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 1,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, linkPath );
  test.identical( got.relativePath, linkPath );
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 1,
    relativeOriginalFile : 0,
    preservingRelative : 1
  })
  test.identical( got.filePath, test.context.globalFromPreferred( '../link' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../link' ) );
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 1,
    relativeOriginalFile : 1,
    preservingRelative : 1
  })
  test.identical( got.filePath, test.context.globalFromPreferred( '../link' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../link' ) );
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 1,
    relativeOriginalFile : 1,
    preservingRelative : 0
  })
  test.identical( got.filePath, linkPath );
  test.identical( got.relativePath, linkPath );
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 0,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, linkPath );
  test.identical( got.relativePath, linkPath );
  test.identical( got.absolutePath, linkPath );

  test.close( 'context cycled soft link' );

  /* */

  test.open( 'context cycled text link' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, allowingCycled : 1 });

  provider.fieldPush( 'usingTextLink', 1 );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
    allowingMissed : 0,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, null );
  test.identical( got.relativePath, null );
  test.identical( got.absolutePath, null );

  test.shouldThrowErrorSync( () =>
  {
    provider.pathResolveLinkStep
    ({
      filePath : linkPath,
      resolvingSoftLink : 1,
      resolvingTextLink : 1,
      throwing : 1,
      allowingMissed : 0,
      allowingCycled : 0,
      relativeOriginalFile : 0,
      preservingRelative : 0
    })
  })

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
    allowingMissed : 0,
    allowingCycled : 1,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, linkPath );
  test.identical( got.relativePath, linkPath );
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 1,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, linkPath );
  test.identical( got.relativePath, linkPath );
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 1,
    relativeOriginalFile : 0,
    preservingRelative : 1
  })
  test.identical( got.filePath, test.context.globalFromPreferred( '../link' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../link' ) );
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 1,
    relativeOriginalFile : 1,
    preservingRelative : 1
  })
  test.identical( got.filePath, test.context.globalFromPreferred( '../link' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../link' ) );
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 1,
    relativeOriginalFile : 1,
    preservingRelative : 0
  })
  test.identical( got.filePath, linkPath );
  test.identical( got.relativePath, linkPath );
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 0,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, linkPath );
  test.identical( got.relativePath, linkPath );
  test.identical( got.absolutePath, linkPath );

  provider.fieldPop( 'usingTextLink', 1 );

  test.close( 'context cycled text link' );

  /* */

  test.open( 'cycled in chain of soft links' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link2', allowingMissed : 1 });
  provider.softLink({ dstPath : link2Path, srcPath : '../link', allowingMissed : 1, allowingCycled : 1 });

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
    allowingMissed : 0,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, link2Path );
  test.identical( got.relativePath, link2Path );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, link2Path );
  test.identical( got.relativePath, link2Path );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 0,
    allowingMissed : 0,
    allowingCycled : 1,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, link2Path );
  test.identical( got.relativePath, link2Path );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 1,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, link2Path );
  test.identical( got.relativePath, link2Path );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 1,
    relativeOriginalFile : 0,
    preservingRelative : 1
  })
  test.identical( got.filePath, test.context.globalFromPreferred( '../link2' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../link2' ) );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 1,
    relativeOriginalFile : 1,
    preservingRelative : 1
  })
  test.identical( got.filePath, test.context.globalFromPreferred( '../link2' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../link2' ) );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 1,
    relativeOriginalFile : 1,
    preservingRelative : 0
  })
  test.identical( got.filePath, link2Path );
  test.identical( got.relativePath, link2Path );
  test.identical( got.absolutePath, link2Path );

  var got = provider.pathResolveLinkStep
  ({
    filePath : linkPath,
    resolvingSoftLink : 0,
    resolvingTextLink : 1,
    throwing : 1,
    allowingMissed : 0,
    allowingCycled : 0,
    relativeOriginalFile : 0,
    preservingRelative : 0
  })
  test.identical( got.filePath, linkPath );
  test.identical( got.relativePath, linkPath );
  test.identical( got.absolutePath, linkPath );

  test.close( 'cycled in chain of soft links' );

}

//

function pathNativize( t )
{
  let context = this;
  let provider = context.provider;

  if( !_.routineIs( provider.path.nativize ) )
  return;

  if( !( provider instanceof _.FileProvider.HardDrive ) )
  {
    t.description = 'nativize returns src'
    t.identical( 1, 1 )
    return;
  }

  if( Config.interpreter === 'njs' && process.platform === 'win32' )
  {
    t.description = 'path in win32 style ';

    /**/

    debugger
    var path = '/A/abc/';
    var got = provider.path.nativize( path );
    var expected = 'A:\\abc\\';
    t.identical( got, expected );

    /**/

    var path = '/A/';
    var got = provider.path.nativize( path );
    var expected = 'A:\\';
    t.identical( got, expected );

    /**/

    var path = '/A';
    var got = provider.path.nativize( path );
    // var expected = 'A:\\';
    var expected = 'A:\\';
    t.identical( got, expected );

    /**/

    var path = '/A/a';
    var got = provider.path.nativize( path );
    var expected = 'A:\\a';
    t.identical( got, expected );

    /**/

    var path = 'A:/a';
    var got = provider.path.nativize( path );
    var expected = 'A:\\a';
    t.identical( got, expected );

    /**/

    var path = '\\A\\a';
    var got = provider.path.nativize( path );
    var expected = 'A:\\a';
    t.identical( got, expected );

    /**/

    var path = 'A';
    var got = provider.path.nativize( path );
    var expected = 'A';
    t.identical( got, expected );

    /**/

    var path = '/c/a';
    var got = provider.path.nativize( path );
    var expected = 'c:\\a';
    t.identical( got, expected );

    /**/

    var path = '/A/1.txt';
    var got = provider.path.nativize( path );
    var expected = 'A:\\1.txt';
    t.identical( got, expected );

    /**/

    var path = 'A:/a\\b/c\\d';
    var got = provider.path.nativize( path );
    var expected = 'A:\\a\\b\\c\\d';
    t.identical( got, expected );
  }

  /* */

  if( Config.debug )
  {
    t.description = 'path is not a string ';
    t.shouldThrowErrorSync( function()
    {
      provider.path.nativize( 1 );
    })
  }
}

// --
// static
// --

function encodersFromGdfs( test )
{
  let context = this;
  let provider = context.provider;
  let writeConverters = _.gdf.inMap[ 'structure' ];
  let readConverters = _.gdf.outMap[ 'structure' ];

  /* */

  test.case = 'check if all write encoders are generated';
  _checkEncoders( _.files.WriteEncoders, writeConverters, 1 );

  /* */

  test.case = 'check if all read encoders are generated';
  _checkEncoders( _.files.ReadEncoders, readConverters, 0 );

  /* */

  test.case = 'add and remove write gdf';

  test.will = 'encoder and gdf should not exist';
  test.is( !_.files.WriteEncoders[ 'testEncoder' ] );
  test.is( !_.gdf.extMap[ 'testEncoder' ] || !_.gdf.extMap[ 'testEncoder' ].length );
  var testConverter =
  {
    ext : [ 'testEncoder' ],
    inFormat : [ 'structure' ],
    outFormat : [ 'string.utf8' ],
    feature : {},
    onEncode : function( op )
    {
      op.out.data = _.toStr( op.out.data, { levels : 99 } );
      // op.out.format = 'string';
    }
  }
  var gdf = _.Gdf([ testConverter ])[ 0 ];

  test.will = 'encoder should not exist';
  test.is( !_.files.WriteEncoders[ 'testEncoder' ] );

  test.will = 'update encoders, encoder should exist';
  _.files.encoder.fromGdfs();
  var encoder = _.files.WriteEncoders[ 'testEncoder' ];
  test.is( _.mapIs( encoder ) );
  test.identical( encoder.exts, gdf.ext );
  test.identical( encoder.gdf, gdf );

  test.will = 'finit gdf, encoder should exist';
  gdf.finit();
  test.is( _.mapIs( _.files.WriteEncoders[ 'testEncoder' ] ) );
  _.files.encoder.fromGdfs();
  test.will = 'update encoders, encoder should not exist';
  test.is( !_.files.WriteEncoders[ 'testEncoder' ] );

  /* */

  test.case = 'adjust gdf exts'
  var testConverter =
  {
    ext : [ 'testEncoder' ],
    inFormat : [ 'structure' ],
    outFormat : [ 'string.utf8' ],
    feature : {},
    onEncode : function( op )
    {
      op.out.data = _.toStr( op.out.data, { levels : 99 } );
      // op.out.format = 'string';
    }
  }
  var gdf = _.Gdf([ testConverter ])[ 0 ];
  var ext = 'testExt';
  let originalExt = gdf.ext.slice();
  gdf.ext = [ ext ];
  test.is( !_.mapIs( _.files.WriteEncoders[ ext ] ) );
  _.files.encoder.fromGdfs();
  var encoder = _.files.WriteEncoders[ ext ];
  test.is( _.mapIs( encoder ) );
  test.identical( encoder.exts, gdf.ext );
  test.identical( encoder.gdf, gdf );
  gdf.ext = originalExt.slice();
  gdf.finit();
  _.files.encoder.fromGdfs();
  test.is( !_.mapIs( _.files.WriteEncoders[ ext ] ) );

  /* - */

  function _checkEncoders( encoders, converters, writing )
  {
    _.each( converters, ( gdf ) =>
    {
      _.each( gdf.ext, ( ext ) =>
      {
        if( encoders[ ext ].gdf.feature.default )
        {
          test.will = 'Expects only one default gdf for encoder: ' + ext;
          if( ext === 'json' )
          debugger;
          if( ext === 'json.min' )
          debugger;

          let defaultConverter = _.gdf.extMap[ ext ].filter( ( c ) => !!c.feature.default );

          defaultConverter = defaultConverter.filter( ( c ) => !writing ^ _.strHas( c.inFormat[ 0 ], 'structure' ) );

          test.identical( defaultConverter.length, 1 );
          test.will = ext + ' encoder should exist';
          test.is( _.mapIs( encoders[ ext ] ) );
          test.will = ext + ' encoder should use default gdf: ' + defaultConverter[ 0 ].name;
          test.is( encoders[ ext ].gdf === defaultConverter[ 0 ] );
        }
        else
        {
          test.will = ext + ' encoder should exist';
          test.is( _.mapIs( encoders[ ext ] ) );
          test.will = ext + ' encoder should exist and use gdf: ' + gdf.name;
          // if( encoders[ ext ].gdf !== gdf )
          // debugger;
          test.is( encoders[ ext ].gdf === gdf );
        }

        test.will = ext + ' encoder should have onBegin/onEnd or both';

        if( _.files.WriteEncoders[ ext ] )
        {
          test.is( _.routineIs( encoders[ ext ].onBegin ) );
        }
        else
        {
          test.is( _.routineIs( encoders[ ext ].onBegin ) );
          test.is( _.routineIs( encoders[ ext ].onEnd ) );
        }

        test.will = ext + ' encoder should have exts arrays';
        test.is( _.arrayIs( encoders[ ext ].exts ) )
      })
    })
  }
}

// --
// experiment
// --

function fileCopyExperiment( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/fileCopyExperiment' );
  let srcPath = provider.path.join( routinePath, 'src' );
  let dstPath = provider.path.join( routinePath, 'dst' );

  /*

    src, dst - both are context soft links

    1. dstPath fails to resolve, dstStat is null, dstPath is not changed because allowingMissed is 1 by default
    2. verifyDst is called because fileExists check gives true
       verifyDst throws an error because does not expect to see dstStat as null in this case


    Expected behaviour :

    dstStat is created in verifyDst, stat from pathResolveLinkFull is not be used
    dstPath is be rewritten by soft link from srcPath

  */

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var got = provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    resolvingSrcSoftLink : 0,
    resolvingDstSoftLink : 1,
    allowingMissed : 0,
    throwing : 0
  });

  test.identical( got, true );
  test.identical( srcPath, srcPath );
  test.identical( dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );

}

//

function statReadExperiment( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/statReadExperiment' );
  let srcPath = provider.path.join( routinePath, 'src' );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    debugger
    provider.statRead({ filePath : srcPath, throwing : 1 });
    debugger;
  })

  /* - */

  var got = provider.statRead({ filePath : srcPath, throwing : 0 });
  test.identical( got, null );

}

//

function experiment( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  debugger;
  var got = provider.dirRead( '/xxx' );
  debugger;

}

experiment.experimental = 1;

//

function hardLinkExperiment( test )
{
  let context = this;
  let provider = context.provider;
  let path = provider.path;

  var delay = 50;

  function makeFiles( names, dirPath, sameTime )
  {
    let ready = new _.Consequence().take( null );
    var paths = names.map( ( name, i ) =>
    {
      var filePath = context.pathFor( path.join( dirPath, name ) );
      provider.fileWrite({ filePath, data : filePath, purging : 1 });

      if( sameTime )
      {
        var time = delay * 1000;
        provider.timeWrite( filePath, time, time );
      }
      else if( i > 0 )
      {
        ready.then( () =>
        {
          return _.time.out( delay ).then( () =>
          {
            return provider.fileWrite({ filePath, data : path.name( filePath ), sync : 0 });
          })
        })
      }

      return filePath;
    });

    ready.deasync();

    return paths;
  }

  function makeHardLinksToPath( filePath, amount )
  {
    let routinePath = path.join( context.provider.path.dir( filePath ), _.idWithDateAndTime() );
    provider.dirMake( routinePath )
    for( var i = 0; i < amount; i++ )
    provider.hardLink( path.join( routinePath, 'file' + i ), filePath );
  }


  var routinePath = test.context.pathFor( 'written/hardLink' );
  var srcPath, dstPath;

  var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
  test.case = 'sourceMode: src - oldest file with maximal amount of links';
  var paths = makeFiles( fileNames, routinePath );
  test.is( paths.length >= 3 );
  makeHardLinksToPath( paths[ 0 ], 3 ); // #1 most linked+oldest file
  makeHardLinksToPath( paths[ paths.length - 1 ], 4 ); // #2 most linked+newest file
  paths = provider.path.s.normalize( paths );
  var records = provider.recordFactory().records( paths );
  logger.log( _.select( records, '*/name' ) )
  logger.log( 'nlink: ', _.select( records, '*/stat/nlink' ) )
  logger.log( 'atime: ', _.select( records, '*/stat/atime' ).map( ( r ) => r.getTime() ) )
  logger.log( 'mtime: ', _.select( records, '*/stat/mtime' ).map( ( r ) => r.getTime() ) )
  logger.log( 'ctime: ', _.select( records, '*/stat/ctime' ).map( ( r ) => r.getTime() ) )
  logger.log( 'birthtime: ', _.select( records, '*/stat/birthtime' ).map( ( r ) => r.getTime() ) )
  var selectedFile = provider._recordsSort({ src : records, sorter : 'modified<hardlinks>' });
  provider.hardLink
  ({
    dstPath : paths,
    sourceMode : 'modified<hardlinks>'
  });
  test.identical( provider.areHardLinked( paths ), true );
  var srcPath = paths[ 0 ];
  test.identical( selectedFile.absolute, srcPath );
  test.identical( Number( selectedFile.stat.nlink ), 4 );
  var src = provider.fileRead( srcPath );
  var dst = provider.fileRead( paths[ paths.length - 1 ] );
  test.identical( src, dst );

}

hardLinkExperiment.experimental = 1;

//

function hardLinkReturnSync( test )
{
/*
  // dst does not exist && directory does not exist -> 8
 - rewriting : 1
 - rewriting : 0

 - rewritingDirs : 1
 - rewritingDirs : 0

 - makingDirectory : 1

 - breakingSrcHardLink : 0, breakingDstHardLink : 1
 - breakingSrcHardLink : 1, breakingDstHardLink : 0
 - breakingSrcHardLink : 1, breakingDstHardLink : 1

// dst does not exist && directory exists -> 8
 - rewriting : 1
 - rewriting : 0

 - rewritingDirs : 1
 - rewritingDirs : 0

 - makingDirectory : 1

 - breakingSrcHardLink : 0, breakingDstHardLink : 1
 - breakingSrcHardLink : 1, breakingDstHardLink : 0
 - breakingSrcHardLink : 1, breakingDstHardLink : 1

// dst exists, is not hard linked -> 6
 - rewriting : 1

 - rewritingDirs : 1

 - makingDirectory : 1

 - breakingSrcHardLink : 0, breakingDstHardLink : 1
 - breakingSrcHardLink : 1, breakingDstHardLink : 0
 - breakingSrcHardLink : 1, breakingDstHardLink : 1

// dst exists, is hard linked -> 6
 - rewriting : 1

 - rewritingDirs : 1

 - makingDirectory : 1

 - breakingSrcHardLink : 0, breakingDstHardLink : 1
 - breakingSrcHardLink : 1, breakingDstHardLink : 0
 - breakingSrcHardLink : 1, breakingDstHardLink : 1

// src === dst -> 8
 - rewriting : 1
 - rewriting : 0

 - rewritingDirs : 1
 - rewritingDirs : 0

 - makingDirectory : 1

 - breakingSrcHardLink : 0, breakingDstHardLink : 1
 - breakingSrcHardLink : 1, breakingDstHardLink : 0
 - breakingSrcHardLink : 1, breakingDstHardLink : 1

total : 36
*/
  let context = this;
  let a = context.assetFor( test, false ); /* qqq3 */

  /* */

  test.open( 'dst does not exist && directory does not exist' );

  test.case = 'rewriting : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dst' ), srcPath : a.abs( 'src' ), rewriting : 1 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'rewriting : 0';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dst' ), srcPath : a.abs( 'src' ), rewriting : 0 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'rewritingDirs : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.dirMake( a.abs( 'dir1/dir2/dst' ) );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/dir2/dst' ), srcPath : a.abs( 'src' ), rewritingDirs : 1 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dir2/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'rewritingDirs : 0';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.dirMake( a.abs( 'dir1/dir2' ) );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/dir2/dst' ), srcPath : a.abs( 'src' ), rewritingDirs : 0 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dir2/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'makingDirectory : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/dir2/dst' ), srcPath : a.abs( 'src' ), makingDirectory : 1 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dir2/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'breakingSrcHardLink : 0, breakingDstHardLink : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dst' ),
    srcPath : a.abs( 'src' ),
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1
  });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'breakingSrcHardLink : 1, breakingDstHardLink : 0';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dst' ),
    srcPath : a.abs( 'src' ),
    breakingSrcHardLink : 1,
    breakingDstHardLink : 0
  });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'breakingSrcHardLink : 1, breakingDstHardLink : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dst' ),
    srcPath : a.abs( 'src' ),
    breakingSrcHardLink : 1,
    breakingDstHardLink : 1
  });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dst' ), a.abs( 'src' ) ), true );

  test.close( 'dst does not exist && directory does not exist' );

  /* */

  test.open( 'dst does not exist && directory exists' );

  test.case = 'rewriting : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/test' ), 'some text' );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/dst' ), srcPath : a.abs( 'src' ), rewriting : 1 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'rewriting : 0';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/test' ), 'some text' );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/dst' ), srcPath : a.abs( 'src' ), rewriting : 0 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'rewritingDirs : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/test' ), 'some text' );
  a.fileProvider.dirMake( a.abs( 'dir1/dst' ) );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/dst' ), srcPath : a.abs( 'src' ), rewritingDirs : 1 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'rewritingDirs : 0';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/test' ), 'some text' );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/dst' ), srcPath : a.abs( 'src' ), rewritingDirs : 0 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'makingDirectory : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/test' ), 'some text' );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/dir2/dst' ), srcPath : a.abs( 'src' ), makingDirectory : 1 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dir2/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'breakingSrcHardLink : 0, breakingDstHardLink : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/test' ), 'some text' );
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dir1/dst' ),
    srcPath : a.abs( 'src' ),
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1
  });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'breakingSrcHardLink : 1, breakingDstHardLink : 0';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/test' ), 'some text' );
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dir1/dst' ),
    srcPath : a.abs( 'src' ),
    breakingSrcHardLink : 1,
    breakingDstHardLink : 0
  });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'breakingSrcHardLink : 1, breakingDstHardLink : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/test' ), 'some text' );
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dir1/dst' ),
    srcPath : a.abs( 'src' ),
    breakingSrcHardLink : 1,
    breakingDstHardLink : 1
  });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  test.close( 'dst does not exist && directory exists' );

  /* */

  test.open( 'dst exists, is not hard linked' );

  test.case = 'rewriting : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/dst' ), 'some text' );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/dst' ), srcPath : a.abs( 'src' ), rewriting : 1 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'rewritingDirs : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/dst' ), 'some text' );
  a.fileProvider.dirMake( a.abs( 'dir1/dst' ) );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/dst' ), srcPath : a.abs( 'src' ), rewritingDirs : 1 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'makingDirectory : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/dst' ), 'some text' );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/dst' ), srcPath : a.abs( 'src' ), makingDirectory : 1 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'breakingSrcHardLink : 0, breakingDstHardLink : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/dst' ), 'some text' );
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dir1/dst' ),
    srcPath : a.abs( 'src' ),
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1
  });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'breakingSrcHardLink : 1, breakingDstHardLink : 0';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/dst' ), 'some text' );
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dir1/dst' ),
    srcPath : a.abs( 'src' ),
    breakingSrcHardLink : 1,
    breakingDstHardLink : 0
  });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'breakingSrcHardLink : 1, breakingDstHardLink : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/dst' ), 'some text' );
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dir1/dst' ),
    srcPath : a.abs( 'src' ),
    breakingSrcHardLink : 1,
    breakingDstHardLink : 1
  });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  test.close( 'dst exists, is not hard linked' );

  /* */

  test.open( 'dst exists, is hard linked' );

  test.case = 'rewriting : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/dst' ), 'some text' );
  a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/dst' ), srcPath : a.abs( 'src' ), rewriting : 1 });
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/dst' ), srcPath : a.abs( 'src' ), rewriting : 1 });
  test.identical( got, false );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'rewritingDirs : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/dst' ), 'some text' );
  a.fileProvider.dirMake( a.abs( 'dir1/dst' ) );
  a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/dst' ), srcPath : a.abs( 'src' ), rewritingDirs : 1 });
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/dst' ), srcPath : a.abs( 'src' ), rewritingDirs : 1 });
  test.identical( got, false );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'makingDirectory : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/dst' ), 'some text' );
  a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/dst' ), srcPath : a.abs( 'src' ), makingDirectory : 1 });
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/dst' ), srcPath : a.abs( 'src' ), makingDirectory : 1 });
  test.identical( got, false );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'breakingSrcHardLink : 0, breakingDstHardLink : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/dst' ), 'some text' );
  a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dir1/dst' ),
    srcPath : a.abs( 'src' ),
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1
  });
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dir1/dst' ),
    srcPath : a.abs( 'src' ),
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1
  });
  test.identical( got, false );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'breakingSrcHardLink : 1, breakingDstHardLink : 0';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/dst' ), 'some text' );
  a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dir1/dst' ),
    srcPath : a.abs( 'src' ),
    breakingSrcHardLink : 1,
    breakingDstHardLink : 0
  });
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dir1/dst' ),
    srcPath : a.abs( 'src' ),
    breakingSrcHardLink : 1,
    breakingDstHardLink : 0
  });
  test.identical( got, false );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  /* */

  test.case = 'breakingSrcHardLink : 1, breakingDstHardLink : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/dst' ), 'some text' );
  a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dir1/dst' ),
    srcPath : a.abs( 'src' ),
    breakingSrcHardLink : 1,
    breakingDstHardLink : 1
  });
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dir1/dst' ),
    srcPath : a.abs( 'src' ),
    breakingSrcHardLink : 1,
    breakingDstHardLink : 1
  });
  test.identical( got, false );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dst' ), a.abs( 'src' ) ), true );

  test.close( 'dst exists, is hard linked' );

  /* */

  test.open( 'src === dst' );

  test.case = 'rewriting : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'dir1/src' ), 'some text' );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/src' ), srcPath : a.abs( 'dir1/src' ), rewriting : 1 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/src' ), a.abs( 'dir1/src' ) ), true );

  /* */

  test.case = 'rewriting : 0';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'dir1/src' ), 'some text' );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/src' ), srcPath : a.abs( 'dir1/src' ), rewriting : 0 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/src' ), a.abs( 'dir1/src' ) ), true );

  /* */

  test.case = 'rewritingDirs : 1';
  a.reflect();
  a.fileProvider.dirMake( a.abs( 'dir1/src' ) );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/src' ), srcPath : a.abs( 'dir1/src' ), rewritingDirs : 1 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/src' ), a.abs( 'dir1/src' ) ), true );

  /* */

  test.case = 'rewritingDirs : 0';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'dir1/src' ), 'some text' );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/src' ), srcPath : a.abs( 'dir1/src' ), rewritingDirs : 0 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/src' ), a.abs( 'dir1/src' ) ), true );

  /* */

  test.case = 'makingDirectory : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'dir1/src' ), 'some text' );
  var got = a.fileProvider.hardLink({ dstPath : a.abs( 'dir1/src' ), srcPath : a.abs( 'dir1/src' ), makingDirectory : 1 });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/src' ), a.abs( 'dir1/src' ) ), true );

  /* */

  test.case = 'breakingSrcHardLink : 0, breakingDstHardLink : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'dir1/src' ), 'some text' );
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dir1/src' ),
    srcPath : a.abs( 'dir1/src' ),
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1
  });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/src' ), a.abs( 'dir1/src' ) ), true );

  /* */

  test.case = 'breakingSrcHardLink : 1, breakingDstHardLink : 0';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'dir1/src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/src' ), 'some text' );
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dir1/src' ),
    srcPath : a.abs( 'dir1/src' ),
    breakingSrcHardLink : 1,
    breakingDstHardLink : 0
  });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/src' ), a.abs( 'dir1/src' ) ), true );

  /* */

  test.case = 'breakingSrcHardLink : 1, breakingDstHardLink : 1';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'dir1/src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dir1/src' ), 'some text' );
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dir1/src' ),
    srcPath : a.abs( 'dir1/src' ),
    breakingSrcHardLink : 1,
    breakingDstHardLink : 1
  });
  test.identical( got, true );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/src' ), a.abs( 'dir1/src' ) ), true );

  test.close( 'src === dst' );

}

//

function hardLinkReturnThrowing0Sync( test )
{
  let context = this;
  let a = context.assetFor( test, false );

  test.case = 'src does not exists';
  a.reflect();
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dst' ),
    srcPath : a.abs( 'src' ),
    throwing : 0,
  });
  test.identical( got, null );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dst' ), a.abs( 'src' ) ), false );

  /* */

  test.case = 'rewriting : 0';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  a.fileProvider.fileWrite( a.abs( 'dst' ), 'some text' );
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dst' ),
    srcPath : a.abs( 'src' ),
    throwing : 0,
    rewriting : 0,
  });
  test.identical( got, null );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dst' ), a.abs( 'src' ) ), false );

  /* */

  test.case = 'makingDirectory : 0';
  a.reflect();
  a.fileProvider.fileWrite( a.abs( 'src' ), 'some text' );
  var got = a.fileProvider.hardLink
  ({
    dstPath : a.abs( 'dir1/dir2/dst' ),
    srcPath : a.abs( 'src' ),
    throwing : 0,
    makingDirectory : 0,
  });
  test.identical( got, null );
  test.identical( a.fileProvider.areHardLinked( a.abs( 'dir1/dir2/dst' ), a.abs( 'src' ) ), false );
}

//

// function hardLinkReturnSoftLinkedSync( test )
// {
//   let context = this;
//   let a = context.assetFor( test, false );

//   /*
//   - resolvingSrcSoftLink: 1
//   - resolvingSrcSoftLink: 0

//   - resolvingDstSoftLink: 1
//   - resolvingDstSoftLink: 0
//   */
// }

// --
// declare
// --

let Self =
{

  name : 'Tools.mid.files.fileProvider.Abstract',
  abstract : 1,
  silencing : 1,
  routineTimeOut : 60000,

  onSuiteBegin,
  onSuiteEnd,
  onRoutineEnd,

  context :
  {

    assetFor,
    pathFor,
    providerIsInstanceOf,
    softLinkIsSupported,
    providerMake : null,
    system : null, /* xxx qqq : remove the field */

    suiteTempPath : null,
    assetsOriginalPath : null,
    appJsPath : null,

  },

  tests :
  {

    //testDelaySample,
    mustNotThrowError,

    readWriteSync,
    readWriteAsync,

    fileWriteActSync,
    fileWriteActAsync,

    fileReadJson,
    fileWriteJson,

    fileReadWithEncoding,
    fileWriteWithEncoding,

    fileTouch,
    timeWrite,

    writeAsyncThrowingError,

    // qqq : extend linking routines with cases using resolvingSrcSoftLink:2 and resolvingSrcTextLink:0-2

    fileCopyActSync,
    fileCopyActAsync,
    fileCopySync,
    fileCopyRelativePath,
    fileCopyLinksSync,
    fileCopyAsync,
    fileCopyLinksAsync,
    fileCopySoftLinkResolving,
    fileCopyAsyncThrowingError,
    fileCopyLinks,
    fileCopyError,
    fileCopySoftLinkExtended,
    fileCopyResolvingBasic,
    fileCopyGlobal,
    fileCopyRelativeLinking,
    fileCopyHardLinkedSync,
    fileCopyHardLinkedAsync,

    fileRenameSync,
    fileRenameRelativePath,
    fileRenameAsync,
    fileRenameActSync,
    fileRenameSync2,
    fileRenameSoftLinkResolving,
    fileRenameResolvingBasic,
    fileRenameGlobal,
    fileRenameRelativeSoftLinking,
    fileRenameRelativeTextLinking,
    fileRenameHardLinkedSync,
    fileRenameHardLinkedAsync,

    fileDeleteSync,
    fileDeleteActSync,
    fileDeleteAsync,
    // fileDeleteLocked
    fileDeletePathEscaped,
    fileDeletePerfomance,

    fileLockWaitingSharingSync,
    fileLockWaitingSharingAsync,
    fileLockWaitingNotSharingSync,
    fileLockWaitingNotSharingAsync,
    fileLockNotWaitingSharingSync,
    fileLockNotWaitingSharingAsync,
    fileLockNotWaitingNotSharingSync,
    fileLockNotWaitingNotSharingAsync,

    fileUnlockSync,
    fileIsLockedSync,

    statResolvedReadSync,
    statReadActSync,
    statResolvedReadAsync,
    statReadActLinkedHead,

    dirMakeSync,
    dirMakeLinksSync,
    dirMakeAsync,

    hashReadSync,
    hashReadAsync,

    dirReadSync,
    dirReadSyncOutputFormats,
    dirReadAsync,

    fileWriteSync,
    fileWriteLinksSync,
    fileWriteAsync,
    fileWriteLinksAsync,

    fileReadAsync,

    softLinkSync,
    softLinkAsync,
    softLinkRelativePath,
    softLinkChain,
    softLinkActSync,
    softLinkSoftLinkResolving,
    softLinkRelativeLinkResolving,
    softLinkMakeAndResolve,
    softLinkResolvingBasic,
    softLinkGlobal,
    softLinkRelativeSoftLinking,
    softLinkRelativeTextLinking,
    softLinkToParentDirectorySync,
    softLinkToParentDirectoryAsync,
    softLinkHardLinkedSync,
    softLinkHardLinkedAsync,

    textLinkSync,
    textLinkResolvingBasic,
    textLinkGlobal,
    textLinkRelativeTextLinking,
    textLinkRelativeSoftLinking,
    textLinkHardLinkedSync,
    textLinkHardLinkedAsync,

    hardLinkSync,
    hardLinkMultipleSync,
    hardLinkRelativePath,
    hardLinkSoftlinked,
    hardLinkActSync,
    hardLinkAsync,
    hardLinkActAsync,
    hardLinkSoftLinkResolving,
    hardLinkHardLinkBreaking,
    hardLinkResolvingBasic,
    hardLinkGlobal,
    hardLinkRelativeSoftLinking,
    hardLinkRelativeTextLinking,
    hardLinkHardLinkedSync,
    hardLinkHardLinkedAsync,

    hardLinkEscapedPath, /* xxx */

    hardLinkReturnSync,

    // qqq3 : implement
    // hardLinkReturnSync,
    // hardLinkReturnAsync,
    // hardLinkReturnThrowing0Sync,
    // hardLinkReturnThrowing0Async,
    // hardLinkReturnSoftLinkedSync,
    // hardLinkReturnSoftLinkedAsync,
    // hardLinkReturnTextLinkedSync,
    // hardLinkReturnTextLinkedAsync,

    /* qqq3 : extend linking tests to check returned value. must be false if success, but no change was done */

    fileExchangeSync,
    fileExchangeAsync,

    //etc

    // hardLinkSyncRunner,
    // hardLinkAsyncRunner,

    isDir,
    dirIsEmpty,

    isTerminal,
    isSoftLink,
    isTextLink,
    isHardLink,
    isLink,
    fileStatIs,

    areHardLinked,
    areTextLinked,
    areSoftLinked,
    filesCanBeSame,

    rightsSet,

    statsAreHardLinked,

    filesSize, /* xxx : move out */
    fileSize,

    fileExists,
    fileExistsCompliantBehavior,

    // record

    record,
    recordStat,

    // path

    localsFromGlobals,
    globalsFromLocals,

    pathResolve,
    uriResolve,

    linkingCriticalCases,
    pathResolveLinkTailChain,
    pathResolveLinkFull,
    pathResolveLinkFullRecursive,
    pathResolveSoftLink,
    pathResolveSoftLinkExtended,
    pathResolveTextLink,
    pathResolveTextLinkExtended,
    pathResolveLinkFullSpecial,
    pathResolveLinkFullResult,
    pathResolveLinkStep,

    pathNativize,

    // static

    encodersFromGdfs,

    // experiment

    fileCopyExperiment,
    statReadExperiment,
    experiment,
    hardLinkExperiment,

  }

};

wTestSuite( Self );

})();
